\documentclass{article}
\usepackage{graphicx} % Required for inserting images

\title{projectAplikom}
\author{Nur Alya Fadilah}
\date{November 2024}

\begin{document}
\section{EMT UNTUK ALJABAR}
# Excercise Nama  : Nur Alya Fadilah


Kelas : Matematika E 2023


# R.2

49. Menyederhanakan


$$\bigg(\frac{24a^{10}b^{-8}c^{7}}{12a^6b^{-3}c^5}\bigg)^{-5}$$\>$&((24\*a^(10)\*b^(-8)\*c^(7))/(12\*a^6\*b^(-3)\*c^(5)))^(-5)


$$\frac{b^{25}}{32\,a^{20}\,c^{10}}$$50. Menyederhanakan


$$\bigg(\frac{125p^{12}q^{-14}r^{22}}{25p^8q^6r^{-15}} \bigg)^{-4}$$\>$&((125\*p^(12)\*q^(-14)\*r^(22))/(25\*p^8\*q^6\*r^(-15)))^(-4)


$$\frac{q^{80}}{625\,p^{16}\,r^{148}}$$90. Hitung


$$2^6 \cdot 2^{-3} \div 2^{10} \div 2^{-8}$$\>$&2^6\*2^(-3)/2^(10)/2^(-8)


$$2$$91. Hitung


$$\frac{4(8-6)^2-4\cdot3+2\cdot8}{3^1+19^0}$$\>$&(4\*(8-6)^2-4\*3+2\*8)/(3^1+19^0)


$$5$$92. Hitung


$$\frac{[4(8-6)^2+4](3-2\cdot8)}{2^2(2^3+5)}$$\>$&((4\*(8-6)^2+4)\*(3-2\*8)/(2^2\*(2^3+5)))


$$-5$$105. Menyederhanakan


$$\bigg[ \frac{(3x^ay^b)^3}{(-3x^ay^b)^2}\bigg]^2$$\>$&(((3\*x^a\*y^b)^3)/(-3\*x^a\*y^b)^2)^2


$$9\,x^{2\,a}\,y^{2\,b}$$# R.3

14. Hitung


$$(8y^5)(9y)$$\>$&(8\*y^5)\*(9\*y)


$$72\,y^6$$13. Hitung


$$(3a^2)(-7a^4)$$\>$&(3\*a^2)\*(-7\*a^4)


$$-21\,a^6$$15. Hitung


$$(6xy^3)(9x^4y^2)$$\>$&(6\*x\*y^3)\*(9\*x^4\*y^2)


$$54\,x^5\,y^5$$27. Hitung


$$(x+3)^2$$\>$&expand((x+3)^2)


$$x^2+6\,x+9$$29. Hitung


$$(y-5)^2$$\>$&expand((y-5)^2)


$$y^2-10\,y+25$$# R.4

121. Faktorkan


$$y^4 - 84+5y^2$$\>$&factor(y^4-84+5\*y^2)


$$\left(y^2-7\right)\,\left(y^2+12\right)$$122. Faktorkan


$$11x^2+x^4-80$$\>$&factor(11\*x^2+x^4-80)


$$\left(x^2-5\right)\,\left(x^2+16\right)$$127. Faktorkan


$$x^2-x+\frac{1}{4}$$\>$&factor(x^2-x+(1/4))


$$\frac{\left(2\,x-1\right)^2}{4}$$125. Faktorkan


$$x^2 + 3x \frac{9}{4}$$\>$&factor(x^2+3\*x+9/4)


$$\frac{\left(2\,x+3\right)^2}{4}$$126. Faktorkan


$$x^2 -5x + \frac{25}{4}$$\>$&factor(x^2-5\*x+25/4)


$$\frac{\left(2\,x-5\right)^2}{4}$$# R.5

31. Menyelesaikan sistem persamaan


\>$&solve(7\*(3\*x+6)=11-(x+2))


$$\left[ x=-\frac{3}{2} \right] $$32. Menyelesaikan sistem persamaan


\>$&solve(9\*(2\*x+8)=20-(x+5))


$$\left[ x=-3 \right] $$35. Menyelesaikan sistem persamaan


$$ x^2+3x-28=0$$\>$&solve(x^2+3\*x-28=0)


$$\left[ x=4 , x=-7 \right] $$53. Menyelesaikan sistem persamaan


$$x^2-36=0$$\>$&solve(x^2-36=0)


$$\left[ x=-6 , x=6 \right] $$55. Menyelesaikan sistem persamaan


$$z^2=144$$\>$&solve(z^2=144)


$$\left[ z=-12 , z=12 \right] $$# R.6

18. Sederhanakan


$$\frac{x^2-y^2}{(x-y)^2}\cdot \frac{1}{x+y}$$\>$&ratsimp(((x^2-y^2)/(x-y)^2)\*1/(x+y))


$$-\frac{1}{y-x}$$31. Sederhanakan


$$\frac{7}{5x} + \frac{3}{5x}$$\>$&ratsimp(7/(5\*x) + 3/(5\*x))


$$\frac{2}{x}$$15. Sederhanakan


$$\frac{4-x}{x^2+4x-32}$$\>$&ratsimp((4-x)/(x^2+4\*x-32))


$$-\frac{1}{x+8}$$16. Sederhanakan


$$\frac{6-x}{x^2-36}$$\>$&ratsimp((6-x)/(x^2-36))


$$-\frac{1}{x+6}$$71. Sederhanakan


$$\frac{(x+h)^2-x^2}{h}$$\>$&ratsimp(((x+h)^2-x^2)/h)


$$2\,x+h$$# R.7

3. Sederhanakan


$$\sqrt[5]{32}$$\>$32^(1/5)


$$2$$13. Sederhanakan


$$\sqrt{180}$$\>$sqrt(180)


$$6\,\sqrt{5}$$14. Sederhanakan


$$\sqrt{48}$$\>$sqrt(48)


$$4\,\sqrt{3}$$15. Sederhanakan


$$\sqrt{72}$$\>$sqrt(72)


$$3\,2^{\frac{3}{2}}$$125. Sederhanakan


$$\sqrt{1+x^2}+\frac{1}{\sqrt{1+x^2}}$$\>$ratsimp(sqrt(1+x^2)+1/sqrt(1+x^2))


$$\frac{x^2+2}{\sqrt{x^2+1}}$$# Review Exercises

70. Kalikan


$$(x^n+10)(x^n-4)$$\>$expand((x^n+10)\*(x^n-4))


$$x^{2\,n}+6\,x^{n}-40$$71. Kalikan


$$(t^n+t^{-a})^2$$\>$expand((t^n+t^(-a))^2)


$$2\,t^{n-a}+t^{2\,n}+\frac{1}{t^{2\,a}}$$73. Kalikan


$$(a^n-b^n)^2$$\>$expand((a^n-b^n)^3)


$$-b^{3\,n}+3\,a^{n}\,b^{2\,n}-3\,a^{2\,n}\,b^{n}+a^{3\,n}$$74. Faktorkan


$$y^2n+16y^n+64$$\>$factor(y^(2\*n)+16\*y^(n)+64)


$$\left(y^{n}+8\right)^2$$75. Faktorkan


$$x^{2t}-3x^t-28$$\>$factor(x^(2\*t)-3\*x^t-28)


$$\left(x^{t}-7\right)\,\left(x^{t}+4\right)$$

\section{EMT UNTUK 2D}
# 23030630096_Nur Alya Fadilah
Nama  : Nur Alya Fadilah


NIM   : 23030630096


Kelas : Matematika E 2023


# Menggambar Grafik 2D dengan EMT

Notebook ini menjelaskan tentang cara menggambar berbagaikurva dan
grafik 2D dengan software EMT. EMT menyediakan fungsi plot2d() untuk
menggambar berbagai kurva dan grafik dua dimensi (2D).


## Plot Dasar

Ada fungsi yang sangat mendasar dari plot. Ada koordinat layar, yang
selalu berkisar dari 0 hingga 1024 di setiap sumbu, tidak peduli
apakah layarnya persegi atau tidak. Semut ada koordinat plot, yang
dapat diatur dengan setplot(). Pemetaan antara koordinat tergantung
pada jendela plot saat ini. Misalnya, shrinkwindow() default
menyisakan ruang untuk label sumbu dan judul plot.


Dalam contoh, kita hanya menggambar beberapa garis acak dalam berbagai
warna. Untuk detail tentang fungsi ini, pelajari fungsi inti EMT.


\>clg; // clear screen

\>window(0,0,1024,1024); // use all of the window

\>setplot(0,1,0,1); // set plot coordinates

\>hold on; // start overwrite mode

\>n=100; X=random(n,2); Y=random(n,2);  // get random points

\>colors=rgb(random(n),random(n),random(n)); // get random colors

\>loop 1 to n; color(colors[#]); plot(X[#],Y[#]); end; // plot

\>hold off; // end overwrite mode

\>insimg; // insert to notebook


![images/23030630096_Nur%20Alya%20Fadilah-001.png](images/23030630096_Nur%20Alya%20Fadilah-001.png)

\>reset;


Grafik perlu ditahan, karena perintah plot() akan menghapus jendela
plot.


Untuk menghapus semua yang kami lakukan, kami menggunakan reset().


Untuk menampilkan gambar hasil plot di layar notebook, perintah
plot2d() dapat diakhiri dengan titik dua (:). Cara lain adalah
perintah plot2d() diakhiri dengan titik koma (;), kemudian menggunakan
perintah insimg() untuk menampilkan gambar hasil plot.


Untuk contoh lain, kami menggambar plot sebagai sisipan di plot lain.
Ini dilakukan dengan mendefinisikan jendela plot yang lebih kecil.
Perhatikan bahwa jendela ini tidak menyediakan ruang untuk label sumbu
di luar jendela plot. Kita harus menambahkan beberapa margin untuk ini
sesuai kebutuhan. Perhatikan bahwa kami menyimpan dan memulihkan
jendela penuh, dan menahan plot saat ini saat kami memplot inset.


\>plot2d("x^3-x");

\>xw=200; yw=100; ww=300; hw=300;

\>ow=window();

\>window(xw,yw,xw+ww,yw+hw);

\>hold on;

\>barclear(xw-50,yw-10,ww+60,ww+60);

\>plot2d("x^4-x",grid=6):


![images/23030630096_Nur%20Alya%20Fadilah-002.png](images/23030630096_Nur%20Alya%20Fadilah-002.png)

\>hold off;

\>window(ow);


Plot dengan banyak angka dicapai dengan cara yang sama. Ada fungsi
figure() utilitas untuk ini.


**Aspek Plot


Plot default menggunakan jendela plot persegi. Anda dapat mengubah ini
dengan fungsi aspek(). Jangan lupa untuk mengatur ulang aspek nanti.
Anda juga dapat mengubah default ini di menu dengan "Set Aspect" ke
rasio aspek tertentu atau ke ukuran jendela grafis saat ini.


Tetapi Anda juga dapat mengubahnya untuk satu plot. Untuk ini, ukuran
area plot saat ini diubah, dan jendela diatur sehingga label memiliki
cukup ruang.


\>aspect(2); // rasio panjang dan lebar 2:1

\>plot2d(["sin(x)","cos(x)"],0,2pi):


![images/23030630096_Nur%20Alya%20Fadilah-003.png](images/23030630096_Nur%20Alya%20Fadilah-003.png)

\>aspect();

\>reset;


Fungsi reset() mengembalikan default plot termasuk rasio aspek.


# Plot 2D di Euler

EMT Math Toolbox memiliki plot dalam 2D, baik untuk data maupun
fungsi. EMT menggunakan fungsi plot2d. Fungsi ini dapat memplot fungsi
dan data.


Dimungkinkan untuk membuat plot di Maxima menggunakan Gnuplot atau
dengan Python menggunakan Math Plot Lib.


Euler dapat memplot plot 2D dari


* 
ekspresi

* 
fungsi, variabel, atau kurva parameter,

* 
vektor nilai x-y,

* 
awan titik di pesawat,

* 
kurva implisit dengan level atau wilayah level.

* 
Fungsi kompleks


Gaya plot mencakup berbagai gaya untuk garis dan titik, plot batang
dan plot berbayang.


# Plot Ekspresi atau Variabel

Ekspresi tunggal dalam "x" (mis. "4*x^2") atau nama fungsi (mis. "f")
menghasilkan grafik fungsi.


Berikut adalah contoh paling dasar, yang menggunakan rentang default
dan menetapkan rentang y yang tepat agar sesuai dengan plot fungsi.


Catatan: Jika Anda mengakhiri baris perintah dengan titik dua ":",
plot akan dimasukkan ke dalam jendela teks. Jika tidak, tekan TAB
untuk melihat plot jika jendela plot tertutup.


\>plot2d("x^2"):


![images/23030630096_Nur%20Alya%20Fadilah-004.png](images/23030630096_Nur%20Alya%20Fadilah-004.png)

\>aspect(1.5); plot2d("x^3-x"):


![images/23030630096_Nur%20Alya%20Fadilah-005.png](images/23030630096_Nur%20Alya%20Fadilah-005.png)

\>a:=5.6; plot2d("exp(-a\*x^2)/a"); insimg(30); // menampilkan gambar hasil plot setinggi 25 baris


![images/23030630096_Nur%20Alya%20Fadilah-006.png](images/23030630096_Nur%20Alya%20Fadilah-006.png)

Dari beberapa contoh sebelumnya Anda dapat melihat bahwa Gambaran
gambar plot menggunakan sumbu X dengan rentang nilai dari -2 sampai
dengan 2. Untuk mengubah rentang nilai X dan Y, Anda dapat menambahkan
nilai batas X (dan Y) di belakang ekspresi yang digambar.


Rentang plot diatur dengan parameter yang ditetapkan berikut:


* 
a,b: rentang-x (default -2,2)

* 
c,d: y-range (default: skala dengan nilai)

* 
r: sebagai alternatif radius di sekitar pusat plot

* 
cx,cy: koordinat pusat plot (default 0,0)


\>plot2d("x^3-x",-1,2):


![images/23030630096_Nur%20Alya%20Fadilah-007.png](images/23030630096_Nur%20Alya%20Fadilah-007.png)

\>plot2d("sin(x)",-2\*pi,2\*pi): // plot sin(x) pada interval [-2pi, 2pi]


![images/23030630096_Nur%20Alya%20Fadilah-008.png](images/23030630096_Nur%20Alya%20Fadilah-008.png)

\>plot2d("cos(x)","sin(3\*x)",xmin=0,xmax=2pi):


![images/23030630096_Nur%20Alya%20Fadilah-009.png](images/23030630096_Nur%20Alya%20Fadilah-009.png)

Alternatif untuk titik dua adalah perintah insimg(baris), yang
menyisipkan plot yang menempati sejumlah baris teks tertentu.


Dalam opsi, plot dapat diatur untuk muncul


* 
di jendela terpisah yang dapat diubah ukurannya,

* 
di jendela buku catatan.


Lebih banyak gaya dapat dicapai dengan perintah plot tertentu.


Bagaimanapun, tekan tombol tabulator untuk melihat plot, jika
disembunyikan.


Untuk membagi jendela menjadi beberapa plot, gunakan perintah
figure(). Dalam contoh, kami memplot x^1 hingga x^4 menjadi 4 bagian
jendela. figure(0) mengatur ulang jendela default.


\>reset;

\>figure(2,2); ...  
\>   for n=1 to 4; figure(n); plot2d("x^"+n); end; ...  
\>   figure(0):


![images/23030630096_Nur%20Alya%20Fadilah-010.png](images/23030630096_Nur%20Alya%20Fadilah-010.png)

Di plot2d(), ada gaya alternatif yang tersedia dengan grid=x. Untuk
gambaran umum, kami menunjukkan berbagai gaya kisi dalam satu gambar
(lihat di bawah untuk perintah figure()). Gaya kisi=0 tidak
disertakan. Ini menunjukkan tidak ada grid dan tidak ada bingkai.


\>figure(3,3); ...  
\>   for k=1:9; figure(k); plot2d("x^3-x",-2,1,grid=k); end; ...  
\>   figure(0):


![images/23030630096_Nur%20Alya%20Fadilah-011.png](images/23030630096_Nur%20Alya%20Fadilah-011.png)

Jika argumen ke plot2d() adalah ekspresi yang diikuti oleh empat
angka, angka-angka ini adalah rentang x dan y untuk plot.


Atau, a, b, c, d dapat ditentukan sebagai parameter yang ditetapkan
sebagai a=... dll.


Dalam contoh berikut, kita mengubah gaya kisi, menambahkan label, dan
menggunakan label vertikal untuk sumbu y.


\>aspect(1.5); plot2d("sin(x)",0,2pi,-1.2,1.2,grid=3,xl="x",yl="sin(x)"):


![images/23030630096_Nur%20Alya%20Fadilah-012.png](images/23030630096_Nur%20Alya%20Fadilah-012.png)

\>plot2d("sin(x)+cos(2\*x)",0,4pi):


![images/23030630096_Nur%20Alya%20Fadilah-013.png](images/23030630096_Nur%20Alya%20Fadilah-013.png)

Gambar yang dihasilkan dengan memasukkan plot ke dalam jendela teks
disimpan di direktori yang sama dengan buku catatan, secara default di
subdirektori bernama "gambar". Mereka juga digunakan oleh ekspor HTML.


Anda cukup menandai gambar apa saja dan menyalinnya ke clipboard
dengan Ctrl-C. Tentu saja, Anda juga dapat mengekspor grafik saat ini
dengan fungsi di menu File.


Fungsi atau ekspresi dalam plot2d dievaluasi secara adaptif. Untuk
kecepatan lebih, matikan plot adaptif dengan &lt;adaptive dan tentukan
jumlah subinterval dengan n=... Ini hanya diperlukan dalam kasus yang
jarang terjadi.


\>plot2d("sign(x)\*exp(-x^2)",-1,1,<adaptive,n=10000):


![images/23030630096_Nur%20Alya%20Fadilah-014.png](images/23030630096_Nur%20Alya%20Fadilah-014.png)

\>plot2d("x^x",r=1.2,cx=1,cy=1):


![images/23030630096_Nur%20Alya%20Fadilah-015.png](images/23030630096_Nur%20Alya%20Fadilah-015.png)

Perhatikan bahwa x^x tidak didefinisikan untuk x&lt;=0. Fungsi plot2d
menangkap kesalahan ini, dan mulai merencanakan segera setelah fungsi
didefinisikan. Ini berfungsi untuk semua fungsi yang mengembalikan NAN
keluar dari jangkauan definisinya.


\>plot2d("log(x)",-0.1,2):


![images/23030630096_Nur%20Alya%20Fadilah-016.png](images/23030630096_Nur%20Alya%20Fadilah-016.png)

The parameter square=true (or &gt;square) selects the y-range automatically so that the
result is a square plot window. Note that by default, Euler uses a square space inside
the plot window.


\>plot2d("x^3-x",\>square):


![images/23030630096_Nur%20Alya%20Fadilah-017.png](images/23030630096_Nur%20Alya%20Fadilah-017.png)

\>plot2d(''integrate("sin(x)\*exp(-x^2)",0,x)'',0,2): // plot integral


![images/23030630096_Nur%20Alya%20Fadilah-018.png](images/23030630096_Nur%20Alya%20Fadilah-018.png)

Jika Anda membutuhkan lebih banyak ruang untuk label-y, panggil
shrinkwindow() dengan parameter yang lebih kecil, atau tetapkan nilai
positif untuk "lebih kecil" di plot2d().


\>plot2d("gamma(x)",1,10,yl="y-values",smaller=6,<vertical):


![images/23030630096_Nur%20Alya%20Fadilah-019.png](images/23030630096_Nur%20Alya%20Fadilah-019.png)

Ekspresi simbolik juga dapat digunakan, karena disimpan sebagai
ekspresi string sederhana.


\>x=linspace(0,2pi,1000); plot2d(sin(5x),cos(7x)):


![images/23030630096_Nur%20Alya%20Fadilah-020.png](images/23030630096_Nur%20Alya%20Fadilah-020.png)

\>a:=5.6; expr &= exp(-a\*x^2)/a; // define expression

\>plot2d(expr,-2,2): // plot from -2 to 2


![images/23030630096_Nur%20Alya%20Fadilah-021.png](images/23030630096_Nur%20Alya%20Fadilah-021.png)

\>plot2d(expr,r=1,thickness=2): // plot in a square around (0,0)


![images/23030630096_Nur%20Alya%20Fadilah-022.png](images/23030630096_Nur%20Alya%20Fadilah-022.png)

\>plot2d(&diff(expr,x),\>add,style="--",color=red): // add another plot


![images/23030630096_Nur%20Alya%20Fadilah-023.png](images/23030630096_Nur%20Alya%20Fadilah-023.png)

\>plot2d(&diff(expr,x,2),a=-2,b=2,c=-2,d=1): // plot in rectangle


![images/23030630096_Nur%20Alya%20Fadilah-024.png](images/23030630096_Nur%20Alya%20Fadilah-024.png)

\>plot2d(&diff(expr,x),a=-2,b=2,\>square): // keep plot square


![images/23030630096_Nur%20Alya%20Fadilah-025.png](images/23030630096_Nur%20Alya%20Fadilah-025.png)

\>plot2d("x^2",0,1,steps=1,color=red,n=10):


![images/23030630096_Nur%20Alya%20Fadilah-026.png](images/23030630096_Nur%20Alya%20Fadilah-026.png)

\>plot2d("x^2",\>add,steps=2,color=blue,n=10):


![images/23030630096_Nur%20Alya%20Fadilah-027.png](images/23030630096_Nur%20Alya%20Fadilah-027.png)

# Fungsi dalam satu Parameter

Fungsi plot yang paling penting untuk plot planar adalah plot2d().
Fungsi ini diimplementasikan dalam bahasa Euler dalam file "plot.e",
yang dimuat di awal program.


Berikut adalah beberapa contoh menggunakan fungsi. Seperti biasa di
EMT, fungsi yang berfungsi untuk fungsi atau ekspresi lain, Anda dapat
meneruskan parameter tambahan (selain x) yang bukan variabel global ke
fungsi dengan parameter titik koma atau dengan koleksi panggilan.


\>function f(x,a) := x^2/a+a\*x^2-x; // define a function

\>a=0.3; plot2d("f",0,1;a): // plot with a=0.3


![images/23030630096_Nur%20Alya%20Fadilah-028.png](images/23030630096_Nur%20Alya%20Fadilah-028.png)

\>plot2d("f",0,1;0.4): // plot with a=0.4


![images/23030630096_Nur%20Alya%20Fadilah-029.png](images/23030630096_Nur%20Alya%20Fadilah-029.png)

\>plot2d({{"f",0.2}},0,1): // plot with a=0.2


![images/23030630096_Nur%20Alya%20Fadilah-030.png](images/23030630096_Nur%20Alya%20Fadilah-030.png)

\>plot2d({{"f(x,b)",b=0.1}},0,1): // plot with 0.1


![images/23030630096_Nur%20Alya%20Fadilah-031.png](images/23030630096_Nur%20Alya%20Fadilah-031.png)

\>function f(x) := x^3-x; ...  
\>   plot2d("f",r=1):


![images/23030630096_Nur%20Alya%20Fadilah-032.png](images/23030630096_Nur%20Alya%20Fadilah-032.png)

Berikut adalah ringkasan dari fungsi yang diterima


* 
ekspresi atau ekspresi simbolik dalam x

* 
fungsi atau fungsi simbolis dengan nama sebagai "f"

* 
fungsi simbolis hanya dengan nama f


Fungsi plot2d() juga menerima fungsi simbolis. Untuk fungsi simbolis,
nama saja yang berfungsi.


\>function f(x) &= diff(x^x,x)


    
                                x
                               x  (log(x) + 1)
    

\>plot2d(f,0,2):


![images/23030630096_Nur%20Alya%20Fadilah-033.png](images/23030630096_Nur%20Alya%20Fadilah-033.png)

Tentu saja, untuk ekspresi atau ekspresi simbolik, nama variabel sudah
cukup untuk memplotnya.


\>expr &= sin(x)\*exp(-x)


    
                                  - x
                                 E    sin(x)
    

\>plot2d(expr,0,3pi):


![images/23030630096_Nur%20Alya%20Fadilah-034.png](images/23030630096_Nur%20Alya%20Fadilah-034.png)

\>function f(x) &= x^x;

\>plot2d(f,r=1,cx=1,cy=1,color=blue,thickness=2);

\>plot2d(&diff(f(x),x),\>add,color=red,style="-.-"):


![images/23030630096_Nur%20Alya%20Fadilah-035.png](images/23030630096_Nur%20Alya%20Fadilah-035.png)

Untuk gaya garis ada berbagai pilihan.


* 
gaya="...". Pilih dari "-", "--", "-.", ".", ".-.", "-.-".

* 
warna: Lihat di bawah untuk warna.

* 
ketebalan: Default adalah 1.


Warna dapat dipilih sebagai salah satu warna default, atau sebagai
warna RGB.


* 
0.15: indeks warna default.

* 
konstanta warna: putih, hitam, merah, hijau, biru, cyan, zaitun,
* abu-abu muda, abu-abu, abu-abu tua, oranye, hijau muda, pirus, biru
* muda, oranye terang, kuning

* 
rgb(merah, hijau, biru): parameter adalah real dalam [0,1].


\>plot2d("exp(-x^2)",r=2,color=red,thickness=3,style="--"):


![images/23030630096_Nur%20Alya%20Fadilah-036.png](images/23030630096_Nur%20Alya%20Fadilah-036.png)

Berikut adalah tampilan warna EMT yang telah ditentukan sebelumnya.


\>aspect(2); columnsplot(ones(1,16),lab=0:15,grid=0,color=0:15):


![images/23030630096_Nur%20Alya%20Fadilah-037.png](images/23030630096_Nur%20Alya%20Fadilah-037.png)

Tapi Anda bisa menggunakan warna apa saja.


\>columnsplot(ones(1,16),grid=0,color=rgb(0,0,linspace(0,1,15))):


![images/23030630096_Nur%20Alya%20Fadilah-038.png](images/23030630096_Nur%20Alya%20Fadilah-038.png)

# Menggambar Beberapa Kurva pada bidang koordinat yang sama

Plot lebih dari satu fungsi (multiple function) ke dalam satu jendela
dapat dilakukan dengan berbagai cara. Salah satu metode menggunakan
&gt;add untuk beberapa panggilan ke plot2d secara keseluruhan, tetapi
panggilan pertama. Kami telah menggunakan fitur ini dalam contoh di
atas.


\>aspect(); plot2d("cos(x)",r=2,grid=6); plot2d("x",style=".",\>add):


![images/23030630096_Nur%20Alya%20Fadilah-039.png](images/23030630096_Nur%20Alya%20Fadilah-039.png)

\>aspect(1.5); plot2d("sin(x)",0,2pi); plot2d("cos(x)",color=blue,style="--",\>add):


![images/23030630096_Nur%20Alya%20Fadilah-040.png](images/23030630096_Nur%20Alya%20Fadilah-040.png)

Salah satu kegunaan &gt;add adalah untuk menambahkan titik pada kurva.


\>plot2d("sin(x)",0,pi); plot2d(2,sin(2),\>points,\>add):


![images/23030630096_Nur%20Alya%20Fadilah-041.png](images/23030630096_Nur%20Alya%20Fadilah-041.png)

Kami menambahkan titik persimpangan dengan label (pada posisi "cl"
untuk kiri tengah), dan memasukkan hasilnya ke dalam notebook. Kami
juga menambahkan judul ke plot.


\>plot2d(["cos(x)","x"],r=1.1,cx=0.5,cy=0.5, ...  
\>     color=[black,blue],style=["-","."], ...  
\>     grid=1);

\>x0=solve("cos(x)-x",1);  ...  
\>     plot2d(x0,x0,\>points,\>add,title="Intersection Demo");  ...  
\>     label("cos(x) = x",x0,x0,pos="cl",offset=20):


![images/23030630096_Nur%20Alya%20Fadilah-042.png](images/23030630096_Nur%20Alya%20Fadilah-042.png)

Dalam demo berikut, kami memplot fungsi sinc(x)=sin(x)/x dan ekspansi
Taylor ke-8 dan ke-16. Kami menghitung ekspansi ini menggunakan Maxima
melalui ekspresi simbolis.


Plot ini dilakukan dalam perintah multi-baris berikut dengan tiga
panggilan ke plot2d(). Yang kedua dan yang ketiga memiliki set flag
&gt;add, yang membuat plot menggunakan rentang sebelumnya.


Kami menambahkan kotak label yang menjelaskan fungsi.


\>$taylor(sin(x)/x,x,0,4)


$$\frac{x^4}{120}-\frac{x^2}{6}+1$$\>plot2d("sinc(x)",0,4pi,color=green,thickness=2); ...  
\>     plot2d(&taylor(sin(x)/x,x,0,8),\>add,color=blue,style="--"); ...  
\>     plot2d(&taylor(sin(x)/x,x,0,16),\>add,color=red,style="-.-"); ...  
\>     labelbox(["sinc","T8","T16"],styles=["-","--","-.-"], ...  
\>       colors=[black,blue,red]):


![images/23030630096_Nur%20Alya%20Fadilah-044.png](images/23030630096_Nur%20Alya%20Fadilah-044.png)

Dalam contoh berikut, kami menghasilkan Bernstein-Polinomial.


$$B_i(x) = \binom{n}{i} x^i (1-x)^{n-i}$$\>plot2d("(1-x)^10",0,1); // plot first function

\>for i=1 to 10; plot2d("bin(10,i)\*x^i\*(1-x)^(10-i)",\>add); end;

\>insimg;


![images/23030630096_Nur%20Alya%20Fadilah-046.png](images/23030630096_Nur%20Alya%20Fadilah-046.png)

Metode kedua menggunakan pasangan matriks nilai-x dan matriks nilai-y
yang berukuran sama.


Kami menghasilkan matriks nilai dengan satu Polinomial Bernstein di
setiap baris. Untuk ini, kita cukup menggunakan vektor kolom i. Lihat
pengantar tentang bahasa matriks untuk mempelajari lebih detail.


\>x=linspace(0,1,500);

\>n=10; k=(0:n)'; // n is row vector, k is column vector

\>y=bin(n,k)\*x^k\*(1-x)^(n-k); // y is a matrix then

\>plot2d(x,y):


![images/23030630096_Nur%20Alya%20Fadilah-047.png](images/23030630096_Nur%20Alya%20Fadilah-047.png)

Perhatikan bahwa parameter warna dapat berupa vektor. Kemudian setiap
warna digunakan untuk setiap baris matriks.


\>x=linspace(0,1,200); y=x^(1:10)'; plot2d(x,y,color=1:10):


![images/23030630096_Nur%20Alya%20Fadilah-048.png](images/23030630096_Nur%20Alya%20Fadilah-048.png)

Metode lain adalah menggunakan vektor ekspresi (string). Anda kemudian
dapat menggunakan larik warna, larik gaya, dan larik ketebalan dengan
panjang yang sama.


\>plot2d(["sin(x)","cos(x)"],0,2pi,color=4:5): 


![images/23030630096_Nur%20Alya%20Fadilah-049.png](images/23030630096_Nur%20Alya%20Fadilah-049.png)

\>plot2d(["sin(x)","cos(x)"],0,2pi): // plot vector of expressions


![images/23030630096_Nur%20Alya%20Fadilah-050.png](images/23030630096_Nur%20Alya%20Fadilah-050.png)

Kita bisa mendapatkan vektor seperti itu dari Maxima menggunakan
makelist() dan mxm2str().


\>v &= makelist(binomial(10,i)\*x^i\*(1-x)^(10-i),i,0,10) // make list


    
                   10            9              8  2             7  3
           [(1 - x)  , 10 (1 - x)  x, 45 (1 - x)  x , 120 (1 - x)  x , 
               6  4             5  5             4  6             3  7
    210 (1 - x)  x , 252 (1 - x)  x , 210 (1 - x)  x , 120 (1 - x)  x , 
              2  8              9   10
    45 (1 - x)  x , 10 (1 - x) x , x  ]
    

\>mxm2str(v) // get a vector of strings from the symbolic vector


    (1-x)^10
    10*(1-x)^9*x
    45*(1-x)^8*x^2
    120*(1-x)^7*x^3
    210*(1-x)^6*x^4
    252*(1-x)^5*x^5
    210*(1-x)^4*x^6
    120*(1-x)^3*x^7
    45*(1-x)^2*x^8
    10*(1-x)*x^9
    x^10

\>plot2d(mxm2str(v),0,1): // plot functions


![images/23030630096_Nur%20Alya%20Fadilah-051.png](images/23030630096_Nur%20Alya%20Fadilah-051.png)

Alternatif lain adalah dengan menggunakan bahasa matriks Euler.


Jika ekspresi menghasilkan matriks fungsi, dengan satu fungsi di
setiap baris, semua fungsi ini akan diplot ke dalam satu plot.


Untuk ini, gunakan vektor parameter dalam bentuk vektor kolom. Jika
array warna ditambahkan, itu akan digunakan untuk setiap baris plot.


\>n=(1:10)'; plot2d("x^n",0,1,color=1:10):


![images/23030630096_Nur%20Alya%20Fadilah-052.png](images/23030630096_Nur%20Alya%20Fadilah-052.png)

Ekspresi dan fungsi satu baris dapat melihat variabel global.


Jika Anda tidak dapat menggunakan variabel global, Anda perlu
menggunakan fungsi dengan parameter tambahan, dan meneruskan parameter
ini sebagai parameter titik koma.


Berhati-hatilah, untuk meletakkan semua parameter yang ditetapkan di
akhir perintah plot2d. Dalam contoh kita meneruskan a=5 ke fungsi f,
yang kita plot dari -10 hingga 10.


\>function f(x,a) := 1/a\*exp(-x^2/a); ...  
\>   plot2d("f",-10,10;5,thickness=2,title="a=5"):


![images/23030630096_Nur%20Alya%20Fadilah-053.png](images/23030630096_Nur%20Alya%20Fadilah-053.png)

Atau, gunakan koleksi dengan nama fungsi dan semua parameter tambahan.
Daftar khusus ini disebut koleksi panggilan, dan itu adalah cara yang
lebih disukai untuk meneruskan argumen ke fungsi yang dengan
sendirinya diteruskan sebagai argumen ke fungsi lain.


Dalam contoh berikut, kami menggunakan loop untuk memplot beberapa
fungsi (lihat tutorial tentang pemrograman untuk loop).


\>plot2d({{"f",1}},-10,10); ...  
\>   for a=2:10; plot2d({{"f",a}},\>add); end:


![images/23030630096_Nur%20Alya%20Fadilah-054.png](images/23030630096_Nur%20Alya%20Fadilah-054.png)

Kami dapat mencapai hasil yang sama dengan cara berikut menggunakan
bahasa matriks EMT. Setiap baris matriks f(x,a) adalah satu fungsi.
Selain itu, kita dapat mengatur warna untuk setiap baris matriks. Klik
dua kali pada fungsi getspectral() untuk penjelasannya.


\>x=-10:0.01:10; a=(1:10)'; plot2d(x,f(x,a),color=getspectral(a/10)):


![images/23030630096_Nur%20Alya%20Fadilah-055.png](images/23030630096_Nur%20Alya%20Fadilah-055.png)

## Label Teks

Dekorasi sederhana bisa


* 
judul dengan judul="..."

* 
x- dan y-label dengan xl="...", yl="..."

* 
label teks lain dengan label("...",x,y)


Perintah label akan memplot ke dalam plot saat ini pada koordinat plot
(x,y). Itu bisa mengambil argumen posisi.


\>plot2d("x^3-x",-1,2,title="y=x^3-x",yl="y",xl="x"):


![images/23030630096_Nur%20Alya%20Fadilah-056.png](images/23030630096_Nur%20Alya%20Fadilah-056.png)

\>expr := "log(x)/x"; ...  
\>     plot2d(expr,0.5,5,title="y="+expr,xl="x",yl="y"); ...  
\>     label("(1,0)",1,0); label("Max",E,expr(E),pos="lc"):


![images/23030630096_Nur%20Alya%20Fadilah-057.png](images/23030630096_Nur%20Alya%20Fadilah-057.png)

Ada juga fungsi labelbox(), yang dapat menampilkan fungsi dan teks.
Dibutuhkan vektor string dan warna, satu item untuk setiap fungsi.


\>function f(x) &= x^2\*exp(-x^2);  ...  
\>   plot2d(&f(x),a=-3,b=3,c=-1,d=1);  ...  
\>   plot2d(&diff(f(x),x),\>add,color=blue,style="--"); ...  
\>   labelbox(["function","derivative"],styles=["-","--"], ...  
\>      colors=[black,blue],w=0.4):


![images/23030630096_Nur%20Alya%20Fadilah-058.png](images/23030630096_Nur%20Alya%20Fadilah-058.png)

Kotak ditambatkan di kanan atas secara default, tetapi &gt; kiri
menambatkannya di kiri atas. Anda dapat memindahkannya ke tempat yang
Anda suka. Posisi jangkar adalah sudut kanan atas kotak, dan angkanya
adalah pecahan dari ukuran jendela grafik. Lebarnya otomatis.


Untuk plot titik, kotak label juga berfungsi. Tambahkan parameter
&gt;points, atau vektor flag, satu untuk setiap label.


Dalam contoh berikut, hanya ada satu fungsi. Jadi kita bisa
menggunakan string sebagai pengganti vektor string. Kami mengatur
warna teks menjadi hitam untuk contoh ini.


\>n=10; plot2d(0:n,bin(n,0:n),\>addpoints); ...  
\>   labelbox("Binomials",styles="[]",\>points,x=0.1,y=0.1, ...  
\>   tcolor=black,\>left):


![images/23030630096_Nur%20Alya%20Fadilah-059.png](images/23030630096_Nur%20Alya%20Fadilah-059.png)

Gaya plot ini juga tersedia di statplot(). Seperti di plot2d() warna
dapat diatur untuk setiap baris plot. Ada lebih banyak plot khusus
untuk keperluan statistik (lihat tutorial tentang statistik).


\>statplot(1:10,random(2,10),color=[red,blue]):


![images/23030630096_Nur%20Alya%20Fadilah-060.png](images/23030630096_Nur%20Alya%20Fadilah-060.png)

Fitur serupa adalah fungsi textbox().


Lebar secara default adalah lebar maksimal dari baris teks. Tapi itu
bisa diatur oleh pengguna juga.


\>function f(x) &= exp(-x)\*sin(2\*pi\*x); ...  
\>   plot2d("f(x)",0,2pi); ...  
\>   textbox(latex("\\text{Example of a damped oscillation}\\ f(x)=e^{-x}sin(2\\pi x)"),w=0.85):


![images/23030630096_Nur%20Alya%20Fadilah-061.png](images/23030630096_Nur%20Alya%20Fadilah-061.png)

Label teks, judul, kotak label, dan teks lainnya dapat berisi string
Unicode (lihat sintaks EMT untuk mengetahui lebih lanjut tentang
string Unicode).


\>plot2d("x^3-x",title=u"x &rarr; x&sup3; - x"):


![images/23030630096_Nur%20Alya%20Fadilah-062.png](images/23030630096_Nur%20Alya%20Fadilah-062.png)

Label pada sumbu x dan y bisa vertikal, begitu juga sumbunya.


\>plot2d("sinc(x)",0,2pi,xl="x",yl=u"x &rarr; sinc(x)",\>vertical):


![images/23030630096_Nur%20Alya%20Fadilah-063.png](images/23030630096_Nur%20Alya%20Fadilah-063.png)

## LaTeX

Anda juga dapat memplot rumus LaTeX jika Anda telah menginstal sistem
LaTeX. Saya merekomendasikan MiKTeX. Jalur ke biner "latex" dan
"dvipng" harus berada di jalur sistem, atau Anda harus mengatur LaTeX
di menu opsi.


Perhatikan, bahwa penguraian LaTeX lambat. Jika Anda ingin menggunakan
LaTeX dalam plot animasi, Anda harus memanggil latex() sebelum loop
sekali dan menggunakan hasilnya (gambar dalam matriks RGB).


Dalam plot berikut, kami menggunakan LaTeX untuk label x dan y, label,
kotak label, dan judul plot.


\>plot2d("exp(-x)\*sin(x)/x",a=0,b=2pi,c=0,d=1,grid=6,color=blue, ...  
\>     title=latex("\\text{Function $\\Phi$}"), ...  
\>     xl=latex("\\phi"),yl=latex("\\Phi(\\phi)")); ...  
\>   textbox( ...  
\>     latex("\\Phi(\\phi) = e^{-\\phi} \\frac{\\sin(\\phi)}{\\phi}"),x=0.8,y=0.5); ...  
\>   label(latex("\\Phi",color=blue),1,0.4):


![images/23030630096_Nur%20Alya%20Fadilah-064.png](images/23030630096_Nur%20Alya%20Fadilah-064.png)

Seringkali, kami menginginkan spasi dan label teks non-konformal pada
sumbu x. Kita dapat menggunakan xaxis() dan yaxis() seperti yang akan
kita tunjukkan nanti.


Cara termudah adalah dengan membuat plot kosong dengan bingkai
menggunakan grid=4, lalu menambahkan grid dengan ygrid() dan xgrid().
Dalam contoh berikut, kami menggunakan tiga string LaTeX untuk label
pada sumbu x dengan xtick().


\>plot2d("sinc(x)",0,2pi,grid=4,<ticks); ...  
\>   ygrid(-2:0.5:2,grid=6); ...  
\>   xgrid([0:2]\*pi,<ticks,grid=6);  ...  
\>   xtick([0,pi,2pi],["0","\\pi","2\\pi"],\>latex):


![images/23030630096_Nur%20Alya%20Fadilah-065.png](images/23030630096_Nur%20Alya%20Fadilah-065.png)

Tentu saja, fungsi juga dapat digunakan.


\>function map f(x) ...


    if x>0 then return x^4
    else return x^2
    endif
    endfunction
</pre>
Parameter "peta" membantu menggunakan fungsi untuk vektor. Untuk


plot, itu tidak perlu. Tetapi untuk mendemonstrasikan vektorisasi itu


berguna, kami menambahkan beberapa poin kunci ke plot di x=-1, x=0 dan
x=1.


Pada plot berikut, kami juga memasukkan beberapa kode LaTeX. Kami
menggunakannya untuk


dua label dan kotak teks. Tentu saja, Anda hanya akan dapat
menggunakan


LaTeX jika Anda telah menginstal LaTeX dengan benar.


\>plot2d("f",-1,1,xl="x",yl="f(x)",grid=6);  ...  
\>   plot2d([-1,0,1],f([-1,0,1]),\>points,\>add); ...  
\>   label(latex("x^3"),0.72,f(0.72)); ...  
\>   label(latex("x^2"),-0.52,f(-0.52),pos="ll"); ...  
\>   textbox( ...  
\>     latex("f(x)=\\begin{cases} x^3 & x\>0 \\\\ x^2 & x \\le 0\\end{cases}"), ...  
\>     x=0.7,y=0.2):


![images/23030630096_Nur%20Alya%20Fadilah-066.png](images/23030630096_Nur%20Alya%20Fadilah-066.png)

## Interaksi pengguna

Saat memplot fungsi atau ekspresi, parameter &gt;user memungkinkan
pengguna untuk memperbesar dan menggeser plot dengan tombol kursor
atau mouse. Pengguna dapat


* 
perbesar dengan + atau -

* 
pindahkan plot dengan tombol kursor

* 
pilih jendela plot dengan mouse

* 
atur ulang tampilan dengan spasi

* 
keluar dengan kembali


Tombol spasi akan mengatur ulang plot ke jendela plot asli.


Saat memplot data, flag &gt;user hanya akan menunggu penekanan tombol.


\>plot2d({{"x^3-a\*x",a=1}},\>user,title="Press any key!"):


![images/23030630096_Nur%20Alya%20Fadilah-067.png](images/23030630096_Nur%20Alya%20Fadilah-067.png)

\>plot2d("exp(x)\*sin(x)",user=true, ...  
\>     title="+/- or cursor keys (return to exit)"):


![images/23030630096_Nur%20Alya%20Fadilah-068.png](images/23030630096_Nur%20Alya%20Fadilah-068.png)

Berikut ini menunjukkan cara interaksi pengguna tingkat lanjut (lihat
tutorial tentang pemrograman untuk detailnya).


Fungsi bawaan mousedrag() menunggu event mouse atau keyboard. Ini
melaporkan mouse ke bawah, mouse dipindahkan atau mouse ke atas, dan
penekanan tombol. Fungsi dragpoints() memanfaatkan ini, dan
memungkinkan pengguna menyeret titik mana pun dalam plot.


Kita membutuhkan fungsi plot terlebih dahulu. Sebagai contoh, kita
interpolasi dalam 5 titik dengan polinomial. Fungsi harus diplot ke
area plot tetap.


\>function plotf(xp,yp,select) ...


      d=interp(xp,yp);
      plot2d("interpval(xp,d,x)";d,xp,r=2);
      plot2d(xp,yp,>points,>add);
      if select>0 then
        plot2d(xp[select],yp[select],color=red,>points,>add);
      endif;
      title("Drag one point, or press space or return!");
    endfunction
</pre>
Perhatikan parameter titik koma di plot2d (d dan xp), yang diteruskan
ke evaluasi fungsi interp(). Tanpa ini, kita harus menulis fungsi
plotinterp() terlebih dahulu, mengakses nilai secara global.


Sekarang kita menghasilkan beberapa nilai acak, dan membiarkan
pengguna menyeret poin.


\>t=-1:0.5:1; dragpoints("plotf",t,random(size(t))-0.5):


![images/23030630096_Nur%20Alya%20Fadilah-069.png](images/23030630096_Nur%20Alya%20Fadilah-069.png)

Ada juga fungsi, yang memplot fungsi lain tergantung pada vektor
parameter, dan memungkinkan pengguna menyesuaikan parameter ini.


Pertama kita membutuhkan fungsi plot.


\>function plotf([a,b]) := plot2d("exp(a\*x)\*cos(2pi\*b\*x)",0,2pi;a,b);


Kemudian kita membutuhkan nama untuk parameter, nilai awal dan matriks
rentang nx2, opsional baris judul.


Ada slider interaktif, yang dapat mengatur nilai oleh pengguna. Fungsi
dragvalues() menyediakan ini.


\>dragvalues("plotf",["a","b"],[-1,2],[[-2,2];[1,10]], ...  
\>     heading="Drag these values:",hcolor=black):


![images/23030630096_Nur%20Alya%20Fadilah-070.png](images/23030630096_Nur%20Alya%20Fadilah-070.png)

Dimungkinkan untuk membatasi nilai yang diseret ke bilangan bulat.
Sebagai contoh, kita menulis fungsi plot, yang memplot polinomial
Taylor derajat n ke fungsi kosinus.


\>function plotf(n) ...


    plot2d("cos(x)",0,2pi,>square,grid=6);
    plot2d(&"taylor(cos(x),x,0,@n)",color=blue,>add);
    textbox("Taylor polynomial of degree "+n,0.1,0.02,style="t",>left);
    endfunction
</pre>
Sekarang kami mengizinkan derajat n bervariasi dari 0 hingga 20 dalam
20 pemberhentian. Hasil dragvalues() digunakan untuk memplot sketsa
dengan n ini, dan untuk memasukkan plot ke dalam buku catatan.


\>nd=dragvalues("plotf","degree",2,[0,20],20,y=0.8, ...  
\>      heading="Drag the value:"); ...  
\>   plotf(nd):


![images/23030630096_Nur%20Alya%20Fadilah-071.png](images/23030630096_Nur%20Alya%20Fadilah-071.png)

Berikut ini adalah demonstrasi sederhana dari fungsi tersebut.
Pengguna dapat menggambar di atas jendela plot, meninggalkan jejak
poin.


\>function dragtest ...


      plot2d(none,r=1,title="Drag with the mouse, or press any key!");
      start=0;
      repeat
        {flag,m,time}=mousedrag();
        if flag==0 then return; endif;
        if flag==2 then
          hold on; mark(m[1],m[2]); hold off;
        endif;
      end
    endfunction
</pre>
\>dragtest // lihat hasilnya dan cobalah lakukan!


## Gaya Plot 2D

Secara default, EMT menghitung tick sumbu otomatis dan menambahkan
label ke setiap tick. Ini dapat diubah dengan parameter grid. Gaya
default sumbu dan label dapat dimodifikasi. Selain itu, label dan
judul dapat ditambahkan secara manual. Untuk mengatur ulang ke gaya
default, gunakan reset().


\>aspect();

\>figure(3,4); ...  
\>    figure(1); plot2d("x^3-x",grid=0); ... // no grid, frame or axis

\> figure(2); plot2d("x^3-x",grid=1); ... // x-y-axis

\> figure(3); plot2d("x^3-x",grid=2); ... // default ticks

\> figure(4); plot2d("x^3-x",grid=3); ... // x-y- axis with labels inside

\> figure(5); plot2d("x^3-x",grid=4); ... // no ticks, only labels

\> figure(6); plot2d("x^3-x",grid=5); ... // default, but no margin

\> figure(7); plot2d("x^3-x",grid=6); ... // axes only

\> figure(8); plot2d("x^3-x",grid=7); ... // axes only, ticks at axis

\> figure(9); plot2d("x^3-x",grid=8); ... // axes only, finer ticks at axis

\> figure(10); plot2d("x^3-x",grid=9); ... // default, small ticks inside

\> figure(11); plot2d("x^3-x",grid=10); ...// no ticks, axes only

\> figure(0):


![images/23030630096_Nur%20Alya%20Fadilah-072.png](images/23030630096_Nur%20Alya%20Fadilah-072.png)

Parameter &lt;frame mematikan frame, dan framecolor=blue mengatur frame
ke warna biru.


Jika Anda ingin centang sendiri, Anda dapat menggunakan style=0, dan
menambahkan semuanya nanti.


\>aspect(1.5); 

\>plot2d("x^3-x",grid=0); // plot

\>frame; xgrid([-1,0,1]); ygrid(0): // add frame and grid


![images/23030630096_Nur%20Alya%20Fadilah-073.png](images/23030630096_Nur%20Alya%20Fadilah-073.png)

Untuk judul plot dan label sumbu, lihat contoh berikut.


\>plot2d("exp(x)",-1,1);

\>textcolor(black); // set the text color to black

\>title(latex("y=e^x")); // title above the plot

\>xlabel(latex("x")); // "x" for x-axis

\>ylabel(latex("y"),\>vertical); // vertical "y" for y-axis

\>label(latex("(0,1)"),0,1,color=blue): // label a point


![images/23030630096_Nur%20Alya%20Fadilah-074.png](images/23030630096_Nur%20Alya%20Fadilah-074.png)

Sumbu dapat digambar secara terpisah dengan xaxis() dan yaxis().


\>plot2d("x^3-x",<grid,<frame);

\>xaxis(0,xx=-2:1,style="-\>"); yaxis(0,yy=-5:5,style="-\>"):


![images/23030630096_Nur%20Alya%20Fadilah-075.png](images/23030630096_Nur%20Alya%20Fadilah-075.png)

Teks pada plot dapat diatur dengan label(). Dalam contoh berikut, "lc"
berarti tengah bawah. Ini mengatur posisi label relatif terhadap
koordinat plot.


\>function f(x) &= x^3-x


    
                                     3
                                    x  - x
    

\>plot2d(f,-1,1,\>square);

\>x0=fmin(f,0,1); // compute point of minimum

\>label("Rel. Min.",x0,f(x0),pos="lc"): // add a label there


![images/23030630096_Nur%20Alya%20Fadilah-076.png](images/23030630096_Nur%20Alya%20Fadilah-076.png)

Ada juga kotak teks.


\>plot2d(&f(x),-1,1,-2,2); // function

\>plot2d(&diff(f(x),x),\>add,style="--",color=red); // derivative

\>labelbox(["f","f'"],["-","--"],[black,red]): // label box


![images/23030630096_Nur%20Alya%20Fadilah-077.png](images/23030630096_Nur%20Alya%20Fadilah-077.png)

\>plot2d(["exp(x)","1+x"],color=[black,blue],style=["-","-.-"]):


![images/23030630096_Nur%20Alya%20Fadilah-078.png](images/23030630096_Nur%20Alya%20Fadilah-078.png)

\>gridstyle("-\>",color=gray,textcolor=gray,framecolor=gray);  ...  
\>    plot2d("x^3-x",grid=1);   ...  
\>    settitle("y=x^3-x",color=black); ...  
\>    label("x",2,0,pos="bc",color=gray);  ...  
\>    label("y",0,6,pos="cl",color=gray); ...  
\>    reset():


![images/23030630096_Nur%20Alya%20Fadilah-079.png](images/23030630096_Nur%20Alya%20Fadilah-079.png)

Untuk kontrol lebih, sumbu x dan sumbu y dapat dilakukan secara
manual.


Perintah fullwindow() memperluas jendela plot karena kita tidak lagi
membutuhkan tempat untuk label di luar jendela plot. Gunakan
shrinkwindow() atau reset() untuk mengatur ulang ke default.


\>fullwindow; ...  
\>    gridstyle(color=darkgray,textcolor=darkgray); ...  
\>    plot2d(["2^x","1","2^(-x)"],a=-2,b=2,c=0,d=4,<grid,color=4:6,<frame); ...  
\>    xaxis(0,-2:1,style="-\>"); xaxis(0,2,"x",<axis); ...  
\>    yaxis(0,4,"y",style="-\>"); ...  
\>    yaxis(-2,1:4,\>left); ...  
\>    yaxis(2,2^(-2:2),style=".",<left); ...  
\>    labelbox(["2^x","1","2^-x"],colors=4:6,x=0.8,y=0.2); ...  
\>    reset:


![images/23030630096_Nur%20Alya%20Fadilah-080.png](images/23030630096_Nur%20Alya%20Fadilah-080.png)

Berikut adalah contoh lain, di mana string Unicode digunakan dan sumbu
di luar area plot.


\>aspect(1.5); 

\>plot2d(["sin(x)","cos(x)"],0,2pi,color=[red,green],<grid,<frame); ...  
\>    xaxis(-1.1,(0:2)\*pi,xt=["0",u"&pi;",u"2&pi;"],style="-",\>ticks,\>zero);  ...  
\>    xgrid((0:0.5:2)\*pi,<ticks); ...  
\>    yaxis(-0.1\*pi,-1:0.2:1,style="-",\>zero,\>grid); ...  
\>    labelbox(["sin","cos"],colors=[red,green],x=0.5,y=0.2,\>left); ...  
\>    xlabel(u"&phi;"); ylabel(u"f(&phi;)"):


![images/23030630096_Nur%20Alya%20Fadilah-081.png](images/23030630096_Nur%20Alya%20Fadilah-081.png)

# Merencanakan Data 2D

Jika x dan y adalah vektor data, data ini akan digunakan sebagai
koordinat x dan y dari suatu kurva. Dalam hal ini, a, b, c, dan d,
atau radius r dapat ditentukan, atau jendela plot akan menyesuaikan
secara otomatis dengan data. Atau, &gt;persegi dapat diatur untuk menjaga
rasio aspek persegi.


Memplot ekspresi hanyalah singkatan untuk plot data. Untuk plot data,
Anda memerlukan satu atau beberapa baris nilai x, dan satu atau
beberapa baris nilai y. Dari rentang dan nilai-x, fungsi plot2d akan
menghitung data yang akan diplot, secara default dengan evaluasi
fungsi yang adaptif. Untuk plot titik gunakan "&gt;titik", untuk garis
campuran dan titik gunakan "&gt;tambahan".


Tapi Anda bisa memasukkan data secara langsung.


* 
Gunakan vektor baris untuk x dan y untuk satu fungsi.

* 
Matriks untuk x dan y diplot baris demi baris.


Berikut adalah contoh dengan satu baris untuk x dan y.


\>x=-10:0.1:10; y=exp(-x^2)\*x; plot2d(x,y):


![images/23030630096_Nur%20Alya%20Fadilah-082.png](images/23030630096_Nur%20Alya%20Fadilah-082.png)

Data juga dapat diplot sebagai titik. Gunakan poin=true untuk ini.
Plotnya bekerja seperti poligon, tetapi hanya menggambar
sudut-sudutnya.


* 
style="...": Pilih dari "[]", "&lt;&gt;", "o", ".", "..", "+", "*", "[]#",
* "&lt; &gt;#", "o#", "..#", "#", "|".


Untuk memplot set poin gunakan &gt;points. Jika warna adalah vektor
warna, setiap titik


mendapat warna yang berbeda. Untuk matriks koordinat dan vektor kolom,
warna berlaku untuk baris matriks.


Parameter &gt;addpoints menambahkan titik ke segmen garis untuk plot
data.


\>xdata=[1,1.5,2.5,3,4]; ydata=[3,3.1,2.8,2.9,2.7]; // data

\>plot2d(xdata,ydata,a=0.5,b=4.5,c=2.5,d=3.5,style="."); // lines

\>plot2d(xdata,ydata,\>points,\>add,style="o"): // add points


![images/23030630096_Nur%20Alya%20Fadilah-083.png](images/23030630096_Nur%20Alya%20Fadilah-083.png)

\>p=polyfit(xdata,ydata,1); // get regression line

\>plot2d("polyval(p,x)",\>add,color=red): // add plot of line


![images/23030630096_Nur%20Alya%20Fadilah-084.png](images/23030630096_Nur%20Alya%20Fadilah-084.png)

# Menggambar Daerah Yang Dibatasi Kurva

Plot data benar-benar poligon. Kita juga dapat memplot kurva atau
kurva terisi.


* 
terisi=benar mengisi plot.

* 
style="...": Pilih dari "#", "/", "\", "\/".

* 
fillcolor: Lihat di atas untuk warna yang tersedia.


Warna isian ditentukan oleh argumen "fillcolor", dan pada &lt;outline
opsional mencegah menggambar batas untuk semua gaya kecuali yang
default.


\>t=linspace(0,2pi,1000); // parameter for curve

\>x=sin(t)\*exp(t/pi); y=cos(t)\*exp(t/pi); // x(t) and y(t)

\>figure(1,2); aspect(16/9)

\>figure(1); plot2d(x,y,r=10); // plot curve

\>figure(2); plot2d(x,y,r=10,\>filled,style="/",fillcolor=red); // fill curve

\>figure(0):


![images/23030630096_Nur%20Alya%20Fadilah-085.png](images/23030630096_Nur%20Alya%20Fadilah-085.png)

Dalam contoh berikut kami memplot elips terisi dan dua segi enam
terisi menggunakan kurva tertutup dengan 6 titik dengan gaya isian
berbeda.


\>x=linspace(0,2pi,1000); plot2d(sin(x),cos(x)\*0.5,r=1,\>filled,style="/"):


![images/23030630096_Nur%20Alya%20Fadilah-086.png](images/23030630096_Nur%20Alya%20Fadilah-086.png)

\>t=linspace(0,2pi,6); ...  
\>   plot2d(cos(t),sin(t),\>filled,style="/",fillcolor=red,r=1.2):


![images/23030630096_Nur%20Alya%20Fadilah-087.png](images/23030630096_Nur%20Alya%20Fadilah-087.png)

\>t=linspace(0,2pi,6); plot2d(cos(t),sin(t),\>filled,style="#"):


![images/23030630096_Nur%20Alya%20Fadilah-088.png](images/23030630096_Nur%20Alya%20Fadilah-088.png)

Contoh lainnya adalah segi empat, yang kita buat dengan 7 titik pada
lingkaran satuan.


\>t=linspace(0,5pi,6);  ...  
\>    plot2d(cos(t),sin(t),r=1,\>filled,style="/",fillcolor=red):


![images/23030630096_Nur%20Alya%20Fadilah-089.png](images/23030630096_Nur%20Alya%20Fadilah-089.png)

Berikut ini adalah himpunan nilai maksimal dari empat kondisi linier
yang kurang dari atau sama dengan 3. Ini adalah A[k].v&lt;=3 untuk semua
baris A. Untuk mendapatkan sudut yang bagus, kita menggunakan n yang
relatif besar.


\>A=[2,1;1,2;-1,0;0,-1];

\>function f(x,y) := max([x,y].A');

\>plot2d("f",r=4,level=[0;3],color=green,n=111):


![images/23030630096_Nur%20Alya%20Fadilah-090.png](images/23030630096_Nur%20Alya%20Fadilah-090.png)

Poin utama dari bahasa matriks adalah memungkinkan untuk menghasilkan
tabel fungsi dengan mudah.


\>t=linspace(0,2pi,1000); x=cos(3\*t); y=sin(4\*t);


Kami sekarang memiliki vektor x dan y nilai. plot2d() dapat memplot
nilai-nilai ini


sebagai kurva yang menghubungkan titik-titik. Plotnya bisa diisi. Pada
kasus ini


ini menghasilkan hasil yang bagus karena aturan lilitan, yang
digunakan untuk


isi.


\>plot2d(x,y,<grid,<frame,\>filled):


![images/23030630096_Nur%20Alya%20Fadilah-091.png](images/23030630096_Nur%20Alya%20Fadilah-091.png)

Sebuah vektor interval diplot terhadap nilai x sebagai daerah terisi


antara nilai interval bawah dan atas.


Hal ini dapat berguna untuk memplot kesalahan perhitungan. Tapi itu
bisa


juga digunakan untuk memplot kesalahan statistik.


\>t=0:0.1:1; ...  
\>    plot2d(t,interval(t-random(size(t)),t+random(size(t))),style="|");  ...  
\>    plot2d(t,t,add=true):


![images/23030630096_Nur%20Alya%20Fadilah-092.png](images/23030630096_Nur%20Alya%20Fadilah-092.png)

Jika x adalah vektor yang diurutkan, dan y adalah vektor interval,
maka plot2d akan memplot rentang interval yang terisi dalam bidang.
Gaya isian sama dengan gaya poligon.


\>t=-1:0.01:1; x=~t-0.01,t+0.01~; y=x^3-x;

\>plot2d(t,y):


![images/23030630096_Nur%20Alya%20Fadilah-093.png](images/23030630096_Nur%20Alya%20Fadilah-093.png)

Dimungkinkan untuk mengisi wilayah nilai untuk fungsi tertentu. Untuk


ini, level harus berupa matriks 2xn. Baris pertama adalah batas bawah


dan baris kedua berisi batas atas.


\>expr := "2\*x^2+x\*y+3\*y^4+y"; // define an expression f(x,y)

\>plot2d(expr,level=[0;1],style="-",color=blue): // 0 <= f(x,y) <= 1


![images/23030630096_Nur%20Alya%20Fadilah-094.png](images/23030630096_Nur%20Alya%20Fadilah-094.png)

Kami juga dapat mengisi rentang nilai seperti


$$-1 \le (x^2+y^2)^2-x^2+y^2 \le 0.$$\>plot2d("(x^2+y^2)^2-x^2+y^2",r=1.2,level=[-1;0],style="/"):


![images/23030630096_Nur%20Alya%20Fadilah-096.png](images/23030630096_Nur%20Alya%20Fadilah-096.png)

\>plot2d("cos(x)","sin(x)^3",xmin=0,xmax=2pi,\>filled,style="/"):


![images/23030630096_Nur%20Alya%20Fadilah-097.png](images/23030630096_Nur%20Alya%20Fadilah-097.png)

# Grafik Fungsi Parametrik

Nilai-x tidak perlu diurutkan. (x,y) hanya menggambarkan kurva. Jika x
diurutkan, kurva tersebut merupakan grafik fungsi.


Dalam contoh berikut, kami memplot spiral


$$\gamma(t) = t \cdot (\cos(2\pi t),\sin(2\pi t))$$Kita perlu menggunakan banyak titik untuk tampilan yang halus atau
fungsi adaptif() untuk mengevaluasi ekspresi (lihat fungsi adaptif()
untuk lebih jelasnya).


\>t=linspace(0,1,1000); ...  
\>   plot2d(t\*cos(2\*pi\*t),t\*sin(2\*pi\*t),r=1):


![images/23030630096_Nur%20Alya%20Fadilah-099.png](images/23030630096_Nur%20Alya%20Fadilah-099.png)

Atau, dimungkinkan untuk menggunakan dua ekspresi untuk kurva. Berikut
ini plot kurva yang sama seperti di atas.


\>plot2d("x\*cos(2\*pi\*x)","x\*sin(2\*pi\*x)",xmin=0,xmax=1,r=1):


![images/23030630096_Nur%20Alya%20Fadilah-100.png](images/23030630096_Nur%20Alya%20Fadilah-100.png)

\>t=linspace(0,1,1000); r=exp(-t); x=r\*cos(2pi\*t); y=r\*sin(2pi\*t);

\>plot2d(x,y,r=1):


![images/23030630096_Nur%20Alya%20Fadilah-101.png](images/23030630096_Nur%20Alya%20Fadilah-101.png)

Dalam contoh berikutnya, kami memplot kurva


$$\gamma(t) = (r(t) \cos(t), r(t) \sin(t))$$dengan


$$r(t) = 1 + \dfrac{\sin(3t)}{2}.$$\>t=linspace(0,2pi,1000); r=1+sin(3\*t)/2; x=r\*cos(t); y=r\*sin(t); ...  
\>   plot2d(x,y,\>filled,fillcolor=red,style="/",r=1.5):


![images/23030630096_Nur%20Alya%20Fadilah-104.png](images/23030630096_Nur%20Alya%20Fadilah-104.png)

# Menggambar Grafik Bilangan Kompleks

Array bilangan kompleks juga dapat diplot. Kemudian titik-titik grid
akan terhubung. Jika sejumlah garis kisi ditentukan (atau vektor garis
kisi 1x2) dalam argumen cgrid, hanya garis kisi tersebut yang
terlihat.


Matriks bilangan kompleks akan secara otomatis diplot sebagai kisi di
bidang kompleks.


Dalam contoh berikut, kami memplot gambar lingkaran satuan di bawah
fungsi eksponensial. Parameter cgrid menyembunyikan beberapa kurva
grid.


\>aspect(); r=linspace(0,1,50); a=linspace(0,2pi,80)'; z=r\*exp(I\*a);...  
\>   plot2d(z,a=-1.25,b=1.25,c=-1.25,d=1.25,cgrid=10):


![images/23030630096_Nur%20Alya%20Fadilah-105.png](images/23030630096_Nur%20Alya%20Fadilah-105.png)

\>aspect(1.25); r=linspace(0,1,50); a=linspace(0,2pi,200)'; z=r\*exp(I\*a);

\>plot2d(exp(z),cgrid=[40,10]):


![images/23030630096_Nur%20Alya%20Fadilah-106.png](images/23030630096_Nur%20Alya%20Fadilah-106.png)

\>r=linspace(0,1,10); a=linspace(0,2pi,40)'; z=r\*exp(I\*a);

\>plot2d(exp(z),\>points,\>add):


![images/23030630096_Nur%20Alya%20Fadilah-107.png](images/23030630096_Nur%20Alya%20Fadilah-107.png)

Sebuah vektor bilangan kompleks secara otomatis diplot sebagai kurva
pada bidang kompleks dengan bagian real dan bagian imajiner.


Dalam contoh, kami memplot lingkaran satuan dengan


$$\gamma(t) = e^{it}$$\>t=linspace(0,2pi,1000); ...  
\>   plot2d(exp(I\*t)+exp(4\*I\*t),r=2):


![images/23030630096_Nur%20Alya%20Fadilah-109.png](images/23030630096_Nur%20Alya%20Fadilah-109.png)

# Plot Statistik

Ada banyak fungsi yang dikhususkan pada plot statistik. Salah satu
plot yang sering digunakan adalah plot kolom.


Jumlah kumulatif dari nilai terdistribusi 0-1-normal menghasilkan
jalan acak.


\>plot2d(cumsum(randnormal(1,1000))):


![images/23030630096_Nur%20Alya%20Fadilah-110.png](images/23030630096_Nur%20Alya%20Fadilah-110.png)

Menggunakan dua baris menunjukkan jalan dalam dua dimensi.


\>X=cumsum(randnormal(2,1000)); plot2d(X[1],X[2]):


![images/23030630096_Nur%20Alya%20Fadilah-111.png](images/23030630096_Nur%20Alya%20Fadilah-111.png)

\>columnsplot(cumsum(random(10)),style="/",color=blue):


![images/23030630096_Nur%20Alya%20Fadilah-112.png](images/23030630096_Nur%20Alya%20Fadilah-112.png)

Itu juga dapat menampilkan string sebagai label.


\>months=["Jan","Feb","Mar","Apr","May","Jun", ...  
\>     "Jul","Aug","Sep","Oct","Nov","Dec"];

\>values=[10,12,12,18,22,28,30,26,22,18,12,8];

\>columnsplot(values,lab=months,color=red,style="-");

\>title("Temperature"):


![images/23030630096_Nur%20Alya%20Fadilah-113.png](images/23030630096_Nur%20Alya%20Fadilah-113.png)

\>k=0:10;

\>plot2d(k,bin(10,k),\>bar):


![images/23030630096_Nur%20Alya%20Fadilah-114.png](images/23030630096_Nur%20Alya%20Fadilah-114.png)

\>plot2d(k,bin(10,k)); plot2d(k,bin(10,k),\>points,\>add):


![images/23030630096_Nur%20Alya%20Fadilah-115.png](images/23030630096_Nur%20Alya%20Fadilah-115.png)

\>plot2d(normal(1000),normal(1000),\>points,grid=6,style=".."):


![images/23030630096_Nur%20Alya%20Fadilah-116.png](images/23030630096_Nur%20Alya%20Fadilah-116.png)

\>plot2d(normal(1,1000),\>distribution,style="O"):


![images/23030630096_Nur%20Alya%20Fadilah-117.png](images/23030630096_Nur%20Alya%20Fadilah-117.png)

\>plot2d("qnormal",0,5;2.5,0.5,\>filled):


![images/23030630096_Nur%20Alya%20Fadilah-118.png](images/23030630096_Nur%20Alya%20Fadilah-118.png)

Untuk memplot distribusi statistik eksperimental, Anda dapat
menggunakan distribution=n dengan plot2d.


\>w=randexponential(1,1000); // exponential distribution

\>plot2d(w,\>distribution): // or distribution=n with n intervals


![images/23030630096_Nur%20Alya%20Fadilah-119.png](images/23030630096_Nur%20Alya%20Fadilah-119.png)

Atau Anda dapat menghitung distribusi dari data dan memplot hasilnya
dengan &gt;bar di plot3d, atau dengan plot kolom.


\>w=normal(1000); // 0-1-normal distribution

\>{x,y}=histo(w,10,v=[-6,-4,-2,-1,0,1,2,4,6]); // interval bounds v

\>plot2d(x,y,\>bar):


![images/23030630096_Nur%20Alya%20Fadilah-120.png](images/23030630096_Nur%20Alya%20Fadilah-120.png)

Fungsi statplot() menyetel gaya dengan string sederhana.


\>statplot(1:10,cumsum(random(10)),"b"):


![images/23030630096_Nur%20Alya%20Fadilah-121.png](images/23030630096_Nur%20Alya%20Fadilah-121.png)

\>n=10; i=0:n; ...  
\>   plot2d(i,bin(n,i)/2^n,a=0,b=10,c=0,d=0.3); ...  
\>   plot2d(i,bin(n,i)/2^n,points=true,style="ow",add=true,color=blue):


![images/23030630096_Nur%20Alya%20Fadilah-122.png](images/23030630096_Nur%20Alya%20Fadilah-122.png)

Selain itu, data dapat diplot sebagai batang. Dalam hal ini, x harus
diurutkan dan satu elemen lebih panjang dari y. Bilah akan memanjang
dari x[i] ke x[i+1] dengan nilai y[i]. Jika x memiliki ukuran yang
sama dengan y, maka akan diperpanjang satu elemen dengan spasi
terakhir.


Gaya isian dapat digunakan seperti di atas.


\>n=10; k=bin(n,0:n); ...  
\>   plot2d(-0.5:n+0.5,k,bar=true,fillcolor=lightgray):


![images/23030630096_Nur%20Alya%20Fadilah-123.png](images/23030630096_Nur%20Alya%20Fadilah-123.png)

Data untuk plot batang (bar=1) dan histogram (histogram=1) dapat
dinyatakan secara eksplisit dalam xv dan yv, atau dapat dihitung dari
distribusi empiris dalam xv dengan &gt;distribusi (atau distribusi=n).
Histogram nilai xv akan dihitung secara otomatis dengan &gt;histogram.
Jika &gt;genap ditentukan, nilai xv akan dihitung dalam interval bilangan
bulat.


\>plot2d(normal(10000),distribution=50):


![images/23030630096_Nur%20Alya%20Fadilah-124.png](images/23030630096_Nur%20Alya%20Fadilah-124.png)

\>k=0:10; m=bin(10,k); x=(0:11)-0.5; plot2d(x,m,\>bar):


![images/23030630096_Nur%20Alya%20Fadilah-125.png](images/23030630096_Nur%20Alya%20Fadilah-125.png)

\>columnsplot(m,k):


![images/23030630096_Nur%20Alya%20Fadilah-126.png](images/23030630096_Nur%20Alya%20Fadilah-126.png)

\>plot2d(random(600)\*6,histogram=6):


![images/23030630096_Nur%20Alya%20Fadilah-127.png](images/23030630096_Nur%20Alya%20Fadilah-127.png)

Untuk distribusi, ada parameter distribusi=n, yang menghitung nilai
secara otomatis dan mencetak distribusi relatif dengan n sub-interval.


\>plot2d(normal(1,1000),distribution=10,style="\\/"):


![images/23030630096_Nur%20Alya%20Fadilah-128.png](images/23030630096_Nur%20Alya%20Fadilah-128.png)

Dengan parameter even=true, ini akan menggunakan interval integer.


\>plot2d(intrandom(1,1000,10),distribution=10,even=true):


![images/23030630096_Nur%20Alya%20Fadilah-129.png](images/23030630096_Nur%20Alya%20Fadilah-129.png)

Dengan parameter even=true, ini akan menggunakan interval integer.


\>columnsplot(getmultiplicities(1:6,intrandom(1,6000,6))):


![images/23030630096_Nur%20Alya%20Fadilah-130.png](images/23030630096_Nur%20Alya%20Fadilah-130.png)

\>plot2d(normal(1,1000),\>distribution); ...  
\>     plot2d("qnormal(x)",color=red,thickness=2,\>add):


![images/23030630096_Nur%20Alya%20Fadilah-131.png](images/23030630096_Nur%20Alya%20Fadilah-131.png)

Ada juga banyak plot khusus untuk statistik. Boxplot menunjukkan
kuartil dari distribusi ini dan banyak outlier. Menurut definisi,
outlier dalam boxplot adalah data yang melebihi 1,5 kali kisaran 50%
tengah plot.


\>M=normal(5,1000); boxplot(quartiles(M)):


![images/23030630096_Nur%20Alya%20Fadilah-132.png](images/23030630096_Nur%20Alya%20Fadilah-132.png)

# Fungsi Implisit

Plot implisit menunjukkan garis level yang menyelesaikan f(x,y)=level,
di mana "level" dapat berupa nilai tunggal atau vektor nilai. Jika
level="auto", akan ada garis level nc, yang akan menyebar antara
fungsi minimum dan maksimum secara merata. Warna yang lebih gelap atau
lebih terang dapat ditambahkan dengan &gt;hue untuk menunjukkan nilai
fungsi. Untuk fungsi implisit, xv harus berupa fungsi atau ekspresi
dari parameter x dan y, atau, sebagai alternatif, xv dapat berupa
matriks nilai.


Euler dapat menandai garis level


dari fungsi apapun.


Untuk menggambar himpunan f(x,y)=c untuk satu atau lebih konstanta c,
Anda dapat menggunakan plot2d() dengan plot implisitnya di dalam
bidang. Parameter untuk c adalah level=c, di mana c dapat berupa
vektor garis level. Selain itu, skema warna dapat digambar di latar
belakang untuk menunjukkan nilai fungsi untuk setiap titik dalam plot.
Parameter "n" menentukan kehalusan plot.


\>aspect(1.5); 

\>plot2d("x^2+y^2-x\*y-x",r=1.5,level=0,contourcolor=red):


![images/23030630096_Nur%20Alya%20Fadilah-133.png](images/23030630096_Nur%20Alya%20Fadilah-133.png)

\>expr := "2\*x^2+x\*y+3\*y^4+y"; // define an expression f(x,y)

\>plot2d(expr,level=0): // Solutions of f(x,y)=0


![images/23030630096_Nur%20Alya%20Fadilah-134.png](images/23030630096_Nur%20Alya%20Fadilah-134.png)

\>plot2d(expr,level=0:0.5:20,\>hue,contourcolor=white,n=200): // nice


![images/23030630096_Nur%20Alya%20Fadilah-135.png](images/23030630096_Nur%20Alya%20Fadilah-135.png)

\>plot2d(expr,level=0:0.5:20,\>hue,\>spectral,n=200,grid=4): // nicer


![images/23030630096_Nur%20Alya%20Fadilah-136.png](images/23030630096_Nur%20Alya%20Fadilah-136.png)

Ini berfungsi untuk plot data juga. Tetapi Anda harus menentukan
rentangnya


untuk label sumbu.


\>x=-2:0.05:1; y=x'; z=expr(x,y);

\>plot2d(z,level=0,a=-1,b=2,c=-2,d=1,\>hue):


![images/23030630096_Nur%20Alya%20Fadilah-137.png](images/23030630096_Nur%20Alya%20Fadilah-137.png)

\>plot2d("x^3-y^2",\>contour,\>hue,\>spectral):


![images/23030630096_Nur%20Alya%20Fadilah-138.png](images/23030630096_Nur%20Alya%20Fadilah-138.png)

\>plot2d("x^3-y^2",level=0,contourwidth=3,\>add,contourcolor=red):


![images/23030630096_Nur%20Alya%20Fadilah-139.png](images/23030630096_Nur%20Alya%20Fadilah-139.png)

\>z=z+normal(size(z))\*0.2;

\>plot2d(z,level=0.5,a=-1,b=2,c=-2,d=1):


![images/23030630096_Nur%20Alya%20Fadilah-140.png](images/23030630096_Nur%20Alya%20Fadilah-140.png)

\>plot2d(expr,level=[0:0.2:5;0.05:0.2:5.05],color=lightgray):


![images/23030630096_Nur%20Alya%20Fadilah-141.png](images/23030630096_Nur%20Alya%20Fadilah-141.png)

\>plot2d("x^2+y^3+x\*y",level=1,r=4,n=100):


![images/23030630096_Nur%20Alya%20Fadilah-142.png](images/23030630096_Nur%20Alya%20Fadilah-142.png)

\>plot2d("x^2+2\*y^2-x\*y",level=0:0.1:10,n=100,contourcolor=white,\>hue):


![images/23030630096_Nur%20Alya%20Fadilah-143.png](images/23030630096_Nur%20Alya%20Fadilah-143.png)

Juga dimungkinkan untuk mengisi set


dengan rentang tingkat.


Dimungkinkan untuk mengisi wilayah nilai untuk fungsi tertentu. Untuk
ini, level harus berupa matriks 2xn. Baris pertama adalah batas bawah
dan baris kedua berisi batas atas.


\>plot2d(expr,level=[0;1],style="-",color=blue): // 0 <= f(x,y) <= 1


![images/23030630096_Nur%20Alya%20Fadilah-144.png](images/23030630096_Nur%20Alya%20Fadilah-144.png)

Plot implisit juga dapat menunjukkan rentang level. Kemudian level
harus berupa matriks 2xn dari interval level, di mana baris pertama
berisi awal dan baris kedua adalah akhir dari setiap interval. Atau,
vektor baris sederhana dapat digunakan untuk level, dan parameter dl
memperluas nilai level ke interval.


\>plot2d("x^4+y^4",r=1.5,level=[0;1],color=blue,style="/"):


![images/23030630096_Nur%20Alya%20Fadilah-145.png](images/23030630096_Nur%20Alya%20Fadilah-145.png)

\>plot2d("x^2+y^3+x\*y",level=[0,2,4;1,3,5],style="/",r=2,n=100):


![images/23030630096_Nur%20Alya%20Fadilah-146.png](images/23030630096_Nur%20Alya%20Fadilah-146.png)

\>plot2d("x^2+y^3+x\*y",level=-10:20,r=2,style="-",dl=0.1,n=100):


![images/23030630096_Nur%20Alya%20Fadilah-147.png](images/23030630096_Nur%20Alya%20Fadilah-147.png)

\>plot2d("sin(x)\*cos(y)",r=pi,\>hue,\>levels,n=100):


![images/23030630096_Nur%20Alya%20Fadilah-148.png](images/23030630096_Nur%20Alya%20Fadilah-148.png)

Dimungkinkan juga untuk menandai suatu wilayah


$$a \le f(x,y) \le b.$$Ini dilakukan dengan menambahkan level dengan dua baris.


\>plot2d("(x^2+y^2-1)^3-x^2\*y^3",r=1.3, ...  
\>     style="#",color=red,<outline, ...  
\>     level=[-2;0],n=100):


![images/23030630096_Nur%20Alya%20Fadilah-150.png](images/23030630096_Nur%20Alya%20Fadilah-150.png)

Dimungkinkan untuk menentukan level tertentu. Misalnya, kita dapat
memplot solusi persamaan seperti


$$x^3-xy+x^2y^2=6$$\>plot2d("x^3-x\*y+x^2\*y^2",r=6,level=1,n=100):


![images/23030630096_Nur%20Alya%20Fadilah-152.png](images/23030630096_Nur%20Alya%20Fadilah-152.png)

\>function starplot1 (v, style="/", color=green, lab=none) ...


      if !holding() then clg; endif;
      w=window(); window(0,0,1024,1024);
      h=holding(1);
      r=max(abs(v))*1.2;
      setplot(-r,r,-r,r);
      n=cols(v); t=linspace(0,2pi,n);
      v=v|v[1]; c=v*cos(t); s=v*sin(t);
      cl=barcolor(color); st=barstyle(style);
      loop 1 to n
        polygon([0,c[#],c[#+1]],[0,s[#],s[#+1]],1);
        if lab!=none then
          rlab=v[#]+r*0.1;
          {col,row}=toscreen(cos(t[#])*rlab,sin(t[#])*rlab);
          ctext(""+lab[#],col,row-textheight()/2);
        endif;
      end;
      barcolor(cl); barstyle(st);
      holding(h);
      window(w);
    endfunction
</pre>
Tidak ada kotak atau sumbu kutu di sini. Selain itu, kami menggunakan
jendela penuh untuk plot.


Kami memanggil reset sebelum kami menguji plot ini untuk mengembalikan
default grafis. Ini tidak perlu, jika Anda yakin plot Anda berhasil.


\>reset; starplot1(normal(1,10)+5,color=red,lab=1:10):


![images/23030630096_Nur%20Alya%20Fadilah-153.png](images/23030630096_Nur%20Alya%20Fadilah-153.png)

Terkadang, Anda mungkin ingin merencanakan sesuatu yang tidak dapat
dilakukan plot2d, tetapi hampir.


Dalam fungsi berikut, kami melakukan plot impuls logaritmik. plot2d
dapat melakukan plot logaritmik, tetapi tidak untuk batang impuls.


\>function logimpulseplot1 (x,y) ...


      {x0,y0}=makeimpulse(x,log(y)/log(10));
      plot2d(x0,y0,>bar,grid=0);
      h=holding(1);
      frame();
      xgrid(ticks(x));
      p=plot();
      for i=-10 to 10;
        if i<=p[4] and i>=p[3] then
           ygrid(i,yt="10^"+i);
        endif;
      end;
      holding(h);
    endfunction
</pre>
Mari kita uji dengan nilai yang terdistribusi secara eksponensial.


\>aspect(1.5); x=1:10; y=-log(random(size(x)))\*200; ...  
\>   logimpulseplot1(x,y):


![images/23030630096_Nur%20Alya%20Fadilah-154.png](images/23030630096_Nur%20Alya%20Fadilah-154.png)

Mari kita menganimasikan kurva 2D menggunakan plot langsung. Perintah
plot(x,y) hanya memplot kurva ke jendela plot. setplot(a,b,c,d)
mengatur jendela ini.


Fungsi wait(0) memaksa plot untuk muncul di jendela grafik. Jika
tidak, menggambar ulang terjadi dalam interval waktu yang jarang.


\>function animliss (n,m) ...


    t=linspace(0,2pi,500);
    f=0;
    c=framecolor(0);
    l=linewidth(2);
    setplot(-1,1,-1,1);
    repeat
      clg;
      plot(sin(n*t),cos(m*t+f));
      wait(0);
      if testkey() then break; endif;
      f=f+0.02;
    end;
    framecolor(c);
    linewidth(l);
    endfunction
</pre>
Tekan sembarang tombol untuk menghentikan animasi ini.


\>animliss(2,3); // lihat hasilnya, jika sudah puas, tekan ENTER


# Plot Logaritmik

EMT menggunakan parameter "logplot" untuk skala logaritmik.


Plot logaritma dapat diplot baik menggunakan skala logaritma dalam y
dengan logplot=1, atau menggunakan skala logaritma dalam x dan y
dengan logplot=2, atau dalam x dengan logplot=3.


  - logplot=1: y-logaritma  
  - logplot=2: x-y-logaritma  
  - logplot=3: x-logaritma  

\>plot2d("exp(x^3-x)\*x^2",1,5,logplot=1):


![images/23030630096_Nur%20Alya%20Fadilah-155.png](images/23030630096_Nur%20Alya%20Fadilah-155.png)

\>plot2d("exp(x+sin(x))",0,100,logplot=1):


![images/23030630096_Nur%20Alya%20Fadilah-156.png](images/23030630096_Nur%20Alya%20Fadilah-156.png)

\>plot2d("exp(x+sin(x))",10,100,logplot=2):


![images/23030630096_Nur%20Alya%20Fadilah-157.png](images/23030630096_Nur%20Alya%20Fadilah-157.png)

\>plot2d("gamma(x)",1,10,logplot=1):


![images/23030630096_Nur%20Alya%20Fadilah-158.png](images/23030630096_Nur%20Alya%20Fadilah-158.png)

\>plot2d("log(x\*(2+sin(x/100)))",10,1000,logplot=3):


![images/23030630096_Nur%20Alya%20Fadilah-159.png](images/23030630096_Nur%20Alya%20Fadilah-159.png)

Ini juga berfungsi dengan plot data.


\>0^(1:20); y=x^2-x;

\>plot2d(x,y,logplot=2):


    Function xylogplot needs positive values for y
    Try "trace errors" to inspect local variables after errors.
    plot2d:
        xylogplot(xx,yy,=points,=color,=frame,=grid,=ticks);

\>...  
\>   ...  
\>   ...  
\>   ...  
\>   ...  
\>   ...  
\>  
# Rujukan Lengkap Fungsi plot2d()

  function plot2d (xv, yv, btest, a, b, c, d, xmin, xmax, r, n,  ..  
  logplot, grid, frame, framecolor, square, color, thickness, style, ..  
  auto, add, user, delta, points, addpoints, pointstyle, bar, histogram,  ..  
  distribution, even, steps, own, adaptive, hue, level, contour,  ..  
  nc, filled, fillcolor, outline, title, xl, yl, maps, contourcolor, ..  
  contourwidth, ticks, margin, clipping, cx, cy, insimg, spectral,  ..  
  cgrid, vertical, smaller, dl, niveau, levels)  

Multipurpose plot function for plots in the plane (2D plots). This function can do
plots of functions of one variables, data plots, curves in the plane, bar plots, grids
of complex numbers, and implicit plots of functions of two variables.


Parameters




x,y       : equations, functions or data vectors


a,b,c,d   : Plot area (default a=-2,b=2)


r         : if r is set, then a=cx-r, b=cx+r, c=cy-r, d=cy+r


            r can be a vector [rx,ry] or a vector [rx1,rx2,ry1,ry2].


xmin,xmax : range of the parameter for curves


auto      : Determine y-range automatically (default)


square    : if true, try to keep square x-y-ranges


n         : number of intervals (default is adaptive)


grid      : 0 = no grid and labels,


            1 = axis only,


            2 = normal grid (see below for the number of grid lines)


            3 = inside axis


            4 = no grid


            5 = full grid including margin


            6 = ticks at the frame


            7 = axis only


            8 = axis only, sub-ticks


frame     : 0 = no frame


framecolor: color of the frame and the grid


margin    : number between 0 and 0.4 for the margin around the plot


color     : Color of curves. If this is a vector of colors,


            it will be used for each row of a matrix of plots. In the case of


            point plots, it should be a column vector. If a row vector or a


            full matrix of colors is used for point plots, it will be used for


            each data point.


thickness : line thickness for curves


            This value can be smaller than 1 for very thin lines.


style     : Plot style for lines, markers, and fills.


            For points use


            "[]", "&lt;&gt;", ".", "..", "...",


            "*", "+", "|", "-", "o"


            "[]#", "&lt;&gt;#", "o#" (filled shapes)


            "[]w", "&lt;&gt;w", "ow" (non-transparent)


            For lines use


            "-", "--", "-.", ".", ".-.", "-.-", "-&gt;"


            For filled polygons or bar plots use


            "#", "#O", "O", "/", "\", "\/",


            "+", "|", "-", "t"


points    : plot single points instead of line segments


addpoints : if true, plots line segments and points


add       : add the plot to the existing plot


user      : enable user interaction for functions


delta     : step size for user interaction


bar       : bar plot (x are the interval bounds, y the interval values)


histogram : plots the frequencies of x in n subintervals


distribution=n : plots the distribution of x with n subintervals


even      : use inter values for automatic histograms.


steps     : plots the function as a step function (steps=1,2)


adaptive  : use adaptive plots (n is the minimal number of steps)


level     : plot level lines of an implicit function of two variables


outline   : draws boundary of level ranges.




If the level value is a 2xn matrix, ranges of levels will be drawn


in the color using the given fill style. If outline is true, it


will be drawn in the contour color. Using this feature, regions of


f(x,y) between limits can be marked.




hue       : add hue color to the level plot to indicate the function


            value


contour   : Use level plot with automatic levels


nc        : number of automatic level lines


title     : plot title (default "")


xl, yl    : labels for the x- and y-axis


smaller   : if &gt;0, there will be more space to the left for labels.


vertical  :


  Turns vertical labels on or off. This changes the global variable


  verticallabels locally for one plot. The value 1 sets only vertical


  text, the value 2 uses vertical numerical labels on the y axis.


filled    : fill the plot of a curve


fillcolor : fill color for bar and filled curves


outline   : boundary for filled polygons


logplot   : set logarithmic plots


            1 = logplot in y,


            2 = logplot in xy,


            3 = logplot in x


own       :


  A string, which points to an own plot routine. With &gt;user, you get


  the same user interaction as in plot2d. The range will be set


  before each call to your function.


maps      : map expressions (0 is faster), functions are always mapped.


contourcolor : color of contour lines


contourwidth : width of contour lines


clipping  : toggles the clipping (default is true)


title     :


  This can be used to describe the plot. The title will appear above


  the plot. Moreover, a label for the x and y axis can be added with


  xl="string" or yl="string". Other labels can be added with the


  functions label() or labelbox(). The title can be a unicode


  string or an image of a Latex formula.


cgrid     :


  Determines the number of grid lines for plots of complex grids.


  Should be a divisor of the the matrix size minus 1 (number of


  subintervals). cgrid can be a vector [cx,cy].


Overview


The function can plot


* 
expressions, call collections or functions of one variable,

* 
parametric curves,

* 
x data against y data,

* 
implicit functions,

* 
bar plots,

* 
complex grids,

* 
polygons.


If a function or expression for xv is given, plot2d() will compute


values in the given range using the function or expression. The


expression must be an expression in the variable x. The range must


be defined in the parameters a and b unless the default range


[-2,2] should be used. The y-range will be computed automatically,


unless c and d are specified, or a radius r, which yields the range


[-r,r] for x and y. For plots of functions, plot2d will use an


adaptive evaluation of the function by default. To speed up the


plot for complicated functions, switch this off with &lt;adaptive, and


optionally decrease the number of intervals n. Moreover, plot2d()


will by default use mapping. I.e., it will compute the plot element


for element. If your expression or your functions can handle a


vector x, you can switch that off with &lt;maps for faster evaluation.


Note that adaptive plots are always computed element for element. 


If functions or expressions for both xv and for yv are specified,


plot2d() will compute a curve with the xv values as x-coordinates


and the yv values as y-coordinates. In this case, a range should be


defined for the parameter using xmin, xmax. Expressions contained


in strings must always be expressions in the parameter variable x.

\section{EMT UNTUK PLOT 3D}
# 23030630096_Nur Alya Fadilah_3D (1)
Nama: Nur Alya Fadilah


NIM: 23030630096


Matematika E 2023


# Menggambar Plot 3D dengan EMT

Ini adalah pengenalan plot 3D di Euler. Kita membutuhkan plot 3D untuk
memvisualisasikan fungsi dari dua variabel.


Euler menggambar fungsi tersebut menggunakan algoritma pengurutan
untuk menyembunyikan bagian di latar belakang. Secara umum, Euler
menggunakan proyeksi pusat. Standarnya adalah dari kuadran x-y positif
menuju titik asal x=y=z=0, tetapi sudut=0 terlihat dari arah sumbu y.
Sudut pandang dan ketinggian dapat diubah.


Euler dapat merencanakan


* 
permukaan dengan bayangan dan garis level atau rentang level,

* 
awan poin,

* 
kurva parametrik,

* 
permukaan implisit.


Plot 3D dari suatu fungsi menggunakan plot3d. Cara termudah adalah
dengan memplot ekspresi dalam x dan y. Parameter r mengatur kisaran
plot di sekitar (0,0).


\>aspect(1.5); plot3d("x^2+sin(y)",r=pi):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-001.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-001.png)

# Fungsi dua Variabel

Untuk grafik fungsi, gunakan


* 
ekspresi sederhana dalam x dan y,

* 
nama fungsi dari dua variabell

* 
atau matriks data.


Standarnya adalah kotak kawat yang diisi dengan warna berbeda di kedua
sisi. Perhatikan bahwa jumlah default interval grid adalah 10, tetapi
plot menggunakan jumlah default 40x40 persegi panjang untuk membangun
permukaan. Ini bisa diubah.


* 
n=40, n=[40,40]: jumlah garis grid di setiap arah

* 
grid=10, grid=[10,10]: jumlah garis grid di setiap arah.


Kami menggunakan default n=40 dan grid=10.


\>plot3d("x^2+y^2"):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-002.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-002.png)

Interaksi pengguna dimungkinkan dengan &gt;parameter pengguna. Pengguna
dapat menekan tombol berikut.


* 
kiri, kanan, atas, bawah: putar sudut pandang

* 
+,-: memperbesar atau memperkecil

* 
a: menghasilkan anaglyph (lihat di bawah)

* 
l: beralih memutar sumber cahaya (lihat di bawah)

* 
spasi: reset ke default

* 
kembali: akhiri interaksi


\>plot3d("exp(-x^2+y^2)",\>user, ...  
\>     title="Turn with the vector keys (press return to finish)"):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-003.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-003.png)

Rentang plot untuk fungsi dapat ditentukan dengan


* 
a,b: rentang-x

* 
c,d: rentang-y

* 
r: persegi simetris di sekitar (0,0).

* 
n: jumlah subinterval untuk plot.


Ada beberapa parameter untuk menskalakan fungsi atau mengubah tampilan
grafik.


fscale: skala ke nilai fungsi (defaultnya adalah &lt;fscale).


skala: angka atau vektor 1x2 untuk skala ke arah x dan y.


bingkai: jenis bingkai (default 1).


\>plot3d("exp(-(x^2+y^2)/5)",r=10,n=80,fscale=4,scale=1.2,frame=3):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-004.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-004.png)

Tampilan dapat diubah dengan berbagai cara.


* 
jarak: jarak pandang ke plot.

* 
zoom: nilai zoom.

* 
sudut: sudut terhadap sumbu y negatif dalam radian.

* 
tinggi: ketinggian tampilan dalam radian.


Nilai default dapat diperiksa atau diubah dengan fungsi view(). Ini
mengembalikan parameter dalam urutan di atas.


\>view


    [5,  2.6,  2,  0.4]

Jarak yang lebih dekat membutuhkan lebih sedikit zoom. Efeknya lebih
seperti lensa sudut lebar.


Dalam contoh berikut, sudut=0 dan tinggi=0 terlihat dari sumbu y
negatif. Label sumbu untuk y disembunyikan dalam kasus ini.


\>plot3d("x^2+y",distance=3,zoom=2,angle=0,height=0):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-005.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-005.png)

Plot terlihat selalu ke pusat kubus plot. Anda dapat memindahkan pusat
dengan parameter tengah.


\>plot3d("x^4+y^2",a=0,b=1,c=-1,d=1,angle=-20,height=20, ...  
\>     center=[0.4,0,0],zoom=5):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-006.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-006.png)

Plot diskalakan agar sesuai dengan kubus satuan untuk dilihat. Jadi
tidak perlu mengubah jarak atau zoom tergantung pada ukuran plot.
Namun, label mengacu pada ukuran sebenarnya.


Jika Anda mematikannya dengan scale=false, Anda perlu berhati-hati,
bahwa plot masih cocok dengan jendela plot, dengan mengubah jarak
pandang atau zoom, dan memindahkan pusat.


\>plot3d("5\*exp(-x^2-y^2)",r=2,<fscale,<scale,distance=13,height=50, ...  
\>     center=[0,0,-2],frame=3):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-007.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-007.png)

Sebuah plot kutub juga tersedia. Parameter polar=true menggambar plot
polar. Fungsi tersebut harus tetap merupakan fungsi dari x dan y.
Parameter "fscale" menskalakan fungsi dengan skala sendiri. Jika
tidak, fungsi diskalakan agar sesuai dengan kubus.


\>plot3d("1/(x^2+y^2+1)",r=5,\>polar, ...  
\>   fscale=2,\>hue,n=100,zoom=4,\>contour,color=gray):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-008.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-008.png)

\>function f(r) := exp(-r/2)\*cos(r); ...  
\>   plot3d("f(x^2+y^2)",\>polar,scale=[1,1,0.4],r=2pi,frame=3,zoom=4):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-009.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-009.png)

Rotasi parameter memutar fungsi dalam x di sekitar sumbu x.


* 
rotate=1: Menggunakan sumbu x

* 
rotate=2: Menggunakan sumbu z


\>plot3d("x^2+1",a=-1,b=1,rotate=true,grid=5):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-010.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-010.png)

Berikut adalah plot dengan tiga fungsi.


\>plot3d("x","x^2+y^2","y",r=2,zoom=3.5,frame=3):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-011.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-011.png)

# Plot Kontur

Untuk plot, Euler menambahkan garis grid. Sebagai gantinya
dimungkinkan untuk menggunakan garis level dan rona satu warna atau
rona berwarna spektral. Euler dapat menggambar tinggi fungsi pada plot
dengan bayangan. Di semua plot 3D, Euler dapat menghasilkan anaglyph
merah/sian.


-&gt; hue: Menyalakan bayangan cahaya alih-alih kabel.


-&gt; kontur: Memplot garis kontur otomatis pada plot.


- level=... (atau level): Sebuah vektor nilai untuk garis kontur.


Standarnya adalah level="auto", yang menghitung beberapa garis level
secara otomatis. Seperti yang Anda lihat di plot, level sebenarnya
adalah rentang level.


Gaya default dapat diubah. Untuk plot kontur berikut, kami menggunakan
grid yang lebih halus untuk 100x100 poin, skala fungsi dan plot, dan
menggunakan sudut pandang yang berbeda.


\>plot3d("exp(-x^2-y^2)",r=2,n=100,level="thin", ...  
\>    \>contour,\>spectral,fscale=1,scale=1.1,angle=45,height=20):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-012.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-012.png)

\>plot3d("exp(x\*y)",angle=100,\>contour,color=green):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-013.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-013.png)

Bayangan default menggunakan warna abu-abu. Tetapi rentang warna
spektral juga tersedia.


-&gt; spektral: Menggunakan skema spektral default


- color=...: Menggunakan warna khusus atau skema spektral


Untuk plot berikut, kami menggunakan skema spektral default dan
menambah jumlah titik untuk mendapatkan tampilan yang sangat halus.


\>plot3d("x^2+y^2",\>spectral,\>contour,n=100):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-014.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-014.png)

Alih-alih garis level otomatis, kita juga dapat mengatur nilai garis
level. Ini akan menghasilkan garis level tipis alih-alih rentang
level.


\>plot3d("x^2-y^2",0,1,0,1,angle=220,level=-1:0.2:1,color=redgreen):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-015.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-015.png)

Dalam plot berikut, kami menggunakan dua pita level yang sangat luas
dari -0,1 hingga 1, dan dari 0,9 hingga 1. Ini dimasukkan sebagai
matriks dengan batas level sebagai kolom.


Selain itu, kami melapisi kisi dengan 10 interval di setiap arah.


\>plot3d("x^2+y^3",level=[-0.1,0.9;0,1], ...  
\>     \>spectral,angle=30,grid=10,contourcolor=gray):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-016.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-016.png)

Dalam contoh berikut, kami memplot himpunan, di mana


$$f(x,y) = x^y-y^x = 0$$Kami menggunakan satu garis tipis untuk garis level.


\>plot3d("x^y-y^x",level=0,a=0,b=6,c=0,d=6,contourcolor=red,n=100):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-018.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-018.png)

Dimungkinkan untuk menunjukkan bidang kontur di bawah plot. Warna dan
jarak ke plot dapat ditentukan.


\>plot3d("x^2+y^4",\>cp,cpcolor=green,cpdelta=0.2):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-019.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-019.png)

Berikut adalah beberapa gaya lagi. Kami selalu mematikan frame, dan
menggunakan berbagai skema warna untuk plot dan grid.


\>figure(2,2); ...  
\>   expr="y^3-x^2"; ...  
\>   figure(1);  ...  
\>     plot3d(expr,<frame,\>cp,cpcolor=spectral); ...  
\>   figure(2);  ...  
\>     plot3d(expr,<frame,\>spectral,grid=10,cp=2); ...  
\>   figure(3);  ...  
\>     plot3d(expr,<frame,\>contour,color=gray,nc=5,cp=3,cpcolor=greenred); ...  
\>   figure(4);  ...  
\>     plot3d(expr,<frame,\>hue,grid=10,\>transparent,\>cp,cpcolor=gray); ...  
\>   figure(0):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-020.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-020.png)

Ada beberapa skema spektral lainnya, bernomor dari 1 hingga 9. Tetapi
Anda juga dapat menggunakan warna=nilai, di mana nilai


* 
spectral: untuk rentang dari biru ke merah

* 
white: untuk rentang yang lebih redup

* 
yellowblue,purplegreen,blueyellow,greenred

* 
blueyellow, greenpurple,yellowblue,redgreen


\>figure(3,3); ...  
\>   for i=1:9;  ...  
\>     figure(i); plot3d("x^2+y^2",spectral=i,\>contour,\>cp,<frame,zoom=4);  ...  
\>   end; ...  
\>   figure(0):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-021.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-021.png)

Sumber cahaya dapat diubah dengan l dan tombol kursor selama interaksi
pengguna. Itu juga dapat diatur dengan parameter.


* 
light: arah untuk cahaya

* 
amb: cahaya sekitar antara 0 dan 1


Perhatikan bahwa program tidak membuat perbedaan antara sisi plot.
Tidak ada bayangan. Untuk ini, Anda perlu Povray.


\>plot3d("-x^2-y^2", ...  
\>     hue=true,light=[0,1,1],amb=0,user=true, ...  
\>     title="Press l and cursor keys (return to exit)"):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-022.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-022.png)

Parameter warna mengubah warna permukaan. Warna garis level juga dapat
diubah.


\>plot3d("-x^2-y^2",color=rgb(0.2,0.2,0),hue=true,frame=false, ...  
\>     zoom=3,contourcolor=red,level=-2:0.1:1,dl=0.01):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-023.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-023.png)

Warna 0 memberikan efek pelangi khusus.


\>plot3d("x^2/(x^2+y^2+1)",color=0,hue=true,grid=10):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-024.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-024.png)

Permukaannya juga bisa transparan.


\>plot3d("x^2+y^2",\>transparent,grid=10,wirecolor=red):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-025.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-025.png)

# Plot Implisit

Ada juga plot implisit dalam tiga dimensi. Euler menghasilkan
pemotongan melalui objek. Fitur plot3d termasuk plot implisit.
Plot-plot ini menunjukkan himpunan nol dari suatu fungsi dalam tiga
variabel.


Solusi dari


$$f(x,y,z) = 0$$dapat divisualisasikan dalam potongan sejajar dengan bidang x-y-, x-z-
dan y-z.


* 
implicit=1: memotong sejajar bidang y-z

* 
implicit=2: memotong sejajar bidang x-z

* 
implicit=4: memotong sejajar bidang x-y


Tambahkan nilai-nilai ini, jika Anda suka. Dalam contoh kita plot


$$M = \{ (x,y,z) : x^2+y^3+zy=1 \}$$\>plot3d("x^2+y^3+z\*y-1",r=5,implicit=3):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-028.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-028.png)

\>plot3d("x^2+y^2+4\*x\*z+z^3",\>implicit,r=2,zoom=2.5):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-029.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-029.png)

# Merencanakan Data 3D

Sama seperti plot2d, plot3d menerima data. Untuk objek 3D, Anda perlu
menyediakan matriks nilai x-, y- dan z, atau tiga fungsi atau ekspresi
fx(x,y), fy(x,y), fz(x,y).


$$\gamma(t,s) = (x(t,s),y(t,s),z(t,s))$$Karena x,y,z adalah matriks, kita asumsikan bahwa (t,s) melalui sebuah
kotak persegi. Hasilnya, Anda dapat memplot gambar persegi panjang di
ruang angkasa.


Anda dapat menggunakan bahasa matriks Euler untuk menghasilkan
koordinat secara efektif.


Dalam contoh berikut, kami menggunakan vektor nilai t dan vektor kolom
nilai s untuk membuat parameter permukaan bola. Dalam gambar kita
dapat menandai daerah, dalam kasus kita daerah kutub.


\>t=linspace(0,2pi,180); s=linspace(-pi/2,pi/2,90)'; ...  
\>   x=cos(s)\*cos(t); y=cos(s)\*sin(t); z=sin(s); ...  
\>   plot3d(x,y,z,\>hue, ...  
\>   color=blue,<frame,grid=[10,20], ...  
\>   values=s,contourcolor=red,level=[90-24;90-22], ...  
\>   scale=1.4,height=50):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-031.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-031.png)

Berikut adalah contoh, yang merupakan grafik fungsi.


\>t=-1:0.1:1; s=(-1:0.1:1)'; plot3d(t,s,t\*s,grid=10):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-032.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-032.png)

Namun, kita bisa membuat segala macam permukaan. Berikut adalah
permukaan yang sama dengan fungsi


$$x = y \, z$$\>plot3d(t\*s,t,s,angle=180,grid=10):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-034.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-034.png)

Dengan lebih banyak usaha, kami dapat menghasilkan banyak permukaan.


Dalam contoh berikut, kita membuat tampilan bayangan dari bola yang
terdistorsi. Koordinat biasa untuk bola adalah


$$\gamma(t,s) = (\cos(t)\cos(s),\sin(t)\sin(s),\cos(s))$$dengan


$$0 \le t \le 2\pi, \quad \frac{-\pi}{2} \le s \le \frac{\pi}{2}.$$Kami mendistorsi ini dengan sebuah faktor


$$d(t,s) = \frac{\cos(4t)+\cos(8s)}{4}.$$\>t=linspace(0,2pi,320); s=linspace(-pi/2,pi/2,160)'; ...  
\>   d=1+0.2\*(cos(4\*t)+cos(8\*s)); ...  
\>   plot3d(cos(t)\*cos(s)\*d,sin(t)\*cos(s)\*d,sin(s)\*d,hue=1, ...  
\>     light=[1,0,1],frame=0,zoom=5):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-038.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-038.png)

Tentu saja, titik cloud juga dimungkinkan. Untuk memplot data titik
dalam ruang, kita membutuhkan tiga vektor untuk koordinat titik-titik
tersebut.


Gayanya sama seperti di plot2d dengan points=true;


\>n=500;  ...  
\>     plot3d(normal(1,n),normal(1,n),normal(1,n),points=true,style="."):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-039.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-039.png)

Dimungkinkan juga untuk memplot kurva dalam 3D. Dalam hal ini, lebih
mudah untuk menghitung titik-titik kurva. Untuk kurva di pesawat kami
menggunakan urutan koordinat dan parameter wire=true.


\>t=linspace(0,8pi,500); ...  
\>   plot3d(sin(t),cos(t),t/10,\>wire,zoom=3):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-040.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-040.png)

\>t=linspace(0,4pi,1000); plot3d(cos(t),sin(t),t/2pi,\>wire, ...  
\>   linewidth=3,wirecolor=blue):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-041.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-041.png)

\>X=cumsum(normal(3,100)); ...  
\>    plot3d(X[1],X[2],X[3],\>anaglyph,\>wire):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-042.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-042.png)

EMT juga dapat memplot dalam mode anaglyph. Untuk melihat plot seperti
itu, Anda memerlukan kacamata merah/sian.


\> plot3d("x^2+y^3",\>anaglyph,\>contour,angle=30):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-043.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-043.png)

Seringkali, skema warna spektral digunakan untuk plot. Ini menekankan
ketinggian fungsi.


\>plot3d("x^2\*y^3-y",\>spectral,\>contour,zoom=3.2):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-044.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-044.png)

Euler juga dapat memplot permukaan berparameter, ketika parameternya
adalah nilai x-, y-, dan z dari gambar kotak persegi panjang dalam
ruang.


Untuk demo berikut, kami mengatur parameter u- dan v-, dan
menghasilkan koordinat ruang dari ini.


\>u=linspace(-1,1,10); v=linspace(0,2\*pi,50)'; ...  
\>   X=(3+u\*cos(v/2))\*cos(v); Y=(3+u\*cos(v/2))\*sin(v); Z=u\*sin(v/2); ...  
\>   plot3d(X,Y,Z,\>anaglyph,<frame,\>wire,scale=2.3):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-045.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-045.png)

Berikut adalah contoh yang lebih rumit, yang megah dengan kacamata
merah/sian.


\>u:=linspace(-pi,pi,160); v:=linspace(-pi,pi,400)';  ...  
\>   x:=(4\*(1+.25\*sin(3\*v))+cos(u))\*cos(2\*v); ...  
\>   y:=(4\*(1+.25\*sin(3\*v))+cos(u))\*sin(2\*v); ...  
\>    z=sin(u)+2\*cos(3\*v); ...  
\>   plot3d(x,y,z,frame=0,scale=1.5,hue=1,light=[1,0,-1],zoom=2.8,\>anaglyph):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-046.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-046.png)

# Plot Statistik

Plot bar juga dimungkinkan. Untuk ini, kita harus menyediakan


* 
x: vektor baris dengan n+1 elemen

* 
y: vektor kolom dengan n+1 elemen

* 
z: matriks nilai nxn.


z bisa lebih besar, tetapi hanya nilai nxn yang akan digunakan.


Dalam contoh, pertama-tama kita menghitung nilainya. Kemudian kita
sesuaikan x dan y, sehingga vektor berpusat pada nilai yang digunakan.


\>x=-1:0.1:1; y=x'; z=x^2+y^2; ...  
\>   xa=(x|1.1)-0.05; ya=(y\_1.1)-0.05; ...  
\>   plot3d(xa,ya,z,bar=true):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-047.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-047.png)

Dimungkinkan untuk membagi plot permukaan menjadi dua atau lebih
bagian.


\>x=-1:0.1:1; y=x'; z=x+y; d=zeros(size(x)); ...  
\>   plot3d(x,y,z,disconnect=2:2:20):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-048.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-048.png)

Jika memuat atau menghasilkan matriks data M dari file dan perlu
memplotnya dalam 3D, Anda dapat menskalakan matriks ke [-1,1] dengan
scale(M), atau menskalakan matriks dengan &gt;zscale. Ini dapat
dikombinasikan dengan faktor penskalaan individu yang diterapkan
sebagai tambahan.


\>i=1:20; j=i'; ...  
\>   plot3d(i\*j^2+100\*normal(20,20),\>zscale,scale=[1,1,1.5],angle=-40,zoom=1.8):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-049.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-049.png)

\>Z=intrandom(5,100,6); v=zeros(5,6); ...  
\>   loop 1 to 5; v[#]=getmultiplicities(1:6,Z[#]); end; ...  
\>   columnsplot3d(v',scols=1:5,ccols=[1:5]):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-050.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-050.png)

# Permukaan Benda Putar

\>plot2d("(x^2+y^2-1)^3-x^2\*y^3",r=1.3, ...  
\>   style="#",color=red,<outline, ...  
\>   level=[-2;0],n=100):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-051.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-051.png)

\>ekspresi &= (x^2+y^2-1)^3-x^2\*y^3; $ekspresi


$$\left(y^2+x^2-1\right)^3-x^2\,y^3$$Kami ingin memutar kurva jantung di sekitar sumbu y. Berikut adalah
ungkapan, yang mendefinisikan hati:


$$f(x,y)=(x^2+y^2-1)^3-x^2.y^3.$$Selanjutnya kita atur


$$x=r.cos(a),\quad y=r.sin(a).$$\>function fr(r,a) &= ekspresi with [x=r\*cos(a),y=r\*sin(a)] | trigreduce; $fr(r,a)


$$\left(r^2-1\right)^3+\frac{\left(\sin \left(5\,a\right)-\sin \left(
 3\,a\right)-2\,\sin a\right)\,r^5}{16}$$Hal ini memungkinkan untuk mendefinisikan fungsi numerik, yang
memecahkan r, jika a diberikan. Dengan fungsi itu kita dapat memplot
jantung yang diputar sebagai permukaan parametrik.


\>function map f(a) := bisect("fr",0,2;a); ...  
\>   t=linspace(-pi/2,pi/2,100); r=f(t);  ...  
\>   s=linspace(pi,2pi,100)'; ...  
\>   plot3d(r\*cos(t)\*sin(s),r\*cos(t)\*cos(s),r\*sin(t), ...  
\>   \>hue,<frame,color=red,zoom=4,amb=0,max=0.7,grid=12,height=50):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-056.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-056.png)

Berikut ini adalah plot 3D dari gambar di atas yang diputar di sekitar
sumbu z. Kami mendefinisikan fungsi, yang menggambarkan objek.


\>function f(x,y,z) ...


    r=x^2+y^2;
    return (r+z^2-1)^3-r*z^3;
     endfunction
</pre>
\>plot3d("f(x,y,z)", ...  
\>   xmin=0,xmax=1.2,ymin=-1.2,ymax=1.2,zmin=-1.2,zmax=1.4, ...  
\>   implicit=1,angle=-30,zoom=2.5,n=[10,60,60],\>anaglyph):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-057.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-057.png)

# Plot 3D Khusus

Fungsi plot3d bagus untuk dimiliki, tetapi tidak memenuhi semua
kebutuhan. Selain rutinitas yang lebih mendasar, dimungkinkan untuk
mendapatkan plot berbingkai dari objek apa pun yang Anda suka.


Meskipun Euler bukan program 3D, ia dapat menggabungkan beberapa objek
dasar. Kami mencoba memvisualisasikan paraboloid dan garis
singgungnya.


\>function myplot ...


      y=0:0.01:1; x=(0.1:0.01:1)';
      plot3d(x,y,0.2*(x-0.1)/2,<scale,<frame,>hue, ..
        hues=0.5,>contour,color=orange);
      h=holding(1);
      plot3d(x,y,(x^2+y^2)/2,<scale,<frame,>contour,>hue);
      holding(h);
    endfunction
</pre>
Sekarang framedplot() menyediakan frame, dan mengatur tampilan.


\>framedplot("myplot",[0.1,1,0,1,0,1],angle=-45, ...  
\>     center=[0,0,-0.7],zoom=6):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-058.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-058.png)

Dengan cara yang sama, Anda dapat memplot bidang kontur secara manual.
Perhatikan bahwa plot3d() menyetel jendela ke fullwindow() secara
default, tetapi plotcontourplane() mengasumsikan itu.


\>x=-1:0.02:1.1; y=x'; z=x^2-y^4;

\>function myplot (x,y,z) ...  
\>  
<pre class="udf">      zoom(2);
      wi=fullwindow();
      plotcontourplane(x,y,z,level="auto",<scale);
      plot3d(x,y,z,>hue,<scale,>add,color=white,level="thin");
      window(wi);
      reset();
    endfunction
</pre>
\>myplot(x,y,z):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-059.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-059.png)

# Animasi

Euler dapat menggunakan frame untuk menghitung animasi terlebih
dahulu.


Salah satu fungsi yang memanfaatkan teknik ini adalah rotate. Itu
dapat mengubah sudut pandang dan menggambar ulang plot 3D. Fungsi
memanggil addpage() untuk setiap plot baru. Akhirnya itu menjiwai
plot.


Silakan pelajari sumber rotasi untuk melihat lebih detail.


\>function testplot () := plot3d("x^2+y^3"); ...  
\>   rotate("testplot"); testplot():


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-060.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-060.png)

*Menggambar Povray


Dengan bantuan file Euler povray.e, Euler dapat menghasilkan file
Povray. Hasilnya sangat bagus untuk dilihat.


Anda perlu menginstal Povray (32bit atau 64bit) dari
  <a href="http://www.povray.org/, dan meletakkan sub-direktori "bin" dari">http://www.povray.org/, dan meletakkan sub-direktori "bin" dari</a>


Povray ke jalur lingkungan, atau mengatur variabel "defaultpovray"
dengan path lengkap yang menunjuk ke "pvengine.exe".


Antarmuka Povray dari Euler menghasilkan file Povray di direktori home
pengguna, dan memanggil Povray untuk mengurai file-file ini. Nama file
default adalah current.pov, dan direktori default adalah eulerhome(),
biasanya c:\Users\Username\Euler. Povray menghasilkan file PNG, yang
dapat dimuat oleh Euler ke dalam buku catatan. Untuk membersihkan
file-file ini, gunakan povclear().


Fungsi pov3d memiliki semangat yang sama dengan plot3d. Ini dapat
menghasilkan grafik fungsi f(x,y), atau permukaan dengan koordinat
X,Y,Z dalam matriks, termasuk garis level opsional. Fungsi ini memulai
raytracer secara otomatis, dan memuat adegan ke dalam notebook Euler.


Selain pov3d(), ada banyak fungsi yang menghasilkan objek Povray.
Fungsi-fungsi ini mengembalikan string, yang berisi kode Povray untuk
objek. Untuk menggunakan fungsi ini, mulai file Povray dengan
povstart(). Kemudian gunakan writeln(...) untuk menulis objek ke file
adegan. Terakhir, akhiri file dengan povend(). Secara default,
raytracer akan dimulai, dan PNG akan dimasukkan ke dalam notebook
Euler.


Fungsi objek memiliki parameter yang disebut "look", yang membutuhkan
string dengan kode Povray untuk tekstur dan hasil akhir objek. Fungsi
povlook() dapat digunakan untuk menghasilkan string ini. Ini memiliki
parameter untuk warna, transparansi, Phong Shading dll.


Perhatikan bahwa alam semesta Povray memiliki sistem koordinat lain.
Antarmuka ini menerjemahkan semua koordinat ke sistem Povray. Jadi
Anda dapat terus berpikir dalam sistem koordinat Euler dengan z
menunjuk vertikal ke atas, a nd x,y,z sumbu dalam arti tangan kanan.


Anda perlu memuat file povray.


\>load povray;


Pastikan, direktori bin Povray ada di jalur. Jika tidak, edit variabel
berikut sehingga berisi path ke povray yang dapat dieksekusi.


\>defaultpovray="C:\\Program Files\\POV-Ray\\v3.7\\bin\\pvengine.exe"


    C:\Program Files\POV-Ray\v3.7\bin\pvengine.exe

Untuk kesan pertama, kami memplot fungsi sederhana. Perintah berikut
menghasilkan file povray di direktori pengguna Anda, dan menjalankan
Povray untuk ray tracing file ini.


Jika Anda memulai perintah berikut, GUI Povray akan terbuka,
menjalankan file, dan menutup secara otomatis. Karena alasan keamanan,
Anda akan ditanya, apakah Anda ingin mengizinkan file exe untuk
dijalankan. Anda dapat menekan batal untuk menghentikan pertanyaan
lebih lanjut. Anda mungkin harus menekan OK di jendela Povray untuk
mengakui dialog awal Povray.


\>pov3d("x^2+y^2",zoom=3);


    exec:
        return _exec(program,param,dir,print,hidden,wait);
    povray:
        exec(program,params,defaulthome);
    Try "trace errors" to inspect local variables after errors.
    pov3d:
        if povray then povray(currentfile,w,h,w/h); endif;

Kita dapat membuat fungsi menjadi transparan dan menambahkan hasil
akhir lainnya. Kami juga dapat menambahkan garis level ke plot fungsi.


\>pov3d("x^2+y^3",axiscolor=red,angle=20, ...  
\>     look=povlook(blue,0.2),level=-1:0.5:1,zoom=3.8);


    exec:
        return _exec(program,param,dir,print,hidden,wait);
    povray:
        exec(program,params,defaulthome);
    Try "trace errors" to inspect local variables after errors.
    pov3d:
        if povray then povray(currentfile,w,h,w/h); endif;

Terkadang perlu untuk mencegah penskalaan fungsi, dan menskalakan
fungsi dengan tangan.


Kami memplot himpunan titik di bidang kompleks, di mana produk dari
jarak ke 1 dan -1 sama dengan 1.


\>pov3d("((x-1)^2+y^2)\*((x+1)^2+y^2)/40",r=1.5, ...  
\>     angle=-120,level=1/40,dlevel=0.005,light=[-1,1,1],height=45,n=50, ...  
\>     <fscale,zoom=3.8);


    exec:
        return _exec(program,param,dir,print,hidden,wait);
    povray:
        exec(program,params,defaulthome);
    Try "trace errors" to inspect local variables after errors.
    pov3d:
        if povray then povray(currentfile,w,h,w/h); endif;

# Merencanakan dengan Koordinat

Alih-alih fungsi, kita dapat memplot dengan koordinat. Seperti pada
plot3d, kita membutuhkan tiga matriks untuk mendefinisikan objek.


Dalam contoh kita memutar fungsi di sekitar sumbu z.


\>function f(x) := x^3-x+1; ...  
\>   x=-1:0.01:1; t=linspace(0,2pi,8)'; ...  
\>   Z=x; X=cos(t)\*f(x); Y=sin(t)\*f(x); ...  
\>   pov3d(X,Y,Z,angle=40,height=20,axis=0,zoom=4,light=[10,-5,5]);


    exec:
        return _exec(program,param,dir,print,hidden,wait);
    povray:
        exec(program,params,defaulthome);
    Try "trace errors" to inspect local variables after errors.
    pov3d:
        if povray then povray(currentfile,w,h,w/h); endif;

Dalam contoh berikut, kami memplot gelombang teredam. Kami
menghasilkan gelombang dengan bahasa matriks Euler.


Kami juga menunjukkan, bagaimana objek tambahan dapat ditambahkan ke
adegan pov3d. Untuk pembuatan objek, lihat contoh berikut. Perhatikan
bahwa plot3d menskalakan plot, sehingga cocok dengan kubus satuan.


\>r=linspace(0,1,80); phi=linspace(0,2pi,80)'; ...  
\>   x=r\*cos(phi); y=r\*sin(phi); z=exp(-5\*r)\*cos(8\*pi\*r)/3;  ...  
\>   pov3d(x,y,z,zoom=5,axis=0,add=povsphere([0,0,0.5],0.1,povlook(green)), ...  
\>     w=500,h=300);


    exec:
        return _exec(program,param,dir,print,hidden,wait);
    povray:
        exec(program,params,defaulthome);
    Try "trace errors" to inspect local variables after errors.
    pov3d:
        if povray then povray(currentfile,w,h,w/h); endif;

Dengan metode bayangan canggih dari Povray, sangat sedikit titik yang
dapat menghasilkan permukaan yang sangat halus. Hanya di perbatasan
dan dalam bayang-bayang triknya mungkin menjadi jelas.


Untuk ini, kita perlu menambahkan vektor normal di setiap titik
matriks.


\>Z &= x^2\*y^3


    
                                     2  3
                                    x  y
    

Persamaan permukaannya adalah [x,y,Z]. Kami menghitung dua turunan ke
x dan y ini dan mengambil produk silang sebagai normal.


\>dx &= diff([x,y,Z],x); dy &= diff([x,y,Z],y);


Kami mendefinisikan normal sebagai produk silang dari turunan ini, dan
mendefinisikan fungsi koordinat.


\>N &= crossproduct(dx,dy); NX &= N[1]; NY &= N[2]; NZ &= N[3]; N,


    
                                   3       2  2
                           [- 2 x y , - 3 x  y , 1]
    

Kami hanya menggunakan 25 poin.


\>x=-1:0.5:1; y=x';

\>pov3d(x,y,Z(x,y),angle=10, ...  
\>     xv=NX(x,y),yv=NY(x,y),zv=NZ(x,y),<shadow);


    exec:
        return _exec(program,param,dir,print,hidden,wait);
    povray:
        exec(program,params,defaulthome);
    Try "trace errors" to inspect local variables after errors.
    pov3d:
        if povray then povray(currentfile,w,h,w/h); endif;

Berikut ini adalah Simpul Trefoil yang dilakukan oleh A. Busser di
Povray. Ada versi yang ditingkatkan dari ini dalam contoh.


  <a href="Examples\Trefoil Knot.html">Simpul Trefoil</a>  

Untuk tampilan yang bagus dengan tidak terlalu banyak titik, kami
menambahkan vektor normal di sini. Kami menggunakan Maxima untuk
menghitung normal bagi kami. Pertama, ketiga fungsi koordinat sebagai
ekspresi simbolik.


\>X &= ((4+sin(3\*y))+cos(x))\*cos(2\*y); ...  
\>   Y &= ((4+sin(3\*y))+cos(x))\*sin(2\*y); ...  
\>   Z &= sin(x)+2\*cos(3\*y);


Kemudian kedua vektor turunan ke x dan y.


\>dx &= diff([X,Y,Z],x); dy &= diff([X,Y,Z],y);


Sekarang normal, yang merupakan produk silang dari dua turunan.


\>dn &= crossproduct(dx,dy);


Kami sekarang mengevaluasi semua ini secara numerik.


\>x:=linspace(-%pi,%pi,40); y:=linspace(-%pi,%pi,100)';


Vektor normal adalah evaluasi dari ekspresi simbolik dn[i] untuk
i=1,2,3. Sintaks untuk ini adalah &amp;"expression"(parameters). Ini
adalah alternatif dari metode pada contoh sebelumnya, di mana kita
mendefinisikan ekspresi simbolik NX, NY, NZ terlebih dahulu.


\>pov3d(X(x,y),Y(x,y),Z(x,y),axis=0,zoom=5,w=450,h=350, ...  
\>     <shadow,look=povlook(gray), ...  
\>     xv=&"dn[1]"(x,y), yv=&"dn[2]"(x,y), zv=&"dn[3]"(x,y));


    exec:
        return _exec(program,param,dir,print,hidden,wait);
    povray:
        exec(program,params,defaulthome);
    Try "trace errors" to inspect local variables after errors.
    pov3d:
        if povray then povray(currentfile,w,h,w/h); endif;

Kami juga dapat menghasilkan grid dalam 3D.


\>povstart(zoom=4); ...  
\>   x=-1:0.5:1; r=1-(x+1)^2/6; ...  
\>   t=(0:30:360)'; y=r\*cos(t); z=r\*sin(t); ...  
\>   writeln(povgrid(x,y,z,d=0.02,dballs=0.05)); ...  
\>   povend();


    exec:
        return _exec(program,param,dir,print,hidden,wait);
    povray:
        exec(program,params,defaulthome);
    Try "trace errors" to inspect local variables after errors.
    povend:
        povray(file,w,h,aspect,exit); 

Dengan povgrid(), kurva dimungkinkan.


\>povstart(center=[0,0,1],zoom=3.6); ...  
\>   t=linspace(0,2,1000); r=exp(-t); ...  
\>   x=cos(2\*pi\*10\*t)\*r; y=sin(2\*pi\*10\*t)\*r; z=t; ...  
\>   writeln(povgrid(x,y,z,povlook(red))); ...  
\>   writeAxis(0,2,axis=3); ...  
\>   povend();


    exec:
        return _exec(program,param,dir,print,hidden,wait);
    povray:
        exec(program,params,defaulthome);
    Try "trace errors" to inspect local variables after errors.
    povend:
        povray(file,w,h,aspect,exit); 

# Objek Povray

Di atas, kami menggunakan pov3d untuk memplot permukaan. Antarmuka
povray di Euler juga dapat menghasilkan objek Povray. Objek-objek ini
disimpan sebagai string di Euler, dan perlu ditulis ke file Povray.


Kami memulai output dengan povstart().


\>povstart(zoom=4);


Pertama kita mendefinisikan tiga silinder, dan menyimpannya dalam
string di Euler.


Fungsi povx() dll. hanya mengembalikan vektor [1,0,0], yang dapat
digunakan sebagai gantinya.


\>c1=povcylinder(-povx,povx,1,povlook(red)); ...  
\>   c2=povcylinder(-povy,povy,1,povlook(green)); ...  
\>   c3=povcylinder(-povz,povz,1,povlook(blue)); ...  
\>  
String berisi kode Povray, yang tidak perlu kita pahami pada saat itu.


\>c1


    cylinder { &lt;-1,0,0&gt;, &lt;1,0,0&gt;, 1
     texture { pigment { color rgb &lt;0.564706,0.0627451,0.0627451&gt; }  } 
     finish { ambient 0.2 } 
     }

Seperti yang Anda lihat, kami menambahkan tekstur ke objek dalam tiga
warna berbeda.


Itu dilakukan oleh povlook(), yang mengembalikan string dengan kode
Povray yang relevan. Kita dapat menggunakan warna Euler default, atau
menentukan warna kita sendiri. Kami juga dapat menambahkan
transparansi, atau mengubah cahaya sekitar.


\>povlook(rgb(0.1,0.2,0.3),0.1,0.5)


     texture { pigment { color rgbf &lt;0.101961,0.2,0.301961,0.1&gt; }  } 
     finish { ambient 0.5 } 
    

Sekarang kita mendefinisikan objek persimpangan, dan menulis hasilnya
ke file.


\>writeln(povintersection([c1,c2,c3]));


Persimpangan tiga silinder sulit untuk divisualisasikan, jika Anda
belum pernah melihatnya sebelumnya.


\>povend;


    exec:
        return _exec(program,param,dir,print,hidden,wait);
    povray:
        exec(program,params,defaulthome);
    Try "trace errors" to inspect local variables after errors.
    povend:
        povray(file,w,h,aspect,exit); 

Fungsi berikut menghasilkan fraktal secara rekursif.


Fungsi pertama menunjukkan, bagaimana Euler menangani objek Povray
sederhana. Fungsi povbox() mengembalikan string, yang berisi koordinat
kotak, tekstur, dan hasil akhir.


\>function onebox(x,y,z,d) := povbox([x,y,z],[x+d,y+d,z+d],povlook());

\>function fractal (x,y,z,h,n) ...  
\>  
<pre class="udf">     if n==1 then writeln(onebox(x,y,z,h));
     else
       h=h/3;
       fractal(x,y,z,h,n-1);
       fractal(x+2*h,y,z,h,n-1);
       fractal(x,y+2*h,z,h,n-1);
       fractal(x,y,z+2*h,h,n-1);
       fractal(x+2*h,y+2*h,z,h,n-1);
       fractal(x+2*h,y,z+2*h,h,n-1);
       fractal(x,y+2*h,z+2*h,h,n-1);
       fractal(x+2*h,y+2*h,z+2*h,h,n-1);
       fractal(x+h,y+h,z+h,h,n-1);
     endif;
    endfunction
</pre>
\>povstart(fade=10,<shadow);

\>fractal(-1,-1,-1,2,4);

\>povend();


    exec:
        return _exec(program,param,dir,print,hidden,wait);
    povray:
        exec(program,params,defaulthome);
    Try "trace errors" to inspect local variables after errors.
    povend:
        povray(file,w,h,aspect,exit); 

Perbedaan memungkinkan memotong satu objek dari yang lain. Seperti
persimpangan, ada bagian dari objek CSG Povray.


\>povstart(light=[5,-5,5],fade=10);


Untuk demonstrasi ini, kami mendefinisikan objek di Povray, alih-alih
menggunakan string di Euler. Definisi ditulis ke file segera.


Koordinat kotak -1 berarti [-1,-1,-1].


\>povdefine("mycube",povbox(-1,1));


Kita dapat menggunakan objek ini di povobject(), yang mengembalikan
string seperti biasa.


\>c1=povobject("mycube",povlook(red));


Kami menghasilkan kubus kedua, dan memutar dan menskalakannya sedikit.


\>c2=povobject("mycube",povlook(yellow),translate=[1,1,1], ...  
\>     rotate=xrotate(10)+yrotate(10), scale=1.2);


Kemudian kita ambil selisih kedua benda tersebut.


\>writeln(povdifference(c1,c2));


Sekarang tambahkan tiga sumbu.


\>writeAxis(-1.2,1.2,axis=1); ...  
\>   writeAxis(-1.2,1.2,axis=2); ...  
\>   writeAxis(-1.2,1.2,axis=4); ...  
\>   povend();


    exec:
        return _exec(program,param,dir,print,hidden,wait);
    povray:
        exec(program,params,defaulthome);
    Try "trace errors" to inspect local variables after errors.
    povend:
        povray(file,w,h,aspect,exit); 

# Fungsi Implisit

Povray dapat memplot himpunan di mana f(x,y,z)=0, seperti parameter
implisit di plot3d. Namun, hasilnya terlihat jauh lebih baik.


Sintaks untuk fungsinya sedikit berbeda. Anda tidak dapat menggunakan
output dari ekspresi Maxima atau Euler.


\>povstart(angle=70,height=50,zoom=4);


Buat permukaan implisit. Perhatikan sintaks yang berbeda dalam
ekspresi.


\>writeln(povsurface("pow(x,2)\*y-pow(y,3)-pow(z,2)",povlook(green))); ...  
\>   writeAxes(); ...  
\>   povend();


    exec:
        return _exec(program,param,dir,print,hidden,wait);
    povray:
        exec(program,params,defaulthome);
    Try "trace errors" to inspect local variables after errors.
    povend:
        povray(file,w,h,aspect,exit); 

# Objek Jala

Dalam contoh ini, kami menunjukkan cara membuat objek mesh, dan
menggambarnya dengan informasi tambahan.


Kami ingin memaksimalkan xy di bawah kondisi x+y=1 dan menunjukkan
sentuhan tangensial dari garis level.


\>povstart(angle=-10,center=[0.5,0.5,0.5],zoom=7);


Kami tidak dapat menyimpan objek dalam string seperti sebelumnya,
karena terlalu besar. Jadi kita mendefinisikan objek dalam file Povray
menggunakan #declare. Fungsi povtriangle() melakukan ini secara
otomatis. Itu dapat menerima vektor normal seperti pov3d().


Berikut ini mendefinisikan objek mesh, dan langsung menulisnya ke
dalam file.


\>x=0:0.02:1; y=x'; z=x\*y; vx=-y; vy=-x; vz=1;

\>mesh=povtriangles(x,y,z,"",vx,vy,vz);


Sekarang kita mendefinisikan dua cakram, yang akan berpotongan dengan
permukaan.


\>cl=povdisc([0.5,0.5,0],[1,1,0],2); ...  
\>   ll=povdisc([0,0,1/4],[0,0,1],2);


Tulis permukaan dikurangi dua cakram.


\>writeln(povdifference(mesh,povunion([cl,ll]),povlook(green)));


Tulis dua persimpangan.


\>writeln(povintersection([mesh,cl],povlook(red))); ...  
\>   writeln(povintersection([mesh,ll],povlook(gray)));


Tulis titik maksimum.


\>writeln(povpoint([1/2,1/2,1/4],povlook(gray),size=2\*defaultpointsize));


Tambahkan sumbu dan selesaikan.


\>writeAxes(0,1,0,1,0,1,d=0.015); ...  
\>   povend();


    exec:
        return _exec(program,param,dir,print,hidden,wait);
    povray:
        exec(program,params,defaulthome);
    Try "trace errors" to inspect local variables after errors.
    povend:
        povray(file,w,h,aspect,exit); 

# Anaglyph di Povray

Untuk menghasilkan anaglyph untuk kacamata merah/sian, Povray harus
berjalan dua kali dari posisi kamera yang berbeda. Ini menghasilkan
dua file Povray dan dua file PNG, yang dimuat dengan fungsi
loadanaglyph().


Tentu saja, Anda memerlukan kacamata merah/sian untuk melihat contoh
berikut dengan benar.


Fungsi pov3d() memiliki sakelar sederhana untuk menghasilkan
anaglyphs.


\>pov3d("-exp(-x^2-y^2)/2",r=2,height=45,\>anaglyph, ...  
\>     center=[0,0,0.5],zoom=3.5);


    exec:
        return _exec(program,param,dir,print,hidden,wait);
    povray:
        exec(program,params,defaulthome);
    Try "trace errors" to inspect local variables after errors.
    pov3d:
        if povray then povray(currentfile,w,h,w/h); endif;

Jika Anda membuat adegan dengan objek, Anda perlu menempatkan generasi
adegan ke dalam fungsi, dan menjalankannya dua kali dengan nilai yang
berbeda untuk parameter anaglyph.


\>function myscene ...


      s=povsphere(povc,1);
      cl=povcylinder(-povz,povz,0.5);
      clx=povobject(cl,rotate=xrotate(90));
      cly=povobject(cl,rotate=yrotate(90));
      c=povbox([-1,-1,0],1);
      un=povunion([cl,clx,cly,c]);
      obj=povdifference(s,un,povlook(red));
      writeln(obj);
      writeAxes();
    endfunction
</pre>
Fungsi povanaglyph() melakukan semua ini. Parameternya seperti di
povstart() dan povend() digabungkan.


\>povanaglyph("myscene",zoom=4.5);


    exec:
        return _exec(program,param,dir,print,hidden,wait);
    povray:
        exec(program,params,defaulthome);
    Try "trace errors" to inspect local variables after errors.
    povanaglyph:
        povray(currentfile,w,h,aspect,exit); 

# Mendefinisikan Objek sendiri

Antarmuka povray Euler berisi banyak objek. Tapi Anda tidak terbatas
pada ini. Anda dapat membuat objek sendiri, yang menggabungkan objek
lain, atau objek yang sama sekali baru.


Kami mendemonstrasikan sebuah torus. Perintah Povray untuk ini adalah
"torus". Jadi kami mengembalikan string dengan perintah ini dan
parameternya. Perhatikan bahwa torus selalu berpusat di titik asal.


\>function povdonat (r1,r2,look="") ...


      return "torus {"+r1+","+r2+look+"}";
    endfunction
</pre>
Inilah torus pertama kami.


\>t1=povdonat(0.8,0.2)


    torus {0.8,0.2}

Mari kita gunakan objek ini untuk membuat torus kedua, diterjemahkan
dan diputar.


\>t2=povobject(t1,rotate=xrotate(90),translate=[0.8,0,0])


    object { torus {0.8,0.2}
     rotate 90 *x 
     translate &lt;0.8,0,0&gt;
     }

Sekarang kita menempatkan objek-objek ini ke dalam sebuah adegan.
Untuk tampilan, kami menggunakan Phong Shading.


\>povstart(center=[0.4,0,0],angle=0,zoom=3.8,aspect=1.5); ...  
\>   writeln(povobject(t1,povlook(green,phong=1))); ...  
\>   writeln(povobject(t2,povlook(green,phong=1))); ...  
\>  
&gt;povend();


memanggil program Povray. Namun, jika terjadi kesalahan, itu tidak
menampilkan kesalahan. Karena itu Anda harus menggunakan


  &gt;povend(&lt;exit);  

jika ada yang tidak berhasil. Ini akan membiarkan jendela Povray
terbuka.


\>povend(h=320,w=480);


    exec:
        return _exec(program,param,dir,print,hidden,wait);
    povray:
        exec(program,params,defaulthome);
    Try "trace errors" to inspect local variables after errors.
    povend:
        povray(file,w,h,aspect,exit); 

Berikut adalah contoh yang lebih rumit. Kami memecahkan


$$Ax \le b, \quad x \ge 0, \quad c.x \to max$$dan menunjukkan titik layak dan optimal dalam plot 3D.


\>A=[10,8,4;5,6,8;6,3,2;9,5,6];

\>b=[10,10,10,10]';

\>c=[1,1,1];


Pertama, mari kita periksa, apakah contoh ini memiliki solusi sama
sekali.


\>x=simplex(A,b,c,\>max,\>check)'


    [0,  1,  0.5]

Ya, sudah.


Selanjutnya kita mendefinisikan dua objek. Yang pertama adalah pesawat


$$a \cdot x \le b$$\>function oneplane (a,b,look="") ...


      return povplane(a,b,look)
    endfunction
</pre>
Kemudian kita mendefinisikan persimpangan dari semua setengah ruang
dan sebuah kubus.


\>function adm (A, b, r, look="") ...


      ol=[];
      loop 1 to rows(A); ol=ol|oneplane(A[#],b[#]); end;
      ol=ol|povbox([0,0,0],[r,r,r]);
      return povintersection(ol,look);
    endfunction
</pre>
Kita sekarang dapat menggambar bentuknya.


\>povstart(angle=120,center=[0.5,0.5,0.5],zoom=3.5); ...  
\>   writeln(adm(A,b,2,povlook(green,0.4))); ...  
\>   writeAxes(0,1.3,0,1.6,0,1.5); ...  
\>  
Berikut ini adalah lingkaran di sekitar optimal.


\>writeln(povintersection([povsphere(x,0.5),povplane(c,c.x')], ...  
\>     povlook(red,0.9)));


Dan kesalahan ke arah yang optimal.


\>writeln(povarrow(x,c\*0.5,povlook(red)));


Kami menambahkan teks ke layar. Teks hanyalah objek 3D. Kita perlu
menempatkan dan memutarnya menurut pandangan kita.


\>writeln(povtext("Linear Problem",[0,0.2,1.3],size=0.05,rotate=125)); ...  
\>   povend();


    exec:
        return _exec(program,param,dir,print,hidden,wait);
    povray:
        exec(program,params,defaulthome);
    Try "trace errors" to inspect local variables after errors.
    povend:
        povray(file,w,h,aspect,exit); 

# Lebih Banyak Contoh

Anda dapat menemukan beberapa contoh lagi untuk Povray di Euler di
file berikut.


  <a href="Examples/Dandelin Spheres.html">Examples/Dandelin Spheres</a>  

  <a href="Examples/Donat Math.html">Examples/Donat Math</a>  

  <a href="Examples/Trefoil Knot.html">Examples/Trefoil Knot</a>  

  <a href="Examples/Optimization by Affine Scaling.html">Examples/Optimization by Affine Scaling</a>  

\>load povray;

\>defaultpovray="C:\\Program Files\\POV-Ray\\v3.7\\bin\\pvengine.exe"


    C:\Program Files\POV-Ray\v3.7\bin\pvengine.exe

## Menggambar bola

\>function povbola (r1,r2) ...


    
    return "sphere {"+r1+","+r2+"}";
    endfunction
</pre>
\>t1=povbola(0.2,0.5); ...  
\>   povstart(center=[0,1,0],angle=0,zoom=4,aspect=2.5); ...  
\>   writeln(povobject(t1,povlook(red,phong=1))); ...  
\>   povend(h=80,w=200);


    exec:
        return _exec(program,param,dir,print,hidden,wait);
    povray:
        exec(program,params,defaulthome);
    Try "trace errors" to inspect local variables after errors.
    povend:
        povray(file,w,h,aspect,exit); 

## Menggambar Tabung

\>function povtabung() ...


    return "cylinder {<-1,0,0>, <0,4,0>, 2 open}";
    endfunction
</pre>
\>t2=povtabung(); ...  
\>   povstart(center=[0,4,0],angle=20,zoom=1.2,aspect=2); ...  
\>   writeln(povobject(t2,povlook(green,phong=2))); ...  
\>   povend(h=200,w=400);


    exec:
        return _exec(program,param,dir,print,hidden,wait);
    povray:
        exec(program,params,defaulthome);
    Try "trace errors" to inspect local variables after errors.
    povend:
        povray(file,w,h,aspect,exit); 

\>plot3d("x^2+y^2-1",r=2,\>implicit):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-063.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-063.png)

## Menggambar Bangun Paraboloid

\>plot3d("x^2/9+y^2/2-z",r=10,\>implicit):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-064.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-064.png)

\>plot3d("-x^2/9+y^2/2-z",r=10,\>implicit):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-065.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-065.png)

\>plot3d("x^2/9-y^2/2-z",r=10,\>implicit):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-066.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-066.png)

## Menggambar Bangun Elipsoid

\>plot3d("x^2/9+y^2/2+z^2/9-1",r=4,\>implicit):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-067.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-067.png)

## Menggambar Bangun Hyperboloid

\>plot3d("x^2/9+y^2/2-z^2/4-1",r=4,\>implicit):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-068.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-068.png)

\>plot3d("x^2/9+y^2/2-z^2/4+1",r=4,\>implicit):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-069.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-069.png)

\>plot3d("x^2/9+y^2/2-z^2/4",r=4,\>implicit):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-070.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-070.png)

## Menggambar Kerucut

\>plot3d("x^2+y^2-z^2",r=4,\>implicit):


![images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-071.png](images/23030630096_Nur%20Alya%20Fadilah_3D%20(1)-071.png)

\section{EEMT UNTUK KALKULUS}
# 23030630096_Nur Alya Fadilah_Kalkulus
Nama  : Nur Alya Fadilah


NIM   : 23030630096


Kelas : Matematika E 2023


# Kalkulus dengan EMT

Materi Kalkulus mencakup di antaranya:


* 
Fungsi (fungsi aljabar, trigonometri, eksponensial, logaritma,
* komposisi fungsi)

* 
Limit Fungsi,

* 
Turunan Fungsi,

* 
Integral Tak Tentu,

* 
Integral Tentu dan Aplikasinya,

* 
Barisan dan Deret (kekonvergenan barisan dan deret).


EMT (bersama Maxima) dapat digunakan untuk melakukan semua perhitungan
di dalam kalkulus, baik secara numerik maupun analitik (eksak).


## Mendefinisikan Fungsi

Terdapat beberapa cara mendefinisikan fungsi pada EMT, yakni:


* 
Menggunakan format nama_fungsi := rumus fungsi (untuk fungsi
* numerik),

* 
Menggunakan format nama_fungsi &amp;= rumus fungsi (untuk fungsi
* simbolik, namun dapat dihitung secara numerik),

* 
Menggunakan format nama_fungsi &amp;&amp;= rumus fungsi (untuk fungsi
* simbolik murni, tidak dapat dihitung langsung),

* 
Fungsi sebagai program EMT.


Setiap format harus diawali dengan perintah function (bukan sebagai
ekspresi).


Berikut adalah adalah beberapa contoh cara mendefinisikan fungsi.


\>function f(x) := 2\*x^2+exp(sin(x)) // fungsi numerik

\>f(0), f(1), f(pi)


    1
    4.31977682472
    20.7392088022

\>function g(x) := sqrt(x^2-3\*x)/(x+1)

\>g(3)


    0

\>g(0)


    0

\>g(4)


    0.4

\>f(g(5)) // komposisi fungsi


    2.20920171961

\>g(f(5))


    0.950898070639

\>f(0:10) // nilai-nilai f(1), f(2), ..., f(10)


    [1,  4.31978,  10.4826,  19.1516,  32.4692,  50.3833,  72.7562,
    99.929,  130.69,  163.51,  200.58]

\>fmap(0:10) // sama dengan f(0:10), berlaku untuk semua fungsi


    [1,  4.31978,  10.4826,  19.1516,  32.4692,  50.3833,  72.7562,
    99.929,  130.69,  163.51,  200.58]

Misalkan kita akan mendefinisikan fungsi


$$f(x) = \begin{cases} x^3 & x>0 \\ x^2 & x\le 0. \end{cases}$$Fungsi tersebut tidak dapat didefinisikan sebagai fungsi numerik
secara "inline" menggunakan format :=, melainkan didefinisikan sebagai
program. Perhatikan, kata "map" digunakan agar fungsi dapat menerima
vektor sebagai input, dan hasilnya berupa vektor. Jika tanpa kata
"map" fungsinya hanya dapat menerima input satu nilai.


\>function map f(x) ...


      if x>0 then return x^3
      else return x^2
      endif;
    endfunction
</pre>
\>f(1)


    1

\>f(-2)


    4

\>f(-5:5)


    [25,  16,  9,  4,  1,  0,  1,  8,  27,  64,  125]

\>aspect(1.5); plot2d("f(x)",-5,5):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-002.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-002.png)

\>function f(x) &= 2\*E^x // fungsi simbolik


    
                                        x
                                     2 E
    

\>function g(x) &= 3\*x+1


    
                                   3 x + 1
    

\>function h(x) &= f(g(x)) // komposisi fungsi


    
                                     3 x + 1
                                  2 E
    

# Latihan

Bukalah buku Kalkulus. Cari dan pilih beberapa (paling sedikit 5 fungsi berbeda
tipe/bentuk/jenis) fungsi dari buku tersebut, kemudian definisikan di EMT pada
baris-baris perintah berikut (jika perlu tambahkan lagi). Untuk setiap fungsi, hitung
beberapa nilainya, baik untuk satu nilai maupun vektor. Gambar grafik tersebut.


Juga, carilah fungsi beberapa (dua) variabel. Lakukan hal sama seperti di atas.


\>function f(x) := 2\*x+5

\>f(3)


    11

\>aspect(1.5); plot2d("f(x)",-5,5):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-003.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-003.png)

\>function g(x) := sin(pi\*x)

\>f(0.5)


    6

\>aspect(1.5); plot2d("g(x)",-5,5):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-004.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-004.png)

\>function j(x) := 2^x

\> j(2)


    4

\>aspect(1.5); plot2d("j(x)",-5,5):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-005.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-005.png)

\>function k(x) := (1-x^2)^2

\> k(0)


    1

\>aspect(1.5); plot2d("k(x)",-5,5):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-006.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-006.png)

\>function m(x) := x^2/(1+x^2)

\> m(8)


    0.984615384615

\>aspect(1.5); plot2d("m(x)",-5,5):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-007.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-007.png)

\> function n(x) := 1/(1+x^2)

\> n(3)


    0.1

\>aspect(1.5); plot2d("n(x)",-5,5):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-008.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-008.png)

\> function p(x) := x/(1-x)

\> p(-9)


    -0.9

\>aspect(1.5); plot2d("p(x)",-5,5):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-009.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-009.png)

\>function h(x) := f(g(j(k(m(n(p(x)))))))

\> h(0)


    3.00529790846

\>aspect(1.5); plot2d("h(x)",-5,5):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-010.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-010.png)

# Menghitung Limit

Perhitungan limit pada EMT dapat dilakukan dengan menggunakan fungsi Maxima, yakni "limit".
Fungsi "limit" dapat digunakan untuk menghitung limit fungsi dalam bentuk ekspresi maupun
fungsi yang sudah didefinisikan sebelumnya. Nilai limit dapat dihitung pada sebarang nilai
atau pada tak hingga (-inf, minf, dan inf). Limit kiri dan limit kanan juga dapat dihitung,
dengan cara memberi opsi "plus" atau "minus". Hasil limit dapat berupa nilai, "und' (tak
definisi), "ind" (tak tentu namun terbatas), "infinity" (kompleks tak hingga).


Perhatikan beberapa contoh berikut. Perhatikan cara menampilkan perhitungan secara lengkap,
tidak hanya menampilkan hasilnya saja.


\>$showev('limit(1/(2\*x-1),x,0))


$$\lim_{x\rightarrow 0}{\frac{1}{2\,x-1}}=-1$$\>$showev('limit((x^2-3\*x-10)/(x-5),x,5))


$$\lim_{x\rightarrow 5}{\frac{x^2-3\,x-10}{x-5}}=7$$\>$showev('limit(sin(x)/x,x,0))


$$\lim_{x\rightarrow 0}{\frac{\sin x}{x}}=1$$\>plot2d("sin(x)/x",-pi,pi):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-014.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-014.png)

\>$showev('limit(sin(x^3)/x,x,0))


$$\lim_{x\rightarrow 0}{\frac{\sin x^3}{x}}=0$$\>$showev('limit(log(x), x, minf))


$$\lim_{x\rightarrow  -\infty }{\log x}={\it infinity}$$\>$showev('limit((-2)^x,x, inf))


$$\lim_{x\rightarrow \infty }{\left(-2\right)^{x}}={\it infinity}$$\>$showev('limit(t-sqrt(2-t),t,2,minus))


$$\lim_{t\uparrow 2}{t-\sqrt{2-t}}=2$$\>$showev('limit(t-sqrt(2-t),t,5,plus)) // Perhatikan hasilnya


$$\lim_{t\downarrow 5}{t-\sqrt{2-t}}=5-\sqrt{3}\,i$$\>plot2d("x-sqrt(2-x)",-2,5):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-020.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-020.png)

\>$showev('limit((x^2-9)/(2\*x^2-5\*x-3),x,3))


$$\lim_{x\rightarrow 3}{\frac{x^2-9}{2\,x^2-5\,x-3}}=\frac{6}{7}$$\>$showev('limit((1-cos(x))/x,x,0))


$$\lim_{x\rightarrow 0}{\frac{1-\cos x}{x}}=0$$\>$showev('limit((x^2+abs(x))/(x^2-abs(x)),x,0))


$$\lim_{x\rightarrow 0}{\frac{\left| x\right| +x^2}{x^2-\left| x
 \right| }}=-1$$\>$showev('limit((1+1/x)^x,x,inf))


$$\lim_{x\rightarrow \infty }{\left(\frac{1}{x}+1\right)^{x}}=e$$\>$showev('limit((1+k/x)^x,x,inf))


$$\lim_{x\rightarrow \infty }{\left(\frac{k}{x}+1\right)^{x}}=e^{k}$$\>$showev('limit((1+x)^(1/x),x,0))


$$\lim_{x\rightarrow 0}{\left(x+1\right)^{\frac{1}{x}}}=e$$\>$showev('limit((x/(x+k))^x,x,inf))


$$\lim_{x\rightarrow \infty }{\left(\frac{x}{x+k}\right)^{x}}=e^ {- k
  }$$\>$showev('limit(sin(1/x),x,0))


$$\lim_{x\rightarrow 0}{\sin \left(\frac{1}{x}\right)}={\it ind}$$\>$showev('limit(sin(1/x),x,inf))


$$\lim_{x\rightarrow \infty }{\sin \left(\frac{1}{x}\right)}=0$$\>plot2d("sin(1/x)",-5,5):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-030.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-030.png)

# Latihan

Bukalah buku Kalkulus. Cari dan pilih beberapa (paling sedikit 5 fungsi berbeda
tipe/bentuk/jenis) fungsi dari buku tersebut, kemudian definisikan di EMT pada
baris-baris perintah berikut (jika perlu tambahkan lagi). Untuk setiap fungsi, hitung
nilai limit fungsi tersebut di beberapa nilai dan di tak hingga. Gambar grafik fungsi
tersebut untuk mengkonfirmasi nilai-nilai limit tersebut.


\>$showev('limit((x^3-2\*x^2-5\*x-5),x,-1))


$$\lim_{x\rightarrow -1}{x^3-2\,x^2-5\,x-5}=-3$$\>$showev('limit((x^3-2\*x^2-5\*x-5),x,inf))


$$\lim_{x\rightarrow \infty }{x^3-2\,x^2-5\,x-5}=\infty $$\>plot2d("(x^3-2\*x^2-5\*x-5)",-5,5):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-033.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-033.png)

\>$showev('limit((x^2-x-1)/(x+8),x,2))


$$\lim_{x\rightarrow 2}{\frac{x^2-x-1}{x+8}}=\frac{1}{10}$$\>$showev('limit((x^2-x-1)/(x+8),x,inf))


$$\lim_{x\rightarrow \infty }{\frac{x^2-x-1}{x+8}}=\infty $$\>plot2d("(x^2-x-1)/(x+8)",-5,5):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-036.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-036.png)

\>$showev('limit((x^2-3\*x+2)/(x+1),x,0))


$$\lim_{x\rightarrow 0}{\frac{x^2-3\,x+2}{x+1}}=2$$\>$showev('limit((x^2-3\*x+2)/(x+1),x,inf))


$$\lim_{x\rightarrow \infty }{\frac{x^2-3\,x+2}{x+1}}=\infty $$\>plot2d("(x^2-3\*x+2)/(x+1)",-5,5):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-039.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-039.png)

\>$showev('limit((sin(x)+cos(x)),x,0))


$$\lim_{x\rightarrow 0}{\sin x+\cos x}=1$$\>$showev('limit(sin(x)+cos(x),x,inf))


$$\lim_{x\rightarrow \infty }{\sin x+\cos x}={\it ind}$$\>plot2d("sin(x)+cos(x)",-5,5):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-042.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-042.png)

\>$showev('limit((x+1/x)/(x^2-1/(2\*x)),x,0))


$$\lim_{x\rightarrow 0}{\frac{x+\frac{1}{x}}{x^2-\frac{1}{2\,x}}}=-2$$\>$showev('limit((x+1/x)/(x^2-1/(2\*x)),x,inf))


$$\lim_{x\rightarrow \infty }{\frac{x+\frac{1}{x}}{x^2-\frac{1}{2\,x}
 }}=0$$\>plot2d("(x+1/x)/(x^2-1/(2\*x))",-5,5):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-045.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-045.png)

# Turunan Fungsi

Definisi turunan:


$$f'(x) = \lim_{h\to 0} \frac{f(x+h)-f(x)}{h}$$Berikut adalah contoh-contoh menentukan turunan fungsi dengan
menggunakan definisi turunan (limit).


\>$showev('limit(((x+h)^n-x^n)/h,h,0)) // turunan x^n


$$\lim_{h\rightarrow 0}{\frac{\left(x+h\right)^{n}-x^{n}}{h}}=n\,x^{n
 -1}$$Mengapa hasilnya seperti itu? Tuliskan atau tunjukkan bahwa hasil limit tersebut
benar, sehingga benar turunan fungsinya benar.  Tulis penjelasan Anda di komentar
ini.


Sebagai petunjuk, ekspansikan (x+h)^n dengan menggunakan teorema binomial.


\>$showev('limit((sin(x+h)-sin(x))/h,h,0)) // turunan sin(x)


$$\lim_{h\rightarrow 0}{\frac{\sin \left(x+h\right)-\sin x}{h}}=\cos 
 x$$Mengapa hasilnya seperti itu? Tuliskan atau tunjukkan bahwa hasil limit tersebut


benar, sehingga benar turunan fungsinya benar.  Tulis penjelasan Anda di komentar
ini.


Sebagai petunjuk, ekspansikan sin(x+h) dengan menggunakan rumus jumlah dua sudut.


\>$showev('limit((log(x+h)-log(x))/h,h,0)) // turunan log(x)


$$\lim_{h\rightarrow 0}{\frac{\log \left(x+h\right)-\log x}{h}}=
 \frac{1}{x}$$Mengapa hasilnya seperti itu? Tuliskan atau tunjukkan bahwa hasil limit tersebut


benar, sehingga benar turunan fungsinya benar.  Tulis penjelasan Anda di komentar
ini.


Sebagai petunjuk, gunakan sifat-sifat logaritma dan hasil limit pada bagian
sebelumnya di atas.


\>$showev('limit((1/(x+h)-1/x)/h,h,0)) // turunan 1/x


$$\lim_{h\rightarrow 0}{\frac{\frac{1}{x+h}-\frac{1}{x}}{h}}=-\frac{1
 }{x^2}$$\>$showev('limit((E^(x+h)-E^x)/h,h,0)) // turunan f(x)=e^x


    Answering "Is x an integer?" with "integer"
    Answering "Is x an integer?" with "integer"
    Answering "Is x an integer?" with "integer"
    Answering "Is x an integer?" with "integer"
    Answering "Is x an integer?" with "integer"
    Maxima is asking
    Acceptable answers are: yes, y, Y, no, n, N, unknown, uk
    Is x an integer?
    
    Use assume!
    Error in:
    $showev('limit((E^(x+h)-E^x)/h,h,0)) // turunan f(x)=e^x ...
                                         ^

Maxima bermasalah dengan limit:


$$\lim_{h\to 0}\frac{e^{x+h}-e^x}{h}.$$Oleh karena itu diperlukan trik khusus agar hasilnya benar.


\>$showev('limit((E^h-1)/h,h,0))


$$\lim_{h\rightarrow 0}{\frac{e^{h}-1}{h}}=1$$\>$factor(E^(x+h)-E^x)


$$\left(e^{h}-1\right)\,e^{x}$$\>$showev('limit(factor((E^(x+h)-E^x)/h),h,0)) // turunan f(x)=e^x


$$\left(\lim_{h\rightarrow 0}{\frac{e^{h}-1}{h}}\right)\,e^{x}=e^{x}$$\>function f(x) &= x^x


    
                                       x
                                      x
    

\>$showev('limit((f(x+h)-f(x))/h,h,0)) // turunan f(x)=x^x


$$\lim_{h\rightarrow 0}{\frac{\left(x+h\right)^{x+h}-x^{x}}{h}}=
 {\it infinity}$$Di sini Maxima juga bermasalah terkait limit:


$$\lim_{h\to 0} \frac{(x+h)^{x+h}-x^x}{h}.$$Dalam hal ini diperlukan asumsi nilai x.


\>&assume(x\>0); $showev('limit((f(x+h)-f(x))/h,h,0)) // turunan f(x)=x^x


$$\lim_{h\rightarrow 0}{\frac{\left(x+h\right)^{x+h}-x^{x}}{h}}=x^{x}
 \,\left(\log x+1\right)$$\>&forget(x\>0) // jangan lupa, lupakan asumsi untuk kembali ke semula


    
                                   [x &gt; 0]
    

\>&forget(x<0)


    
                                   [x &lt; 0]
    

\>&facts()


    
                                      []
    

\>$showev('limit((asin(x+h)-asin(x))/h,h,0)) // turunan arcsin(x)


$$\lim_{h\rightarrow 0}{\frac{\arcsin \left(x+h\right)-\arcsin x}{h}}=
 \frac{1}{\sqrt{1-x^2}}$$\>$showev('limit((tan(x+h)-tan(x))/h,h,0)) // turunan tan(x)


$$\lim_{h\rightarrow 0}{\frac{\tan \left(x+h\right)-\tan x}{h}}=
 \frac{1}{\cos ^2x}$$\>function f(x) &= sinh(x) // definisikan f(x)=sinh(x)


    
                                   sinh(x)
    

\>function df(x) &= limit((f(x+h)-f(x))/h,h,0); $df(x) // df(x) = f'(x)


$$\frac{e^ {- x }\,\left(e^{2\,x}+1\right)}{2}$$Hasilnya adalah cosh(x), karena


$$\frac{e^x+e^{-x}}{2}=\cosh(x).$$\>plot2d(["f(x)","df(x)"],-pi,pi,color=[blue,red]):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-062.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-062.png)

# Latihan

Bukalah buku Kalkulus. Cari dan pilih beberapa (paling sedikit 5 fungsi berbeda
tipe/bentuk/jenis) fungsi dari buku tersebut, kemudian definisikan di EMT pada
baris-baris perintah berikut (jika perlu tambahkan lagi). Untuk setiap fungsi,
tentukan turunannya dengan menggunakan definisi turunan (limit), seperti
contoh-contoh tersebut. Gambar grafik fungsi asli dan fungsi turunannya pada sumbu
koordinat yang sama.


\>function f(x) &= 2\*x+5


    
                                   2 x + 5
    

\>function df(x) &= limit((f(x+h)-f(x))/h,h,0); $df(x) // df(x) = f'(x)


$$2$$\>plot2d(["f(x)","df(x)"],-pi,pi,color=[blue,red]):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-064.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-064.png)

\>function g(x) &= sin(pi\*x)


    
                                  sin(pi x)
    

\>function dg(x) &= limit((g(x+h)-g(x))/h,h,0); $dg(x) // dg(x) = g'(x)


$$\pi\,\cos \left(\pi\,x\right)$$\>plot2d(["g(x)","dg(x)"],-pi,pi,color=[blue,red]):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-066.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-066.png)

\>function j(x) &= x^2


    
                                       2
                                      x
    

\>function dj(x) &= limit((j(x+h)-j(x))/h,h,0); $dj(x) // dj(x) = j'(x)


$$2\,x$$\>plot2d(["j(x)","dj(x)"],-pi,pi,color=[blue,red]):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-068.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-068.png)

\>function k(x) &= (1-x^2)^2


    
                                        2 2
                                  (1 - x )
    

\>function dk(x) &= limit((k(x+h)-k(x))/h,h,0); $dk(x) // dk(x) = k'(x)


$$4\,x^3-4\,x$$\>plot2d(["k(x)","dk(x)"],-pi,pi,color=[blue,red]):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-070.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-070.png)

\>function m(x) &= x^2/(1+x^2)


    
                                       2
                                      x
                                    ------
                                     2
                                    x  + 1
    

\>function dm(x) &= limit((m(x+h)-m(x))/h,h,0); $dm(x) // dm(x) = m'(x)


$$\frac{2\,x}{x^4+2\,x^2+1}$$\>plot2d(["m(x)","dm(x)"],-pi,pi,color=[blue,red]):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-072.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-072.png)

\>function n(x) &= 1/(1+x^2)


    
                                      1
                                    ------
                                     2
                                    x  + 1
    

\>function dn(x) &= limit((n(x+h)-n(x))/h,h,0); $dn(x) // dn(x) = n'(x)


$$-\frac{2\,x}{x^4+2\,x^2+1}$$\>plot2d(["n(x)","dn(x)"],-pi,pi,color=[blue,red]):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-074.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-074.png)

\>function p(x) &= x/(1-x)


    
                                      x
                                    -----
                                    1 - x
    

\>function dp(x) &= limit((p(x+h)-p(x))/h,h,0); $dp(x) // dp(x) = p'(x)


$$\frac{1}{x^2-2\,x+1}$$\>plot2d(["p(x)","dp(x)"],-pi,pi,color=[blue,red]):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-076.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-076.png)

\>function b(x) &= f(g(j(k(m(n(p(x)))))))


    
                                            1                    4
            2 sin(pi (1 - --------------------------------------) ) + 5
                               2
                              x         4         1            2
                          (-------- + 1)  (--------------- + 1)
                                  2             2
                           (1 - x)             x         2
                                           (-------- + 1)
                                                   2
                                            (1 - x)
    

\>function db(x) &= limit((b(x+h)-b(x))/h,h,0); $db(x) // db(x) = b'(x)


$$0$$\>plot2d(["b(x)","db(x)"],-pi,pi,color=[blue,red]):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-078.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-078.png)

# Integral

EMT dapat digunakan untuk menghitung integral, baik integral tak tentu
maupun integral tentu. Untuk integral tak tentu (simbolik) sudah tentu
EMT menggunakan Maxima, sedangkan untuk perhitungan integral tentu EMT
sudah menyediakan beberapa fungsi yang mengimplementasikan algoritma
kuadratur (perhitungan integral tentu menggunakan metode numerik).


Pada notebook ini akan ditunjukkan perhitungan integral tentu dengan
menggunakan Teorema Dasar Kalkulus:


$$\int_a^b f(x)\ dx = F(b)-F(a), \quad \text{ dengan  } F'(x) = f(x).$$Fungsi untuk menentukan integral adalah integrate. Fungsi ini dapat
digunakan untuk menentukan, baik integral tentu maupun tak tentu (jika
fungsinya memiliki antiderivatif). Untuk perhitungan integral tentu
fungsi integrate menggunakan metode numerik (kecuali fungsinya tidak
integrabel, kita tidak akan menggunakan metode ini).


\>$showev('integrate(x^n,x))


    Answering "Is n equal to -1?" with "no"

$$\int {x^{n}}{\;dx}=\frac{x^{n+1}}{n+1}$$\>$showev('integrate(1/(1+x),x))


$$\int {\frac{1}{x+1}}{\;dx}=\log \left(x+1\right)$$\>$showev('integrate(1/(1+x^2),x))


$$\int {\frac{1}{x^2+1}}{\;dx}=\arctan x$$\>$showev('integrate(1/sqrt(1-x^2),x))


$$\int {\frac{1}{\sqrt{1-x^2}}}{\;dx}=\arcsin x$$\>$showev('integrate(sin(x),x,0,pi))


$$\int_{0}^{\pi}{\sin x\;dx}=2$$\>$showev('integrate(sin(x),x,a,b))


$$\int_{a}^{b}{\sin x\;dx}=\cos a-\cos b$$\>$showev('integrate(x^n,x,a,b))


    Answering "Is n positive, negative or zero?" with "positive"

$$\int_{a}^{b}{x^{n}\;dx}=\frac{b^{n+1}}{n+1}-\frac{a^{n+1}}{n+1}$$\>$showev('integrate(x^2\*sqrt(2\*x+1),x))


$$\int {x^2\,\sqrt{2\,x+1}}{\;dx}=\frac{\left(2\,x+1\right)^{\frac{7
 }{2}}}{28}-\frac{\left(2\,x+1\right)^{\frac{5}{2}}}{10}+\frac{\left(
 2\,x+1\right)^{\frac{3}{2}}}{12}$$\>$showev('integrate(x^2\*sqrt(2\*x+1),x,0,2))


$$\int_{0}^{2}{x^2\,\sqrt{2\,x+1}\;dx}=\frac{2\,5^{\frac{5}{2}}}{21}-
 \frac{2}{105}$$\>$ratsimp(%)


$$\int_{0}^{2}{x^2\,\sqrt{2\,x+1}\;dx}=\frac{2\,5^{\frac{7}{2}}-2}{
 105}$$\>$showev('integrate((sin(sqrt(x)+a)\*E^sqrt(x))/sqrt(x),x,0,pi^2))


$$\int_{0}^{\pi^2}{\frac{\sin \left(\sqrt{x}+a\right)\,e^{\sqrt{x}}}{
 \sqrt{x}}\;dx}=\left(-e^{\pi}-1\right)\,\sin a+\left(e^{\pi}+1
 \right)\,\cos a$$\>$factor(%)


$$\int_{0}^{\pi^2}{\frac{\sin \left(\sqrt{x}+a\right)\,e^{\sqrt{x}}}{
 \sqrt{x}}\;dx}=\left(-e^{\pi}-1\right)\,\left(\sin a-\cos a\right)$$\>function map f(x) &= E^(-x^2)


    
                                        2
                                     - x
                                    E
    

\>$showev('integrate(f(x),x))


$$\int {e^ {- x^2 }}{\;dx}=\frac{\sqrt{\pi}\,\mathrm{erf}\left(x
 \right)}{2}$$Fungsi f tidak memiliki antiturunan, integralnya masih memuat integral
lain.


$$erf(x) = \int \frac{e^{-x^2}}{\sqrt{\pi}} \ dx.$$Kita tidak dapat menggunakan teorema Dasar kalkulus untuk menghitung
integral tentu fungsi tersebut jika semua batasnya berhingga. Dalam
hal ini dapat digunakan metode numerik (rumus kuadratur).


Misalkan kita akan menghitung:


$$7\,\int_{0}^{\pi}{\frac{1}{x^6}\;dx}$$\>x=0:0.1:pi-0.1; plot2d(x,f(x+0.1),\>bar); plot2d("f(x)",0,pi,\>add):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-095.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-095.png)

Integral tentu


maxima: 'integrate(f(x),x,0,pi)


dapat dihampiri dengan jumlah luas persegi-persegi panjang di bawah kurva y=f(x)
tersebut. Langkah-langkahnya adalah sebagai berikut.


\>t &= makelist(a,a,0,pi-0.1,0.1); // t sebagai list untuk menyimpan nilai-nilai x

\>fx &= makelist(f(t[i]+0.1),i,1,length(t)); // simpan nilai-nilai f(x)

\>// jangan menggunakan x sebagai list, kecuali Anda pakar Maxima!


Hasilnya adalah:


maxima: 'integrate(f(x),x,0,pi) = 0.1*sum(fx[i],i,1,length(fx))


Jumlah tersebut diperoleh dari hasil kali lebar sub-subinterval (=0.1) dan jumlah
nilai-nilai f(x) untuk x = 0.1, 0.2, 0.3, ..., 3.2.


\>0.1\*sum(f(x+0.1)) // cek langsung dengan perhitungan numerik EMT


    0.836219610253

Untuk mendapatkan nilai integral tentu yang mendekati nilai sebenarnya, lebar
sub-intervalnya dapat diperkecil lagi, sehingga daerah di bawah kurva tertutup
semuanya, misalnya dapat digunakan lebar subinterval 0.001. (Silakan dicoba!)


Meskipun Maxima tidak dapat menghitung integral tentu fungsi tersebut untuk
batas-batas yang berhingga, namun integral tersebut dapat dihitung secara eksak jika
batas-batasnya tak hingga. Ini adalah salah satu keajaiban di dalam matematika, yang
terbatas tidak dapat dihitung secara eksak, namun yang tak hingga malah dapat
dihitung secara eksak.


\>$showev('integrate(f(x),x,0,inf))


$$\int_{0}^{\infty }{e^ {- x^2 }\;dx}=\frac{\sqrt{\pi}}{2}$$Berikut adalah contoh lain fungsi yang tidak memiliki antiderivatif, sehingga
integral tentunya hanya dapat dihitung dengan metode numerik.


\>function f(x) &= x^x


    
                                       x
                                      x
    

\>$showev('integrate(f(x),x,0,1))


$$\int_{0}^{1}{x^{x}\;dx}=\int_{0}^{1}{x^{x}\;dx}$$\>x=0:0.1:1-0.01; plot2d(x,f(x+0.01),\>bar); plot2d("f(x)",0,1,\>add):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-098.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-098.png)

Maxima gagal menghitung integral tentu tersebut secara langsung menggunakan perintah
integrate. Berikut kita lakukan seperti contoh sebelumnya untuk mendapat hasil atau
pendekatan nilai integral tentu tersebut.


\>t &= makelist(a,a,0,1-0.01,0.01);

\>fx &= makelist(f(t[i]+0.01),i,1,length(t));


maxima: 'integrate(f(x),x,0,1) = 0.01*sum(fx[i],i,1,length(fx))


Apakah hasil tersebut cukup baik? perhatikan gambarnya.


# Latihan

* 
Bukalah buku Kalkulus.

* 
Cari dan pilih beberapa (paling sedikit 5 fungsi berbeda
* tipe/bentuk/jenis) fungsi dari buku tersebut, kemudian definisikan di
* EMT pada baris-baris perintah berikut (jika perlu tambahkan lagi).

* 
Untuk setiap fungsi, tentukan anti turunannya (jika ada), hitunglah
* integral tentu dengan batas-batas yang menarik (Anda tentukan
* sendiri), seperti contoh-contoh tersebut.

* 
Lakukan hal yang sama untuk fungsi-fungsi yang tidak dapat
* diintegralkan (cari sedikitnya 3 fungsi).

* 
Gambar grafik fungsi dan daerah integrasinya pada sumbu koordinat
* yang sama.

* 
Gunakan integral tentu untuk mencari luas daerah yang dibatasi oleh
* dua kurva yang berpotongan di dua titik. (Cari dan gambar kedua kurva
* dan arsir (warnai) daerah yang dibatasi oleh keduanya.)

* 
Gunakan integral tentu untuk menghitung volume benda putar kurva y=
* f(x) yang diputar mengelilingi sumbu x dari x=a sampai x=b, yakni


$$V = \int_a^b \pi (f(x)^2\ dx.$$(Pilih fungsinya dan gambar kurva dan benda putar yang dihasilkan.
Anda dapat mencari contoh-contoh bagaimana cara menggambar benda hasil
perputaran suatu kurva.)


- Gunakan integral tentu untuk menghitung panjang kurva y=f(x) dari
x=a sampai x=b dengan menggunakan rumus:


$$S = \int_a^b \sqrt{1+(f'(x))^2} \ dx.$$(Pilih fungsi dan gambar kurvanya.)


\>function a(x) &= x^2


    
                                       2
                                      x
    

\>$showev('integrate(a(x),x))


$$\int {x^2}{\;dx}=\frac{x^3}{3}$$\>x=-1:0.2:1-0.01; plot2d(x,a(x+0.01),\>bar); plot2d("a(x)",0,1,\>add):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-102.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-102.png)

\>function b(x) &= 1/(1+4\*x^2)


    
                                      1
                                   --------
                                      2
                                   4 x  + 1
    

\>$showev('integrate(b(x),x,0,1))


$$\int_{0}^{1}{\frac{1}{4\,x^2+1}\;dx}=\frac{\arctan 2}{2}$$\>x=0:0.1:1-0.01; plot2d(x,b(x+0.01),\>bar); plot2d("b(x)",0,1,\>add):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-104.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-104.png)

\>function c(x) &= x/sqrt(1-x^4)


    
                                      x
                                 ------------
                                           4
                                 sqrt(1 - x )
    

\>$showev('integrate(c(x),x,0,1))


$$\int_{0}^{1}{\frac{x}{\sqrt{1-x^4}}\;dx}=\frac{\pi}{4}$$\>x=0:0.1:1-0.01; plot2d(x,c(x+0.01),\>bar); plot2d("c(x)",0,1,\>add):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-106.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-106.png)

\>function d(x) &= x^2 -9\*x


    
                                    2
                                   x  - 9 x
    

\>$showev('integrate(d(x),x,0,1))


$$\int_{0}^{1}{x^2-9\,x\;dx}=-\frac{25}{6}$$\>x=0:0.1:1-0.01; plot2d(x,d(x+0.01),\>bar); plot2d("d(x)",0,1,\>add):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-108.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-108.png)

\>function e(x) &= 1/x^3^3


    
                                      1
                                     ---
                                      27
                                     x
    

\>$showev('integrate(e(x),x,0,1))


    Maxima said:
    defint: integral is divergent.
    #0: showev(f='integrate(1/x^27,x,0,1))
     -- an error. To debug this try: debugmode(true);
    
    Error in:
    $showev('integrate(e(x),x,0,1)) ...
                                   ^

\>x=-1:0.1:1-0.01; plot2d(x,e(x+0.01),\>bar); plot2d("e(x)",0,1,\>add):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-109.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-109.png)

\>function f(x) &= 7\*x/x^7


    
                                      7
                                      --
                                       6
                                      x
    

\>$showev('integrate(f(x),x,0,1))


    Maxima said:
    defint: integral is divergent.
    #0: showev(f=7*'integrate(1/x^6,x,0,1))
     -- an error. To debug this try: debugmode(true);
    
    Error in:
    $showev('integrate(f(x),x,0,1)) ...
                                   ^

\>x=-1:0.1:1-0.01; plot2d(x,f(x+0.01),\>bar); plot2d("f(x)",0,1,\>add):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-110.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-110.png)

\>function g(x) &= 1/x^2+101


    
                                   1
                                   -- + 101
                                    2
                                   x
    

\>$showev('integrate(g(x),x,0,2))


    Maxima said:
    defint: integral is divergent.
    #0: showev(f='integrate(1/x^2+101,x,0,2))
     -- an error. To debug this try: debugmode(true);
    
    Error in:
    $showev('integrate(g(x),x,0,2)) ...
                                   ^

\>x=-1:0.1:1-0.01; plot2d(x,g(x+0.01),\>bar); plot2d("g(x)",0,1,\>add):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-111.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-111.png)

\>function h(x) &=1/x


    
                                      1
                                      -
                                      x
    

\>$showev('integrate(h(x),x,0,1))


    Maxima said:
    defint: integral is divergent.
    #0: showev(f='integrate(1/x,x,0,1))
     -- an error. To debug this try: debugmode(true);
    
    Error in:
    $showev('integrate(h(x),x,0,1)) ...
                                   ^

\>x=0:0.1:1-0.01; plot2d(x,h(x+0.01),\>bar); plot2d("h(x)",0,1,\>add):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-112.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-112.png)

\>function j(x) &= x^2+1


    
                                     2
                                    x  + 1
    

\>$showev(pi\*('integrate(j(x)^2,x,0,1)))


$$\pi\,\int_{0}^{1}{\left(x^2+1\right)^2\;dx}=\frac{28\,\pi}{15}$$\>x=0:0.1:1-0.01; plot2d(x,j(x+0.01),\>bar); plot2d("j(x)",0,1,\>add):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-114.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-114.png)

\>function dj(x) &= limit((j(x+h)-j(x))/h,h,0); $dj(x) // dj(x) = j'(x)


$$2\,x$$\>$showev('integrate(sqrt(1+dj(x)^2),x,0,1))


$$\int_{0}^{1}{\sqrt{4\,x^2+1}\;dx}=\frac{{\rm asinh}\; 2+2\,\sqrt{5}
 }{4}$$\>x=0:0.1:1-0.01; plot2d(x,a(x+0.01),\>bar); plot2d("a(x)",0,1,\>add); plot2d("b(x)",0,1,\>add):


![images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-117.png](images/23030630096_Nur%20Alya%20Fadilah_Kalkulus-117.png)

\> ...  
\>    ...  
\>    ...  
\>    ...  
\>    ...  
\>    ...  
\>  
# Barisan dan Deret

(Catatan: bagian ini belum lengkap. Anda dapat membaca contoh-contoh pengguanaan EMT dan
Maxima untuk menghitung limit barisan, rumus jumlah parsial suatu deret, jumlah tak hingga
suatu deret konvergen, dan sebagainya. Anda dapat mengeksplor contoh-contoh di EMT atau
perbagai panduan penggunaan Maxima di software Maxima atau dari Internet.)


Barisan dapat didefinisikan dengan beberapa cara di dalam EMT, di antaranya:


* 
dengan cara yang sama seperti mendefinisikan vektor dengan elemen-elemen beraturan
* (menggunakan titik dua ":");

* 
menggunakan perintah "sequence" dan rumus barisan (suku ke -n);

* 
menggunakan perintah "iterate" atau "niterate";

* 
menggunakan fungsi Maxima "create_list" atau "makelist" untuk menghasilkan barisan
* simbolik;

* 
menggunakan fungsi biasa yang inputnya vektor atau barisan;

* 
menggunakan fungsi rekursif.


EMT menyediakan beberapa perintah (fungsi) terkait barisan, yakni:


* 
sum: menghitung jumlah semua elemen suatu barisan

* 
cumsum: jumlah kumulatif suatu barisan

* 
differences: selisih antar elemen-elemen berturutan


EMT juga dapat digunakan untuk menghitung jumlah deret berhingga maupun deret tak hingga,
dengan menggunakan perintah (fungsi) "sum". Perhitungan dapat dilakukan secara numerik
maupun simbolik dan eksak.


Berikut adalah beberapa contoh perhitungan barisan dan deret menggunakan EMT.


\>1:10 // barisan sederhana


    [1,  2,  3,  4,  5,  6,  7,  8,  9,  10]

\>1:2:30


    [1,  3,  5,  7,  9,  11,  13,  15,  17,  19,  21,  23,  25,  27,  29]

\>sum(1:2:30), sum(1/(1:2:30))


    225
    2.33587263431

\>$'sum(k, k, 1, n) = factor(ev(sum(k, k, 1, n),simpsum=true)) // simpsum:menghitung deret secara simbolik


$$\sum_{k=1}^{n}{k}=\frac{n\,\left(n+1\right)}{2}$$\>$'sum(1/(3^k+k), k, 0, inf) = factor(ev(sum(1/(3^k+k), k, 0, inf),simpsum=true))


$$\sum_{k=0}^{\infty }{\frac{1}{3^{k}+k}}=\sum_{k=0}^{\infty }{\frac{
 1}{3^{k}+k}}$$Di sini masih gagal, hasilnya tidak dihitung.


\>$'sum(1/x^2, x, 1, inf)= ev(sum(1/x^2, x, 1, inf),simpsum=true) // ev: menghitung nilai ekspresi


$$\sum_{x=1}^{\infty }{\frac{1}{x^2}}=\frac{\pi^2}{6}$$\>$'sum((-1)^(k-1)/k, k, 1, inf) = factor(ev(sum((-1)^(x-1)/x, x, 1, inf),simpsum=true))


$$\sum_{k=1}^{\infty }{\frac{\left(-1\right)^{k-1}}{k}}=-\sum_{x=1}^{
 \infty }{\frac{\left(-1\right)^{x}}{x}}$$Di sini masih gagal, hasilnya tidak dihitung.


\>$'sum((-1)^k/(2\*k-1), k, 1, inf) = factor(ev(sum((-1)^k/(2\*k-1), k, 1, inf),simpsum=true))


$$\sum_{k=1}^{\infty }{\frac{\left(-1\right)^{k}}{2\,k-1}}=\sum_{k=1
 }^{\infty }{\frac{\left(-1\right)^{k}}{2\,k-1}}$$\>$ev(sum(1/n!, n, 0, inf),simpsum=true)


$$\sum_{n=0}^{\infty }{\frac{1}{n!}}$$Di sini masih gagal, hasilnya tidak dihitung, harusnya hasilnya e.


\>&assume(abs(x)<1); $'sum(a\*x^k, k, 0, inf)=ev(sum(a\*x^k, k, 0, inf),simpsum=true), &forget(abs(x)<1);


$$a\,\sum_{k=0}^{\infty }{x^{k}}=\frac{a}{1-x}$$Deret geometri tak hingga, dengan asumsi rasional antara -1 dan 1.


# Deret Taylor

Deret Taylor suatu fungsi f yang diferensiabel sampai tak hingga di
sekitar x=a adalah:


$$f(x) = \sum_{k=0}^\infty \frac{(x-a)^k f^{(k)}(a)}{k!}.$$\>$'e^x =taylor(exp(x),x,0,10) // deret Taylor e^x di sekitar x=0, sampai suku ke-11


$$e^{x}=\frac{x^{10}}{3628800}+\frac{x^9}{362880}+\frac{x^8}{40320}+
 \frac{x^7}{5040}+\frac{x^6}{720}+\frac{x^5}{120}+\frac{x^4}{24}+
 \frac{x^3}{6}+\frac{x^2}{2}+x+1$$\>$'log(x)=taylor(log(x),x,1,10)// deret log(x) di sekitar x=1


$$\log x=x-\frac{\left(x-1\right)^{10}}{10}+\frac{\left(x-1\right)^9
 }{9}-\frac{\left(x-1\right)^8}{8}+\frac{\left(x-1\right)^7}{7}-
 \frac{\left(x-1\right)^6}{6}+\frac{\left(x-1\right)^5}{5}-\frac{
 \left(x-1\right)^4}{4}+\frac{\left(x-1\right)^3}{3}-\frac{\left(x-1
 \right)^2}{2}-1$$

 \section{EMT UNTUK GEEOMETRI}
 # Nur Alya Fadilah_23030630096_Geometry
Nama : Nur Alya Fadilah


NIM  : 23030630096


Prodi: Matematika E 2023


# Visualisasi dan Perhitungan Geometri dengan EMT

Euler menyediakan beberapa fungsi untuk melakukan visualisasi dan
perhitungan geometri, baik secara numerik maupun analitik (seperti
biasanya tentunya, menggunakan Maxima). Fungsi-fungsi untuk
visualisasi dan perhitungan geometeri tersebut disimpan di dalam file
program "geometry.e", sehingga file tersebut harus dipanggil sebelum
menggunakan fungsi-fungsi atau perintah-perintah untuk geometri.


\>load geometry


    Numerical and symbolic geometry.

## Fungsi-fungsi Geometri

Fungsi-fungsi untuk Menggambar Objek Geometri:


  defaultd:=textheight()*1.5: nilai asli untuk parameter d  
  setPlotrange(x1,x2,y1,y2): menentukan rentang x dan y pada bidang koordinat  
  setPlotRange(r): pusat bidang koordinat (0,0) dan batas-batas sumbu-x dan y adalah -r sd r  
  plotPoint (P, "P"): menggambar titik P dan diberi label "P"  
  plotSegment (A,B, "AB", d): menggambar ruas garis AB, diberi label "AB" sejauh d  
  plotLine (g, "g", d): menggambar garis g diberi label "g" sejauh d  
  plotCircle (c,"c",v,d): Menggambar lingkaran c dan diberi label "c"  
  plotLabel (label, P, V, d): menuliskan label pada posisi P  

Fungsi-fungsi Geometri Analitik (numerik maupun simbolik):


  turn(v, phi): memutar vektor v sejauh phi  
  turnLeft(v):   memutar vektor v ke kiri  
  turnRight(v):  memutar vektor v ke kanan  
  normalize(v): normal vektor v  
  crossProduct(v, w): hasil kali silang vektorv dan w.  
  lineThrough(A, B): garis melalui A dan B, hasilnya [a,b,c] sdh. ax+by=c.  
  lineWithDirection(A,v): garis melalui A searah vektor v  
  getLineDirection(g): vektor arah (gradien) garis g  
  getNormal(g): vektor normal (tegak lurus) garis g  
  getPointOnLine(g):  titik pada garis g  
  perpendicular(A, g):  garis melalui A tegak lurus garis g  
  parallel (A, g):  garis melalui A sejajar garis g  
  lineIntersection(g, h):  titik potong garis g dan h  
  projectToLine(A, g):   proyeksi titik A pada garis g  
  distance(A, B):  jarak titik A dan B  
  distanceSquared(A, B):  kuadrat jarak A dan B  
  quadrance(A, B): kuadrat jarak A dan B  
  areaTriangle(A, B, C):  luas segitiga ABC  
  computeAngle(A, B, C):   besar sudut &lt;ABC  
  angleBisector(A, B, C): garis bagi sudut &lt;ABC  
  circleWithCenter (A, r): lingkaran dengan pusat A dan jari-jari r  
  getCircleCenter(c):  pusat lingkaran c  
  getCircleRadius(c):  jari-jari lingkaran c  
  circleThrough(A,B,C):  lingkaran melalui A, B, C  
  middlePerpendicular(A, B): titik tengah AB  
  lineCircleIntersections(g, c): titik potong garis g dan lingkran c  
  circleCircleIntersections (c1, c2):  titik potong lingkaran c1 dan c2  
  planeThrough(A, B, C):  bidang melalui titik A, B, C  

Fungsi-fungsi Khusus Untuk Geometri Simbolik:


  getLineEquation (g,x,y): persamaan garis g dinyatakan dalam x dan y  
  getHesseForm (g,x,y,A): bentuk Hesse garis g dinyatakan dalam x dan y dengan titik A pada  

sisi positif (kanan/atas) garis


  quad(A,B): kuadrat jarak AB


  spread(a,b,c): Spread segitiga dengan panjang sisi-sisi a,b,c, yakni sin(alpha)^2 dengan
alpha sudut yang menghadap sisi a.


  crosslaw(a,b,c,sa): persamaan 3 quads dan 1 spread pada segitiga dengan panjang sisi a, b,
c.


  triplespread(sa,sb,sc): persamaan 3 spread sa,sb,sc yang memebntuk suatu segitiga


  doublespread(sa): Spread sudut rangkap Spread 2*phi, dengan sa=sin(phi)^2 spread a.


## Contoh 1: Luas, Lingkaran Luar, Lingkaran Dalam Segitiga

Untuk menggambar objek-objek geometri, langkah pertama adalah menentukan rentang sumbu-sumbu
koordinat. Semua objek geometri akan digambar pada satu bidang koordinat, sampai
didefinisikan bidang koordinat yang baru.


\>setPlotRange(-0.5,2.5,-0.5,2.5); // mendefinisikan bidang koordinat baru 


Sekarang tetapkan tiga poin dan plot mereka.


\>A=[1,0]; plotPoint(A,"A"); // definisi dan gambar tiga titik

\>B=[0,1]; plotPoint(B,"B");

\>C=[2,2]; plotPoint(C,"C");


Kemudian tiga segmen.


\>plotSegment(A,B,"c"); // c=AB

\>plotSegment(B,C,"a"); // a=BC

\>plotSegment(A,C,"b"); // b=AC


Fungsi geometri meliputi fungsi untuk membuat garis dan lingkaran.
Format garis adalah [a,b,c], yang mewakili garis dengan persamaan
ax+by=c.


\>lineThrough(B,C) // garis yang melalui B dan C


    [-1,  2,  2]

Hitunglah garis tegak lurus yang melalui A pada BC.


\>h=perpendicular(A,lineThrough(B,C)); // garis h tegak lurus BC melalui A


Dan persimpangannya dengan BC.


\>D=lineIntersection(h,lineThrough(B,C)); // D adalah titik potong h dan BC


Rencanakan itu.


\>plotPoint(D,value=1); // koordinat D ditampilkan

\>aspect(1); plotSegment(A,D): // tampilkan semua gambar hasil plot...()


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-001.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-001.png)

Hitung luas ABC:


\>norm(A-D)\*norm(B-C)/2 // AD=norm(A-D), BC=norm(B-C)


    1.5

Bandingkan dengan rumus determinan.


\>areaTriangle(A,B,C) // hitung luas segitiga langusng dengan fungsi


    1.5

Cara lain menghitung luas segitigas ABC:


\>distance(A,D)\*distance(B,C)/2


    1.5

Sudut di C


\>degprint(computeAngle(B,C,A))


    3652'11.63''

Sekarang lingkaran luar segitiga.


\>c=circleThrough(A,B,C); // lingkaran luar segitiga ABC

\>R=getCircleRadius(c); // jari2 lingkaran luar 

\>O=getCircleCenter(c); // titik pusat lingkaran c 

\>plotPoint(O,"O"); // gambar titik "O"

\>plotCircle(c,"Lingkaran luar segitiga ABC"):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-002.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-002.png)

Tampilkan koordinat titik pusat dan jari-jari lingkaran luar.


\>O, R


    [1.16667,  1.16667]
    1.17851130198

Sekarang akan digambar lingkaran dalam segitiga ABC. Titik pusat lingkaran dalam adalah
titik potong garis-garis bagi sudut.


\>l=angleBisector(A,C,B); // garis bagi <ACB

\>g=angleBisector(C,A,B); // garis bagi <CAB

\>P=lineIntersection(l,g) // titik potong kedua garis bagi sudut


    [0.86038,  0.86038]

Tambahkan semuanya ke plot.


\>color(5); plotLine(l); plotLine(g); color(1); // gambar kedua garis bagi sudut

\>plotPoint(P,"P"); // gambar titik potongnya

\>r=norm(P-projectToLine(P,lineThrough(A,B))) // jari-jari lingkaran dalam


    0.509653732104

\>plotCircle(circleWithCenter(P,r),"Lingkaran dalam segitiga ABC"): // gambar lingkaran dalam


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-003.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-003.png)

## Latihan

1. Tentukan ketiga titik singgung lingkaran dalam dengan sisi-sisi
segitiga ABC.


Jawaban:


\>setPlotRange(-2.5,4.5,-2.5,4.5);

\>A=[-2,1]; plotPoint(A,"A");

\>B=[1,-2]; plotPoint(B,"B");

\>C=[4,4]; plotPoint(C,"C");


2. Gambar segitiga dengan titik-titik sudut ketiga titik singgung
tersebut.


Jawaban:


\>plotSegment(A,B,"c")

\>plotSegment(B,C,"a")

\>plotSegment(A,C,"b")

\>aspect(1):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-004.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-004.png)

3. Tunjukkan bahwa garis bagi sudut yang ke tiga juga melalui titik
pusat lingkaran dalam.


Jawaban:


\>l=angleBisector(A,C,B);

\>g=angleBisector(C,A,B);

\>P=lineIntersection(l,g)


    [0.581139,  0.581139]

\>color(5); plotLine(l); plotLine(g); color(1);

\>plotPoint(P,"P");

\>r=norm(P-projectToLine(P,lineThrough(A,B)))


    1.52896119631

\>plotCircle(circleWithCenter(P,r),"Lingkaran dalam segitiga ABC"):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-005.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-005.png)

Jadi, terbukti bahwa garis bagi sudut yang ketiga juga melalui titik
pusat lingkaran dalam.


4. Gambar jari-jari lingkaran dalam.


Jawaban:


\>r=norm(P-projectToLine(P,lineThrough(A,B)))


    1.52896119631

\>plotCircle(circleWithCenter(P,r),"Lingkaran dalam segitiga ABC"):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-006.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-006.png)

# Contoh 2: Geometri Smbolik

Kita dapat menghitung geometri eksak dan simbolik menggunakan Maxima.


File geometri.e menyediakan fungsi yang sama (dan lebih banyak lagi)
di Maxima. Namun, kita dapat menggunakan perhitungan simbolik
sekarang.


\>A &= [1,0]; B &= [0,1]; C &= [2,2]; // menentukan tiga titik A, B, C


Fungsi untuk garis dan lingkaran bekerja seperti fungsi Euler, tetapi
memberikan perhitungan simbolis.


\>c &= lineThrough(B,C) // c=BC


    
                                 [- 1, 2, 2]
    

Kita bisa mendapatkan persamaan garis dengan mudah.


\>$getLineEquation(c,x,y), $solve(%,y) | expand // persamaan garis c


$$2\,y-x=2$$$$\left[ y=\frac{x}{2}+1 \right] $$\>$getLineEquation(lineThrough(A,[x1,y1]),x,y) // persamaan garis melalui A dan (x1, y1)


$$\left({\it x_1}-1\right)\,y-x\,{\it y_1}=-{\it y_1}$$\>h &= perpendicular(A,lineThrough(B,C)) // h melalui A tegak lurus BC


    
                                  [2, 1, 2]
    

\>Q &= lineIntersection(c,h) // Q titik potong garis c=BC dan h


    
                                     2  6
                                    [-, -]
                                     5  5
    

\>$projectToLine(A,lineThrough(B,C)) // proyeksi A pada BC


$$\left[ \frac{2}{5} , \frac{6}{5} \right] $$\>$distance(A,Q) // jarak AQ


$$\frac{3}{\sqrt{5}}$$\>cc &= circleThrough(A,B,C); $cc // (titik pusat dan jari-jari) lingkaran melalui A, B, C


$$\left[ \frac{7}{6} , \frac{7}{6} , \frac{5}{3\,\sqrt{2}} \right] $$\>r&=getCircleRadius(cc); $r , $float(r) // tampilkan nilai jari-jari


$$\frac{5}{3\,\sqrt{2}}$$$$1.178511301977579$$\>$computeAngle(A,C,B) // nilai <ACB


$$\arccos \left(\frac{4}{5}\right)$$\>$solve(getLineEquation(angleBisector(A,C,B),x,y),y)[1] // persamaan garis bagi <ACB


$$y=x$$\>P &= lineIntersection(angleBisector(A,C,B),angleBisector(C,B,A)); $P // titik potong 2 garis bagi sudut


$$\left[ \frac{\sqrt{2}\,\sqrt{5}+2}{6} , \frac{\sqrt{2}\,\sqrt{5}+2
 }{6} \right] $$\>P() // hasilnya sama dengan perhitungan sebelumnya


    [0.86038,  0.86038]

## Berpotongan Garis dan Lingkaran

Tentu saja, kita juga dapat memotong garis dengan lingkaran, dan
lingkaran dengan lingkaran.


\>A &:= [1,0]; c=circleWithCenter(A,4);

\>B &:= [1,2]; C &:= [2,1]; l=lineThrough(B,C);

\>setPlotRange(5); plotCircle(c); plotLine(l);


Perpotongan garis dengan lingkaran menghasilkan dua titik dan jumlah
titik potong.


\>{P1,P2,f}=lineCircleIntersections(l,c);

\>P1, P2,


    [4.64575,  -1.64575]
    [-0.645751,  3.64575]

\>plotPoint(P1); plotPoint(P2):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-018.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-018.png)

Begitu pula di Maxima.


\>c &= circleWithCenter(A,4) // lingkaran dengan pusat A jari-jari 4


    
                                  [1, 0, 4]
    

\>l &= lineThrough(B,C) // garis l melalui B dan C


    
                                  [1, 1, 3]
    

\>$lineCircleIntersections(l,c) | radcan, // titik potong lingkaran c dan garis l


$$\left[ \left[ \sqrt{7}+2 , 1-\sqrt{7} \right]  , \left[ 2-\sqrt{7}
  , \sqrt{7}+1 \right]  \right] $$Akan ditunjukkan bahwa sudut-sudut yang menghadap bsuusr yang sama adalah sama besar.


\>C=A+normalize([-2,-3])\*4; plotPoint(C); plotSegment(P1,C); plotSegment(P2,C);

\>degprint(computeAngle(P1,C,P2))


    6917'42.68''

\>C=A+normalize([-4,-3])\*4; plotPoint(C); plotSegment(P1,C); plotSegment(P2,C);

\>degprint(computeAngle(P1,C,P2))


    6917'42.68''

\>insimg;


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-020.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-020.png)

## Garis Sumbu

Berikut adalah langkah-langkah menggambar garis sumbu ruas garis AB:


1. Gambar lingkaran dengan pusat A melalui B.


2. Gambar lingkaran dengan pusat B melalui A.


3. Tarik garis melallui kedua titik potong kedua lingkaran tersebut. Garis ini merupakan
garis sumbu (melalui titik tengah dan tegak lurus) AB.


\>A=[2,2]; B=[-1,-2];

\>c1=circleWithCenter(A,distance(A,B));

\>c2=circleWithCenter(B,distance(A,B));

\>{P1,P2,f}=circleCircleIntersections(c1,c2);

\>l=lineThrough(P1,P2);

\>setPlotRange(5); plotCircle(c1); plotCircle(c2);

\>plotPoint(A); plotPoint(B); plotSegment(A,B); plotLine(l):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-021.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-021.png)

Selanjutnya, kami melakukan hal yang sama di Maxima dengan koordinat
umum.


\>A &= [a1,a2]; B &= [b1,b2];

\>c1 &= circleWithCenter(A,distance(A,B));

\>c2 &= circleWithCenter(B,distance(A,B));

\>P &= circleCircleIntersections(c1,c2); P1 &= P[1]; P2 &= P[2];


Persamaan untuk persimpangan cukup terlibat. Tapi kita bisa
disederhanakan, jika kita selesaikan untuk y.


\>g &= getLineEquation(lineThrough(P1,P2),x,y);

\>$solve(g,y)


$$\left[ y=\frac{-\left(2\,{\it b_1}-2\,{\it a_1}\right)\,x+{\it b_2}
 ^2+{\it b_1}^2-{\it a_2}^2-{\it a_1}^2}{2\,{\it b_2}-2\,{\it a_2}}
  \right] $$Ini memang sama dengan tegak lurus tengah, yang dihitung dengan cara
yang sama sekali berbeda.


\>$solve(getLineEquation(middlePerpendicular(A,B),x,y),y)


$$\left[ y=\frac{-\left(2\,{\it b_1}-2\,{\it a_1}\right)\,x+{\it b_2}
 ^2+{\it b_1}^2-{\it a_2}^2-{\it a_1}^2}{2\,{\it b_2}-2\,{\it a_2}}
  \right] $$\>h &=getLineEquation(lineThrough(A,B),x,y);

\>$solve(h,y)


$$\left[ y=\frac{\left({\it b_2}-{\it a_2}\right)\,x-{\it a_1}\,
 {\it b_2}+{\it a_2}\,{\it b_1}}{{\it b_1}-{\it a_1}} \right] $$Perhatikan hasil kali gradien garis g dan h adalah:


Artinya kedua garis tegak lurus.


# Contoh 3: Rumus Heron

Rumus Heron menyatakan bahwa luas segitiga dengan panjang sisi-sisi a,
b dan c adalah:


Untuk membuktikan hal ini kita misalkan C(0,0), B(a,0) dan A(x,y),
b=AC, c=AB. Luas segitiga ABC adalah


Nilai y didapat dengan menyelesaikan sistem persamaan:


\>sol &= solve([x^2+y^2=b^2,(x-a)^2+y^2=c^2],[x,y])


    
                                      []
    

Ekstrak solusi y.


\>ysol &= y with sol[2][2]; $ysol


    Maxima said:
    part: invalid index of list or matrix.
     -- an error. To debug this try: debugmode(true);
    
    Error in:
    ysol &amp;= y with sol[2][2]; $ysol ...
                            ^

Kami mendapatkan rumus Heron.


\>function H(a,b,c) &= sqrt(factor((ysol\*a/2)^2)); $'H(a,b,c)=H(a,b,c)


$$H\left(a , b , \left[ 1 , 0 , 4 \right] \right)=\frac{\left| a
 \right| \,\left| {\it ysol}\right| }{2}$$Tentu saja, setiap segitiga persegi panjang adalah kasus yang
terkenal.


\>H(3,4,5) //luas segitiga siku-siku dengan panjang sisi 3, 4, 5


    Variable or function ysol not found.
    Try "trace errors" to inspect local variables after errors.
    H:
        useglobal; return abs(a)*abs(ysol)/2 
    Error in:
    H(3,4,5) //luas segitiga siku-siku dengan panjang sisi 3, 4, 5 ...
            ^

Dan juga jelas, bahwa ini adalah segitiga dengan luas maksimal dan dua
sisi 3 dan 4.


\>aspect (1.5); plot2d(&H(3,4,x),1,7): // Kurva luas segitiga sengan panjang sisi 3, 4, x (1<= x <=7)


    Variable or function ysol not found.
    Error in expression: 3*abs(ysol)/2
    %ploteval:
        y0=f$(x[1],args());
    adaptiveevalone:
        s=%ploteval(g$,t;args());
    Try "trace errors" to inspect local variables after errors.
    plot2d:
        dw/n,dw/n^2,dw/n,auto;args());

Kasus umum juga berfungsi.


\>$solve(diff(H(a,b,c)^2,c)=0,c)


    Maxima said:
    diff: second argument must be a variable; found [1,0,4]
     -- an error. To debug this try: debugmode(true);
    
    Error in:
    $solve(diff(H(a,b,c)^2,c)=0,c) ...
                                  ^

Sekarang mari kita cari himpunan semua titik di mana b+c=d untuk
beberapa konstanta d. Diketahui bahwa ini adalah elips.


\>s1 &= subst(d-c,b,sol[2]); $s1


    Maxima said:
    part: invalid index of list or matrix.
     -- an error. To debug this try: debugmode(true);
    
    Error in:
    s1 &amp;= subst(d-c,b,sol[2]); $s1 ...
                             ^

Dan buat fungsi ini.


\>function fx(a,c,d) &= rhs(s1[1]); $fx(a,c,d), function fy(a,c,d) &= rhs(s1[2]); $fy(a,c,d)


$$0$$$$0$$Sekarang kita bisa menggambar setnya. Sisi b bervariasi dari 1 hingga
4. Diketahui bahwa kita mendapatkan elips.


\>aspect(1); plot2d(&fx(3,x,5),&fy(3,x,5),xmin=1,xmax=4,square=1):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-028.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-028.png)

Kita dapat memeriksa persamaan umum untuk elips ini, yaitu.


di mana (xm,ym) adalah pusat, dan u dan v adalah setengah sumbu.


\>$ratsimp((fx(a,c,d)-a/2)^2/u^2+fy(a,c,d)^2/v^2 with [u=d/2,v=sqrt(d^2-a^2)/2])


$$\frac{a^2}{d^2}$$Kita lihat bahwa tinggi dan luas segitiga adalah maksimal untuk x=0.
Jadi luas segitiga dengan a+b+c=d maksimal jika segitiga sama sisi.
Kami ingin menurunkan ini secara analitis.


\>eqns &= [diff(H(a,b,d-(a+b))^2,a)=0,diff(H(a,b,d-(a+b))^2,b)=0]; $eqns


$$\left[ \frac{a\,{\it ysol}^2}{2}=0 , 0=0 \right] $$Kami mendapatkan beberapa minima, yang termasuk dalam segitiga dengan
satu sisi 0, dan solusinya a=b=c=d/3.


\>$solve(eqns,[a,b])


$$\left[ \left[ a=0 , b={\it \%r_1} \right]  \right] $$Ada juga metode Lagrange, memaksimalkan H(a,b,c)^2 terhadap a+b+d=d.


\>&solve([diff(H(a,b,c)^2,a)=la,diff(H(a,b,c)^2,b)=la, ...  
\>      diff(H(a,b,c)^2,c)=la,a+b+c=d],[a,b,c,la])


    Maxima said:
    diff: second argument must be a variable; found [1,0,4]
     -- an error. To debug this try: debugmode(true);
    
    Error in:
    ... la,    diff(H(a,b,c)^2,c)=la,a+b+c=d],[a,b,c,la]) ...
                                                         ^

Kita bisa membuat plot situasinya


Pertama-tama atur poin di Maxima.


\>A &= at([x,y],sol[2]); $A


    Maxima said:
    part: invalid index of list or matrix.
     -- an error. To debug this try: debugmode(true);
    
    Error in:
    A &amp;= at([x,y],sol[2]); $A ...
                         ^

\>B &= [0,0]; $B, C &= [a,0]; $C


$$\left[ 0 , 0 \right] $$$$\left[ a , 0 \right] $$Kemudian atur rentang plot, dan plot titik-titiknya.


\>setPlotRange(0,5,-2,3); ...  
\>   a=4; b=3; c=2; ...  
\>   plotPoint(mxmeval("B"),"B"); plotPoint(mxmeval("C"),"C"); ...  
\>   plotPoint(mxmeval("A"),"A"):


    Variable a1 not found!
    Use global variables or parameters for string evaluation.
    Error in Evaluate, superfluous characters found.
    Try "trace errors" to inspect local variables after errors.
    mxmeval:
        return evaluate(mxm(s));
    Error in:
    ... otPoint(mxmeval("C"),"C"); plotPoint(mxmeval("A"),"A"): ...
                                                         ^

Plot segmen.


\>plotSegment(mxmeval("A"),mxmeval("C")); ...  
\>   plotSegment(mxmeval("B"),mxmeval("C")); ...  
\>   plotSegment(mxmeval("B"),mxmeval("A")):


    Variable a1 not found!
    Use global variables or parameters for string evaluation.
    Error in Evaluate, superfluous characters found.
    Try "trace errors" to inspect local variables after errors.
    mxmeval:
        return evaluate(mxm(s));
    Error in:
    plotSegment(mxmeval("A"),mxmeval("C")); plotSegment(mxmeval("B ...
                            ^

Hitung tegak lurus tengah di Maxima.


\>h &= middlePerpendicular(A,B); g &= middlePerpendicular(B,C);


Dan pusat lingkaran.


\>U &= lineIntersection(h,g);


Kami mendapatkan rumus untuk jari-jari lingkaran.


\>&assume(a\>0,b\>0,c\>0); $distance(U,B) | radcan


$$\frac{\sqrt{{\it a_2}^2+{\it a_1}^2}\,\sqrt{{\it a_2}^2+{\it a_1}^2
 -2\,a\,{\it a_1}+a^2}}{2\,\left| {\it a_2}\right| }$$Mari kita tambahkan ini ke plot.


\>plotPoint(U()); ...  
\>   plotCircle(circleWithCenter(mxmeval("U"),mxmeval("distance(U,C)"))):


    Variable a2 not found!
    Use global variables or parameters for string evaluation.
    Error in ^
    Error in expression: [a/2,(a2^2+a1^2-a*a1)/(2*a2)]
    Error in:
    plotPoint(U()); plotCircle(circleWithCenter(mxmeval("U"),mxmev ...
                 ^

Menggunakan geometri, kami memperoleh rumus sederhana


untuk radiusnya. Kita bisa cek, apakah ini benar dengan Maxima. Maxima
akan memfaktorkan ini hanya jika kita kuadratkan.


\>$c^2/sin(computeAngle(A,B,C))^2  | factor


$$\left[ \frac{{\it a_2}^2+{\it a_1}^2}{{\it a_2}^2} , 0 , \frac{16\,
 \left({\it a_2}^2+{\it a_1}^2\right)}{{\it a_2}^2} \right] $$# Contoh 4: Garis Euler dan Parabola

Garis Euler adalah garis yang ditentukan dari sembarang segitiga yang
tidak sama sisi. Ini adalah garis tengah segitiga, dan melewati
beberapa titik penting yang ditentukan dari segitiga, termasuk
orthocenter, circumcenter, centroid, titik Exeter dan pusat lingkaran
sembilan titik segitiga.


Untuk demonstrasi, kami menghitung dan memplot garis Euler dalam
sebuah segitiga.


Pertama, kita mendefinisikan sudut-sudut segitiga di Euler. Kami
menggunakan definisi, yang terlihat dalam ekspresi simbolis.


\>A::=[-1,-1]; B::=[2,0]; C::=[1,2];


Untuk memplot objek geometris, kami menyiapkan area plot, dan
menambahkan titik ke sana. Semua plot objek geometris ditambahkan ke
plot saat ini.


\>setPlotRange(3); plotPoint(A,"A"); plotPoint(B,"B"); plotPoint(C,"C");


Kita juga bisa menambahkan sisi segitiga.


\>plotSegment(A,B,""); plotSegment(B,C,""); plotSegment(C,A,""):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-036.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-036.png)

Berikut adalah luas segitiga, menggunakan rumus determinan. Tentu
saja, kita harus mengambil nilai absolut dari hasil ini.


\>$areaTriangle(A,B,C)


$$-\frac{7}{2}$$Kita dapat menghitung koefisien sisi c.


\>c &= lineThrough(A,B)


    
                                [- 1, 3, - 2]
    

Dan juga dapatkan rumus untuk baris ini.


\>$getLineEquation(c,x,y)


$$3\,y-x=-2$$Untuk bentuk Hesse, kita perlu menentukan sebuah titik, sehingga titik
tersebut berada di sisi positif dari bentuk Hesse. Memasukkan titik
menghasilkan jarak positif ke garis.


\>$getHesseForm(c,x,y,C), $at(%,[x=C[1],y=C[2]])


$$\frac{3\,y-x+2}{\sqrt{10}}$$$$\frac{7}{\sqrt{10}}$$Sekarang kita hitung lingkaran luar ABC.


\>LL &= circleThrough(A,B,C); $getCircleEquation(LL,x,y)


$$\left(y-\frac{5}{14}\right)^2+\left(x-\frac{3}{14}\right)^2=\frac{
 325}{98}$$\>O &= getCircleCenter(LL); $O


$$\left[ \frac{3}{14} , \frac{5}{14} \right] $$Gambarkan lingkaran dan pusatnya. Cu dan U adalah simbolis. Kami
mengevaluasi ekspresi ini untuk Euler.


\>plotCircle(LL()); plotPoint(O(),"O"):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-043.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-043.png)

Kita dapat menghitung perpotongan ketinggian di ABC (orthocenter)
secara numerik dengan perintah berikut.


\>H &= lineIntersection(perpendicular(A,lineThrough(C,B)),...  
\>     perpendicular(B,lineThrough(A,C))); $H


$$\left[ \frac{11}{7} , \frac{2}{7} \right] $$Sekarang kita dapat menghitung garis Euler dari segitiga.


\>el &= lineThrough(H,O); $getLineEquation(el,x,y)


$$-\frac{19\,y}{14}-\frac{x}{14}=-\frac{1}{2}$$Tambahkan ke plot kami.


\>plotPoint(H(),"H"); plotLine(el(),"Garis Euler"):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-046.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-046.png)

Pusat gravitasi harus berada di garis ini.


\>M &= (A+B+C)/3; $getLineEquation(el,x,y) with [x=M[1],y=M[2]]


$$-\frac{1}{2}=-\frac{1}{2}$$\>plotPoint(M(),"M"): // titik berat


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-048.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-048.png)

Teorinya memberitahu kita MH=2*MO. Kita perlu menyederhanakan dengan
radcan untuk mencapai ini.


\>$distance(M,H)/distance(M,O)|radcan


$$2$$Fungsi termasuk fungsi untuk sudut juga.


\>$computeAngle(A,C,B), degprint(%())


$$\arccos \left(\frac{4}{\sqrt{5}\,\sqrt{13}}\right)$$    6015'18.43''

Persamaan untuk pusat incircle tidak terlalu bagus.


\>Q &= lineIntersection(angleBisector(A,C,B),angleBisector(C,B,A))|radcan; $Q


$$\left[ \frac{\left(2^{\frac{3}{2}}+1\right)\,\sqrt{5}\,\sqrt{13}-15
 \,\sqrt{2}+3}{14} , \frac{\left(\sqrt{2}-3\right)\,\sqrt{5}\,\sqrt{
 13}+5\,2^{\frac{3}{2}}+5}{14} \right] $$Mari kita hitung juga ekspresi untuk jari-jari lingkaran yang
tertulis.


\>r &= distance(Q,projectToLine(Q,lineThrough(A,B)))|ratsimp; $r


$$\frac{\sqrt{\left(-41\,\sqrt{2}-31\right)\,\sqrt{5}\,\sqrt{13}+115
 \,\sqrt{2}+614}}{7\,\sqrt{2}}$$\>LD &=  circleWithCenter(Q,r); // Lingkaran dalam


Mari kita tambahkan ini ke plot.


\>color(5); plotCircle(LD()):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-053.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-053.png)

## Parabola

Selanjutnya akan dicari persamaan tempat kedudukan titik-titik yang berjarak sama ke titik C
dan ke garis AB.


\>p &= getHesseForm(lineThrough(A,B),x,y,C)-distance([x,y],C); $p='0


$$\frac{3\,y-x+2}{\sqrt{10}}-\sqrt{\left(2-y\right)^2+\left(1-x
 \right)^2}=0$$Persamaan tersebut dapat digambar menjadi satu dengan gambar sebelumnya.


\>plot2d(p,level=0,add=1,contourcolor=6):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-055.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-055.png)

Ini seharusnya menjadi beberapa fungsi, tetapi pemecah default Maxima
hanya dapat menemukan solusinya, jika kita kuadratkan persamaannya.
Akibatnya, kami mendapatkan solusi palsu.


\>akar &= solve(getHesseForm(lineThrough(A,B),x,y,C)^2-distance([x,y],C)^2,y)


    
            [y = - 3 x - sqrt(70) sqrt(9 - 2 x) + 26, 
                                  y = - 3 x + sqrt(70) sqrt(9 - 2 x) + 26]
    

Solusi pertama adalah


maxima: akar[1]


Menambahkan solusi pertama ke plot menunjukkan, bahwa itu memang jalan
yang kita cari. Teorinya memberi tahu kita bahwa itu adalah parabola
yang diputar.


\>plot2d(&rhs(akar[1]),add=1):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-056.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-056.png)

\>function g(x) &= rhs(akar[1]); $'g(x)= g(x)// fungsi yang mendefinisikan kurva di atas


$$g\left(x\right)=-3\,x-\sqrt{70}\,\sqrt{9-2\,x}+26$$\>T &=[-1, g(-1)]; // ambil sebarang titik pada kurva tersebut

\>dTC &= distance(T,C); $fullratsimp(dTC), $float(%) // jarak T ke C


$$\sqrt{1503-54\,\sqrt{11}\,\sqrt{70}}$$$$2.135605779339061$$\>U &= projectToLine(T,lineThrough(A,B)); $U // proyeksi T pada garis AB 


$$\left[ \frac{80-3\,\sqrt{11}\,\sqrt{70}}{10} , \frac{20-\sqrt{11}\,
 \sqrt{70}}{10} \right] $$\>dU2AB &= distance(T,U); $fullratsimp(dU2AB), $float(%) // jatak T ke AB


$$\sqrt{1503-54\,\sqrt{11}\,\sqrt{70}}$$$$2.135605779339061$$Ternyata jarak T ke C sama dengan jarak T ke AB. Coba Anda pilih titik T yang lain dan
ulangi perhitungan-perhitungan di atas untuk menunjukkan bahwa hasilnya juga sama.


\>y


    Variable y not found!
    Error in:
    y ...
     ^

# Contoh 5: Trigonometri Rasional

Ini terinspirasi dari ceramah N.J.Wildberger. Dalam bukunya "Divine
Proportions", Wildberger mengusulkan untuk mengganti pengertian klasik
tentang jarak dan sudut dengan kuadrat dan penyebaran. Dengan
menggunakan ini, memang mungkin untuk menghindari fungsi trigonometri
dalam banyak contoh, dan tetap "rasional".


Berikut ini, saya memperkenalkan konsep, dan memecahkan beberapa
masalah. Saya menggunakan perhitungan simbolik Maxima di sini, yang
menyembunyikan keuntungan utama dari trigonometri rasional bahwa
perhitungan hanya dapat dilakukan dengan kertas dan pensil. Anda
diundang untuk memeriksa hasil tanpa komputer.


Intinya adalah bahwa perhitungan rasional simbolis sering kali
menghasilkan hasil yang sederhana. Sebaliknya, trigonometri klasik
menghasilkan hasil trigonometri yang rumit, yang hanya mengevaluasi
perkiraan numerik.


\>load geometry;


Untuk pengenalan pertama, kami menggunakan segitiga persegi panjang
dengan proporsi Mesir terkenal 3, 4 dan 5. Perintah berikut adalah
perintah Euler untuk merencanakan geometri bidang yang terdapat dalam
file Euler "geometry.e".


\>C&:=[0,0]; A&:=[4,0]; B&:=[0,3]; ...  
\>   setPlotRange(-1,5,-1,5); ...  
\>   plotPoint(A,"A"); plotPoint(B,"B"); plotPoint(C,"C"); ...  
\>   plotSegment(B,A,"c"); plotSegment(A,C,"b"); plotSegment(C,B,"a"); ...  
\>   insimg(30);


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-063.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-063.png)

Tentu saja,


di mana wa adalah sudut di A. Cara yang biasa untuk menghitung sudut
ini, adalah dengan mengambil invers dari fungsi sinus. Hasilnya adalah
sudut yang tidak dapat dicerna, yang hanya dapat dicetak kira-kira.


\>wa := arcsin(3/5); degprint(wa)


    3652'11.63''

Trigonometri rasional mencoba menghindari hal ini.


Gagasan pertama trigonometri rasional adalah kuadran, yang
menggantikan jarak. Sebenarnya, itu hanya kuadrat jarak. Berikut ini,
a, b, dan c menunjukkan kuadrat dari sisi-sisinya.


Teorema Pythogoras menjadi a+b=c.


\>a &= 3^2; b &= 4^2; c &= 5^2; &a+b=c


    
                                   25 = 25
    

Pengertian kedua dari trigonometri rasional adalah penyebaran. Spread
mengukur pembukaan antar baris. Ini adalah 0, jika garis-garisnya
sejajar, dan 1, jika garis-garisnya persegi panjang. Ini adalah
kuadrat sinus sudut antara dua garis.


Penyebaran garis AB dan AC pada gambar di atas didefinisikan sebagai:


di mana a dan c adalah kuadrat dari sembarang segitiga siku-siku
dengan salah satu sudut di A.


\>sa &= a/c; $sa


$$\frac{9}{25}$$Ini lebih mudah dihitung daripada sudut, tentu saja. Tetapi Anda
kehilangan properti bahwa sudut dapat ditambahkan dengan mudah.


Tentu saja, kita dapat mengonversi nilai perkiraan untuk sudut wa
menjadi sprad, dan mencetaknya sebagai pecahan.


\>fracprint(sin(wa)^2)


    9/25

Hukum kosinus trgonometri klasik diterjemahkan menjadi "hukum silang"
berikut.


Di sini a, b, dan c adalah kuadrat dari sisi-sisi segitiga, dan sa
adalah penyebaran sudut A. Sisi a, seperti biasa, berhadapan dengan
sudut A.


Hukum ini diimplementasikan dalam file geometri.e yang kami muat ke
Euler.


\>$crosslaw(aa,bb,cc,saa)


$$\left[ \left({\it bb}-{\it aa}+\frac{7}{6}\right)^2 , \left(
 {\it bb}-{\it aa}+\frac{7}{6}\right)^2 , \left({\it bb}-{\it aa}+
 \frac{5}{3\,\sqrt{2}}\right)^2 \right] =\left[ \frac{14\,{\it bb}\,
 \left(1-{\it saa}\right)}{3} , \frac{14\,{\it bb}\,\left(1-{\it saa}
 \right)}{3} , \frac{5\,2^{\frac{3}{2}}\,{\it bb}\,\left(1-{\it saa}
 \right)}{3} \right] $$Dalam kasus kami, kami mendapatkan


\>$crosslaw(a,b,c,sa)


$$1024=1024$$Mari kita gunakan crosslaw ini untuk mencari spread di A. Untuk
melakukan ini, kita buat crosslaw untuk kuadran a, b, dan c, dan
selesaikan untuk spread yang tidak diketahui sa.


Anda dapat melakukannya dengan tangan dengan mudah, tetapi saya
menggunakan Maxima. Tentu saja, kami mendapatkan hasilnya, kami sudah
memilikinya.


\>$crosslaw(a,b,c,x), $solve(%,x)


$$1024=1600\,\left(1-x\right)$$$$\left[ x=\frac{9}{25} \right] $$Kita sudah tahu ini. Definisi spread adalah kasus khusus dari
crosslaw.


Kita juga dapat menyelesaikan ini untuk umum a,b,c. Hasilnya adalah
rumus yang menghitung penyebaran sudut segitiga yang diberikan kuadrat
dari ketiga sisinya.


\>$solve(crosslaw(aa,bb,cc,x),x)


$$\left[ \left[ \frac{168\,{\it bb}\,x+36\,{\it bb}^2+\left(-72\,
 {\it aa}-84\right)\,{\it bb}+36\,{\it aa}^2-84\,{\it aa}+49}{36} , 
 \frac{168\,{\it bb}\,x+36\,{\it bb}^2+\left(-72\,{\it aa}-84\right)
 \,{\it bb}+36\,{\it aa}^2-84\,{\it aa}+49}{36} , \frac{15\,2^{\frac{
 5}{2}}\,{\it bb}\,x+18\,{\it bb}^2+\left(-36\,{\it aa}-15\,2^{\frac{
 3}{2}}\right)\,{\it bb}+18\,{\it aa}^2-15\,2^{\frac{3}{2}}\,{\it aa}
 +25}{18} \right] =0 \right] $$Kita bisa membuat fungsi dari hasilnya. Fungsi seperti itu sudah
didefinisikan dalam file geometri.e dari Euler.


\>$spread(a,b,c)


$$\frac{9}{25}$$Sebagai contoh, kita dapat menggunakannya untuk menghitung sudut
segitiga dengan sisi


Hasilnya rasional, yang tidak begitu mudah didapat jika kita
menggunakan trigonometri klasik.


\>$spread(a,a,4\*a/7)


$$\frac{6}{7}$$Ini adalah sudut dalam derajat.


\>degprint(arcsin(sqrt(6/7)))


    6747'32.44''

## Contoh lain

Sekarang, mari kita coba contoh yang lebih maju.


Kami mengatur tiga sudut segitiga sebagai berikut.


\>A&:=[1,2]; B&:=[4,3]; C&:=[0,4]; ...  
\>   setPlotRange(-1,5,1,7); ...  
\>   plotPoint(A,"A"); plotPoint(B,"B"); plotPoint(C,"C"); ...  
\>   plotSegment(B,A,"c"); plotSegment(A,C,"b"); plotSegment(C,B,"a"); ...  
\>   insimg;


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-072.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-072.png)

Menggunakan Pythogoras, mudah untuk menghitung jarak antara dua titik.
Saya pertama kali menggunakan jarak fungsi file Euler untuk geometri.
Jarak fungsi menggunakan geometri klasik.


\>$distance(A,B)


$$\sqrt{10}$$Euler juga mengandung fungsi untuk kuadran antara dua titik.


Dalam contoh berikut, karena c+b bukan a, maka segitiga itu bukan
persegi panjang.


\>c &= quad(A,B); $c, b &= quad(A,C); $b, a &= quad(B,C); $a,


$$10$$$$5$$$$17$$Pertama, mari kita hitung sudut tradisional. Fungsi computeAngle
menggunakan metode biasa berdasarkan hasil kali titik dua vektor.
Hasilnya adalah beberapa pendekatan floating point.


\>wb &= computeAngle(A,B,C); $wb, $(wb/pi\*180)()


$$\arccos \left(\frac{11}{\sqrt{10}\,\sqrt{17}}\right)$$    32.4711922908

Dengan menggunakan pensil dan kertas, kita dapat melakukan hal yang
sama dengan hukum silang. Kami memasukkan kuadran a, b, dan c ke dalam
hukum silang dan menyelesaikan x.


\>$crosslaw(a,b,c,x), $solve(%,x),


$$4=200\,\left(1-x\right)$$$$\left[ x=\frac{49}{50} \right] $$Yaitu, apa yang dilakukan oleh penyebaran fungsi yang didefinisikan
dalam "geometry.e".


\>sb &= spread(b,a,c); $sb


$$\frac{49}{170}$$Maxima mendapatkan hasil yang sama menggunakan trigonometri biasa,
jika kita memaksanya. Itu menyelesaikan istilah sin(arccos(...))
menjadi hasil pecahan. Sebagian besar siswa tidak dapat melakukan ini.


\>$sin(computeAngle(A,B,C))^2


$$\frac{49}{170}$$Setelah kita memiliki spread di B, kita dapat menghitung tinggi ha di
sisi a. Ingat bahwa


Menurut definisi.


\>ha &= c\*sb; $ha


$$\frac{49}{17}$$Gambar berikut telah dihasilkan dengan program geometri C.a.R., yang
dapat menggambar kuadrat dan menyebar.


image: (20) Rational_Geometry_CaR.png


Menurut definisi, panjang ha adalah akar kuadrat dari kuadratnya.


\>$sqrt(ha)


$$\frac{7}{\sqrt{17}}$$Sekarang kita dapat menghitung luas segitiga. Jangan lupa, bahwa kita
berhadapan dengan kuadrat!


\>$sqrt(ha)\*sqrt(a)/2


$$\frac{7}{2}$$Rumus determinan biasa menghasilkan hasil yang sama.


\>$areaTriangle(B,A,C)


$$\frac{7}{2}$$## The Heron Formula

Sekarang, mari kita selesaikan masalah ini secara umum!


\>&remvalue(a,b,c,sb,ha);


Pertama kita hitung spread di B untuk segitiga dengan sisi a, b, dan
c. Kemudian kita menghitung luas kuadrat ("quadrea"?), faktorkan
dengan Maxima, dan kita mendapatkan rumus Heron yang terkenal.


Memang, ini sulit dilakukan dengan pensil dan kertas.


\>$spread(b^2,c^2,a^2), $factor(%\*c^2\*a^2/4)


$$\frac{-c^4-\left(-2\,b^2-2\,a^2\right)\,c^2-b^4+2\,a^2\,b^2-a^4}{4
 \,a^2\,c^2}$$$$\frac{\left(-c+b+a\right)\,\left(c-b+a\right)\,\left(c+b-a\right)\,
 \left(c+b+a\right)}{16}$$## The Triple Spread Rule

Kerugian dari spread adalah mereka tidak lagi hanya menambahkan sudut
yang sama.


Namun, tiga spread dari sebuah segitiga memenuhi aturan "triple
spread" berikut.


\>&remvalue(sa,sb,sc); $triplespread(sa,sb,sc)


$$\left({\it sc}+{\it sb}+{\it sa}\right)^2=2\,\left({\it sc}^2+
 {\it sb}^2+{\it sa}^2\right)+4\,{\it sa}\,{\it sb}\,{\it sc}$$Aturan ini berlaku untuk setiap tiga sudut yang menambah 180 .


Sejak menyebar


sama, aturan triple spread juga benar, jika


Karena penyebaran sudut negatif adalah sama, aturan penyebaran rangkap
tiga juga berlaku, jika


Misalnya, kita dapat menghitung penyebaran sudut 60. Ini 3/4.
Persamaan memiliki solusi kedua, bagaimanapun, di mana semua spread
adalah 0.


\>$solve(triplespread(x,x,x),x)


$$\left[ x=\frac{3}{4} , x=0 \right] $$Sebaran 90 jelas 1. Jika dua sudut dijumlahkan menjadi 90,
sebarannya menyelesaikan persamaan sebaran rangkap tiga dengan a,b,1.
Dengan perhitungan berikut kita mendapatkan a+b=1.


\>$triplespread(x,y,1), $solve(%,x)


$$\left(y+x+1\right)^2=2\,\left(y^2+x^2+1\right)+4\,x\,y$$$$\left[ x=1-y \right] $$Karena sebaran 180-t sama dengan sebaran t, rumus sebaran rangkap
tiga juga berlaku, jika satu sudut adalah jumlah atau selisih dua
sudut lainnya.


Jadi kita dapat menemukan penyebaran sudut berlipat ganda. Perhatikan
bahwa ada dua solusi lagi. Kami membuat ini fungsi.


\>$solve(triplespread(a,a,x),x), function doublespread(a) &= factor(rhs(%[1]))


$$\left[ x=4\,a-4\,a^2 , x=0 \right] $$    
                                - 4 (a - 1) a
    

## Angle Bisectors

This is the situation, we already know.


\>C&:=[0,0]; A&:=[4,0]; B&:=[0,3]; ...  
\>   setPlotRange(-1,5,-1,5); ...  
\>   plotPoint(A,"A"); plotPoint(B,"B"); plotPoint(C,"C"); ...  
\>   plotSegment(B,A,"c"); plotSegment(A,C,"b"); plotSegment(C,B,"a"); ...  
\>   insimg;


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-093.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-093.png)

Mari kita hitung panjang garis bagi sudut di A. Tetapi kita ingin
menyelesaikannya untuk umum a,b,c.


\>&remvalue(a,b,c);


Jadi pertama-tama kita hitung penyebaran sudut yang dibagi dua di A,
dengan menggunakan rumus sebaran rangkap tiga.


Masalah dengan rumus ini muncul lagi. Ini memiliki dua solusi. Kita
harus memilih yang benar. Solusi lainnya mengacu pada sudut terbelah
180 -wa.


\>$triplespread(x,x,a/(a+b)), $solve(%,x), sa2 &= rhs(%[1]); $sa2


$$\left(2\,x+\frac{a}{b+a}\right)^2=2\,\left(2\,x^2+\frac{a^2}{\left(
 b+a\right)^2}\right)+\frac{4\,a\,x^2}{b+a}$$$$\left[ x=\frac{-\sqrt{b}\,\sqrt{b+a}+b+a}{2\,b+2\,a} , x=\frac{
 \sqrt{b}\,\sqrt{b+a}+b+a}{2\,b+2\,a} \right] $$$$\frac{-\sqrt{b}\,\sqrt{b+a}+b+a}{2\,b+2\,a}$$Mari kita periksa persegi panjang Egyptian.


\>$sa2 with [a=3^2,b=4^2]


$$\frac{1}{10}$$Kami dapat mencetak sudut dalam Euler, setelah mentransfer penyebaran
ke radian.


\>wa2 := arcsin(sqrt(1/10)); degprint(wa2)


    1826'5.82''

Titik P adalah perpotongan garis bagi sudut dengan sumbu y.


\>P := [0,tan(wa2)\*4]


    [0,  1.33333]

\>plotPoint(P,"P"); plotSegment(A,P):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-098.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-098.png)

Mari kita periksa sudut dalam contoh spesifik kita.


\>computeAngle(C,A,P), computeAngle(P,A,B)


    0.321750554397
    0.321750554397

Sekarang kita hitung panjang garis bagi AP.


Kami menggunakan teorema sinus dalam segitiga APC. Teorema ini
menyatakan bahwa


berlaku dalam segitiga apa pun. Kuadratkan, itu diterjemahkan ke dalam
apa yang disebut "hukum penyebaran"


di mana a,b,c menunjukkan qudrances.


Karena spread CPA adalah 1-sa2, kita dapatkan darinya bisa/1=b/(1-sa2)
dan dapat menghitung bisa (kuadran dari garis-bagi sudut).


\>&factor(ratsimp(b/(1-sa2))); bisa &= %; $bisa


$$\frac{2\,b\,\left(b+a\right)}{\sqrt{b}\,\sqrt{b+a}+b+a}$$Mari kita periksa rumus ini untuk nilai-nilai Mesir kita.


\>sqrt(mxmeval("at(bisa,[a=3^2,b=4^2])")), distance(A,P)


    4.21637021356
    4.21637021356

Kita juga dapat menghitung P menggunakan rumus spread.


\>py&=factor(ratsimp(sa2\*bisa)); $py


$$-\frac{b\,\left(\sqrt{b}\,\sqrt{b+a}-b-a\right)}{\sqrt{b}\,\sqrt{b+
 a}+b+a}$$Nilainya sama dengan yang kita dapatkan dengan rumus trigonometri.


\>sqrt(mxmeval("at(py,[a=3^2,b=4^2])"))


    1.33333333333

## The Chord Angle

Perhatikan situasi berikut.


\>setPlotRange(1.2); ...  
\>   color(1); plotCircle(circleWithCenter([0,0],1)); ...  
\>   A:=[cos(1),sin(1)]; B:=[cos(2),sin(2)]; C:=[cos(6),sin(6)]; ...  
\>   plotPoint(A,"A"); plotPoint(B,"B"); plotPoint(C,"C"); ...  
\>   color(3); plotSegment(A,B,"c"); plotSegment(A,C,"b"); plotSegment(C,B,"a"); ...  
\>   color(1); O:=[0,0];  plotPoint(O,"0"); ...  
\>   plotSegment(A,O); plotSegment(B,O); plotSegment(C,O,"r"); ...  
\>   insimg;


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-101.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-101.png)

Kita dapat menggunakan Maxima untuk menyelesaikan rumus penyebaran
rangkap tiga untuk sudut-sudut di pusat O untuk r. Jadi kita
mendapatkan rumus untuk jari-jari kuadrat dari pericircle dalam hal
kuadrat dari sisi.


Kali ini, Maxima menghasilkan beberapa nol kompleks, yang kita
abaikan.


\>&remvalue(a,b,c,r); // hapus nilai-nilai sebelumnya untuk perhitungan baru

\>rabc &= rhs(solve(triplespread(spread(b,r,r),spread(a,r,r),spread(c,r,r)),r)[4]); $rabc


$$-\frac{a\,b\,c}{c^2-2\,b\,c+a\,\left(-2\,c-2\,b\right)+b^2+a^2}$$Kita dapat menjadikannya sebagai fungsi Euler.


\>function periradius(a,b,c) &= rabc;


Mari kita periksa hasilnya untuk poin A,B,C.


\>a:=quadrance(B,C); b:=quadrance(A,C); c:=quadrance(A,B);


Jari-jarinya memang 1.


\>periradius(a,b,c)


    1

Faktanya, spread CBA hanya bergantung pada b dan c. Ini adalah teorema
sudut chord.


\>$spread(b,a,c)\*rabc | ratsimp


$$\frac{b}{4}$$Sebenarnya spreadnya adalah b/(4r), dan kita melihat bahwa sudut chord
dari chord b adalah setengah dari sudut pusat.


\>$doublespread(b/(4\*r))-spread(b,r,r) | ratsimp


$$0$$# Contoh 6: Jarak Minimal pada Bidang

## Preliminary remark

Fungsi yang, ke titik M di bidang, menetapkan jarak AM antara titik
tetap A dan M, memiliki garis level yang agak sederhana: lingkaran
berpusat di A.


\>&remvalue();

\>A=[-1,-1];

\>function d1(x,y):=sqrt((x-A[1])^2+(y-A[2])^2)

\>fcontour("d1",xmin=-2,xmax=0,ymin=-2,ymax=0,hue=1, ...  
\>   title="If you see ellipses, please set your window square"):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-105.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-105.png)

dan grafiknya agak sederhana untuk: bagian atas kerucut:


\>plot3d("d1",xmin=-2,xmax=0,ymin=-2,ymax=0):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-106.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-106.png)

Tentu saja minimal 0 dicapai di A.


## Dua poin

Sekarang kita lihat fungsi MA+MB dimana A dan B adalah dua titik
(tetap). Ini adalah "fakta yang diketahui" bahwa kurva level adalah
elips, titik fokusnya adalah A dan B; kecuali untuk AB minimum yang
konstan pada segmen [AB]:


\>B=[1,-1];

\>function d2(x,y):=d1(x,y)+sqrt((x-B[1])^2+(y-B[2])^2)

\>fcontour("d2",xmin=-2,xmax=2,ymin=-3,ymax=1,hue=1):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-107.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-107.png)

Grafiknya lebih menarik:


\>plot3d("d2",xmin=-2,xmax=2,ymin=-3,ymax=1):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-108.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-108.png)

Pembatasan garis (AB) lebih terkenal:


\>plot2d("abs(x+1)+abs(x-1)",xmin=-3,xmax=3):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-109.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-109.png)

## Tiga poin



Sekarang hal-hal yang kurang sederhana: Ini sedikit kurang terkenal
bahwa MA+MB+MC mencapai minimum pada satu titik pesawat tetapi untuk
menentukan itu kurang sederhana:


1) Jika salah satu sudut segitiga ABC lebih dari 120 (katakanlah di
A), maka minimum dicapai pada titik ini (misalnya AB+AC).


Contoh:


\>C=[-4,1];

\>function d3(x,y):=d2(x,y)+sqrt((x-C[1])^2+(y-C[2])^2)

\>plot3d("d3",xmin=-5,xmax=3,ymin=-4,ymax=4);

\>insimg;


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-110.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-110.png)

\>fcontour("d3",xmin=-4,xmax=1,ymin=-2,ymax=2,hue=1,title="The minimum is on A");

\>P=(A\_B\_C\_A)'; plot2d(P[1],P[2],add=1,color=12);

\>insimg;


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-111.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-111.png)

2) Tetapi jika semua sudut segitiga ABC kurang dari 120 , minimumnya
adalah pada titik F di bagian dalam segitiga, yang merupakan
satu-satunya titik yang melihat sisi-sisi ABC dengan sudut yang sama
(maka masing-masing 120  ):


\>C=[-0.5,1];

\>plot3d("d3",xmin=-2,xmax=2,ymin=-2,ymax=2):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-112.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-112.png)

\>fcontour("d3",xmin=-2,xmax=2,ymin=-2,ymax=2,hue=1,title="The Fermat point");

\>P=(A\_B\_C\_A)'; plot2d(P[1],P[2],add=1,color=12);

\>insimg;


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-113.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-113.png)

Merupakan kegiatan yang menarik untuk mewujudkan gambar di atas dengan
perangkat lunak geometri; misalnya, saya tahu soft yang ditulis di
Jawa yang memiliki instruksi "garis kontur" ...


Semua ini di atas telah ditemukan oleh seorang hakim Perancis bernama
Pierre de Fermat; dia menulis surat kepada dilettants lain seperti
pendeta Marin Mersenne dan Blaise Pascal yang bekerja di pajak
penghasilan. Jadi titik unik F sedemikian rupa sehingga FA+FB+FC
minimal, disebut titik Fermat segitiga. Tetapi tampaknya beberapa
tahun sebelumnya, Torriccelli Italia telah menemukan titik ini sebelum
Fermat melakukannya! Bagaimanapun tradisinya adalah mencatat poin ini
F...


## Empat poin

Langkah selanjutnya adalah menambahkan 4 titik D dan mencoba
meminimalkan MA+MB+MC+MD; katakan bahwa Anda adalah operator TV kabel
dan ingin mencari di bidang mana Anda harus meletakkan antena sehingga
Anda dapat memberi makan empat desa dan menggunakan panjang kabel
sesedikit mungkin!


\>D=[1,1];

\>function d4(x,y):=d3(x,y)+sqrt((x-D[1])^2+(y-D[2])^2)

\>plot3d("d4",xmin=-1.5,xmax=1.5,ymin=-1.5,ymax=1.5):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-114.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-114.png)

\>fcontour("d4",xmin=-1.5,xmax=1.5,ymin=-1.5,ymax=1.5,hue=1);

\>P=(A\_B\_C\_D)'; plot2d(P[1],P[2],points=1,add=1,color=12);

\>insimg;


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-115.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-115.png)

Masih ada minimum dan tidak tercapai di salah satu simpul A, B, C atau
D:


\>function f(x):=d4(x[1],x[2])

\>neldermin("f",[0.2,0.2])


    [0.142858,  0.142857]

Tampaknya dalam kasus ini, koordinat titik optimal adalah rasional
atau mendekati rasional...


Sekarang ABCD adalah persegi, kami berharap bahwa titik optimal akan
menjadi pusat ABCD:


\>C=[-1,1];

\>plot3d("d4",xmin=-1,xmax=1,ymin=-1,ymax=1):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-116.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-116.png)

\>fcontour("d4",xmin=-1.5,xmax=1.5,ymin=-1.5,ymax=1.5,hue=1);

\>P=(A\_B\_C\_D)'; plot2d(P[1],P[2],add=1,color=12,points=1);

\>insimg;


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-117.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-117.png)

# Contoh 7: Bola Dandelin dengan Povray

Anda dapat menjalankan demonstrasi ini, jika Anda telah menginstal
Povray, dan pvengine.exe di jalur program.


Pertama kita hitung jari-jari bola.


Jika Anda melihat gambar di bawah, Anda melihat bahwa kita membutuhkan
dua lingkaran yang menyentuh dua garis yang membentuk kerucut, dan
satu garis yang membentuk bidang yang memotong kerucut.


Kami menggunakan file geometri.e dari Euler untuk ini.


\>load geometry;


Pertama dua garis yang membentuk kerucut.


\>g1 &= lineThrough([0,0],[1,a])


    
                                 [- a, 1, 0]
    

\>g2 &= lineThrough([0,0],[-1,a])


    
                                [- a, - 1, 0]
    

Kemudian saya baris ketiga.


\>g &= lineThrough([-1,0],[1,1])


    
                                 [- 1, 2, 1]
    

Kami merencanakan semuanya sejauh ini.


\>setPlotRange(-1,1,0,2);

\>color(black); plotLine(g(),"")

\>a:=2; color(blue); plotLine(g1(),""), plotLine(g2(),""):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-118.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-118.png)

Sekarang kita ambil titik umum pada sumbu y.


\>P &= [0,u]


    
                                    [0, u]
    

Hitung jarak ke g1.


\>d1 &= distance(P,projectToLine(P,g1)); $d1


$$\sqrt{\left(\frac{a^2\,u}{a^2+1}-u\right)^2+\frac{a^2\,u^2}{\left(a
 ^2+1\right)^2}}$$Hitung jarak ke g.


\>d &= distance(P,projectToLine(P,g)); $d


$$\sqrt{\left(\frac{u+2}{5}-u\right)^2+\frac{\left(2\,u-1\right)^2}{
 25}}$$Dan temukan pusat kedua lingkaran yang jaraknya sama.


\>sol &= solve(d1^2=d^2,u); $sol


$$\left[ u=\frac{-\sqrt{5}\,\sqrt{a^2+1}+2\,a^2+2}{4\,a^2-1} , u=
 \frac{\sqrt{5}\,\sqrt{a^2+1}+2\,a^2+2}{4\,a^2-1} \right] $$Ada dua solusi.


Kami mengevaluasi solusi simbolis, dan menemukan kedua pusat, dan
kedua jarak.


\>u := sol()


    [0.333333,  1]

\>dd := d()


    [0.149071,  0.447214]

Plot lingkaran ke dalam gambar.


\>color(red);

\>plotCircle(circleWithCenter([0,u[1]],dd[1]),"");

\>plotCircle(circleWithCenter([0,u[2]],dd[2]),"");

\>insimg;


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-122.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-122.png)

## Plot with Povray

Selanjutnya kami merencanakan semuanya dengan Povray. Perhatikan bahwa
Anda mengubah perintah apa pun dalam urutan perintah Povray berikut,
dan menjalankan kembali semua perintah dengan Shift-Return.


Pertama kita memuat fungsi povray.


\>load povray;

\>defaultpovray="C:\\Program Files\\POV-Ray\\v3.7\\bin\\pvengine.exe"


    C:\Program Files\POV-Ray\v3.7\bin\pvengine.exe

Kami mengatur adegan dengan tepat.


\>povstart(zoom=11,center=[0,0,0.5],height=10,angle=140);


Selanjutnya kita menulis dua bidang ke file Povray.


\>writeln(povsphere([0,0,u[1]],dd[1],povlook(red)));

\>writeln(povsphere([0,0,u[2]],dd[2],povlook(red)));


Dan kerucutnya, transparan.


\>writeln(povcone([0,0,0],0,[0,0,a],1,povlook(lightgray,1)));


Kami menghasilkan pesawat terbatas pada kerucut.


\>gp=g();

\>pc=povcone([0,0,0],0,[0,0,a],1,"");

\>vp=[gp[1],0,gp[2]]; dp=gp[3];

\>writeln(povplane(vp,dp,povlook(blue,0.5),pc));


Sekarang kita menghasilkan dua titik pada lingkaran, di mana bola
menyentuh kerucut.


\>function turnz(v) := return [-v[2],v[1],v[3]]

\>P1=projectToLine([0,u[1]],g1()); P1=turnz([P1[1],0,P1[2]]);

\>writeln(povpoint(P1,povlook(yellow)));

\>P2=projectToLine([0,u[2]],g1()); P2=turnz([P2[1],0,P2[2]]);

\>writeln(povpoint(P2,povlook(yellow)));


Kemudian kami menghasilkan dua titik di mana bola menyentuh bidang.
Ini adalah fokus dari elips.


\>P3=projectToLine([0,u[1]],g()); P3=[P3[1],0,P3[2]];

\>writeln(povpoint(P3,povlook(yellow)));

\>P4=projectToLine([0,u[2]],g()); P4=[P4[1],0,P4[2]];

\>writeln(povpoint(P4,povlook(yellow)));


Selanjutnya kita hitung perpotongan P1P2 dengan bidang.


\>t1=scalp(vp,P1)-dp; t2=scalp(vp,P2)-dp; P5=P1+t1/(t1-t2)\*(P2-P1);

\>writeln(povpoint(P5,povlook(yellow)));


Kami menghubungkan titik-titik dengan segmen garis.


\>writeln(povsegment(P1,P2,povlook(yellow)));

\>writeln(povsegment(P5,P3,povlook(yellow)));

\>writeln(povsegment(P5,P4,povlook(yellow)));


Sekarang kita menghasilkan pita abu-abu, di mana bola menyentuh
kerucut.


\>pcw=povcone([0,0,0],0,[0,0,a],1.01);

\>pc1=povcylinder([0,0,P1[3]-defaultpointsize/2],[0,0,P1[3]+defaultpointsize/2],1);

\>writeln(povintersection([pcw,pc1],povlook(gray)));

\>pc2=povcylinder([0,0,P2[3]-defaultpointsize/2],[0,0,P2[3]+defaultpointsize/2],1);

\>writeln(povintersection([pcw,pc2],povlook(gray)));


Mulai program Povray.


\>povend();


    exec:
        return _exec(program,param,dir,print,hidden,wait);
    povray:
        exec(program,params,defaulthome);
    Try "trace errors" to inspect local variables after errors.
    povend:
        povray(file,w,h,aspect,exit); 

Untuk mendapatkan Anaglyph ini kita perlu memasukkan semuanya ke dalam
fungsi scene. Fungsi ini akan digunakan dua kali kemudian.


\>function scene () ...


    global a,u,dd,g,g1,defaultpointsize;
    writeln(povsphere([0,0,u[1]],dd[1],povlook(red)));
    writeln(povsphere([0,0,u[2]],dd[2],povlook(red)));
    writeln(povcone([0,0,0],0,[0,0,a],1,povlook(lightgray,1)));
    gp=g();
    pc=povcone([0,0,0],0,[0,0,a],1,"");
    vp=[gp[1],0,gp[2]]; dp=gp[3];
    writeln(povplane(vp,dp,povlook(blue,0.5),pc));
    P1=projectToLine([0,u[1]],g1()); P1=turnz([P1[1],0,P1[2]]);
    writeln(povpoint(P1,povlook(yellow)));
    P2=projectToLine([0,u[2]],g1()); P2=turnz([P2[1],0,P2[2]]);
    writeln(povpoint(P2,povlook(yellow)));
    P3=projectToLine([0,u[1]],g()); P3=[P3[1],0,P3[2]];
    writeln(povpoint(P3,povlook(yellow)));
    P4=projectToLine([0,u[2]],g()); P4=[P4[1],0,P4[2]];
    writeln(povpoint(P4,povlook(yellow)));
    t1=scalp(vp,P1)-dp; t2=scalp(vp,P2)-dp; P5=P1+t1/(t1-t2)*(P2-P1);
    writeln(povpoint(P5,povlook(yellow)));
    writeln(povsegment(P1,P2,povlook(yellow)));
    writeln(povsegment(P5,P3,povlook(yellow)));
    writeln(povsegment(P5,P4,povlook(yellow)));
    pcw=povcone([0,0,0],0,[0,0,a],1.01);
    pc1=povcylinder([0,0,P1[3]-defaultpointsize/2],[0,0,P1[3]+defaultpointsize/2],1);
    writeln(povintersection([pcw,pc1],povlook(gray)));
    pc2=povcylinder([0,0,P2[3]-defaultpointsize/2],[0,0,P2[3]+defaultpointsize/2],1);
    writeln(povintersection([pcw,pc2],povlook(gray)));
    endfunction
</pre>
Anda membutuhkan kacamata merah/sian untuk menghargai efek berikut.


\>povanaglyph("scene",zoom=11,center=[0,0,0.5],height=10,angle=140);


    Command was not allowed!
    exec:
        return _exec(program,param,dir,print,hidden,wait);
    povray:
        exec(program,params,defaulthome);
    Try "trace errors" to inspect local variables after errors.
    povanaglyph:
        povray(currentfile,w,h,aspect,exit); 

# Contoh 8: Geometri Bumi

Dalam buku catatan ini, kami ingin melakukan beberapa perhitungan
sferis. Fungsi-fungsi tersebut terdapat dalam file "spherical.e" di
folder contoh. Kita perlu memuat file itu terlebih dahulu.


\>load "spherical.e";


Untuk memasukkan posisi geografis, kami menggunakan vektor dengan dua
koordinat dalam radian (utara dan timur, nilai negatif untuk selatan
dan barat). Berikut koordinat Kampus FMIPA UNY.


\>FMIPA=[rad(-7,-46.467),rad(110,23.05)]


    [-0.13569,  1.92657]

Anda dapat mencetak posisi ini dengan sposprint (cetak posisi
spherical).


\>sposprint(FMIPA) // posisi garis lintang dan garis bujur FMIPA UNY


    S 746.467' E 11023.050'

Mari kita tambahkan dua kota lagi, Solo dan Semarang.


\>Solo=[rad(-7,-34.333),rad(110,49.683)]; Semarang=[rad(-6,-59.05),rad(110,24.533)];

\>sposprint(Solo), sposprint(Semarang),


    S 734.333' E 11049.683'
    S 659.050' E 11024.533'

Pertama kita menghitung vektor dari satu ke yang lain pada bola ideal.
Vektor ini [pos,jarak] dalam radian. Untuk menghitung jarak di bumi,
kita kalikan dengan jari-jari bumi pada garis lintang 7.


\>br=svector(FMIPA,Solo); degprint(br[1]), br[2]\*rearth(7)-\>km // perkiraan jarak FMIPA-Solo


    6520'26.60''
    53.8945384608

Ini adalah perkiraan yang baik. Rutinitas berikut menggunakan
perkiraan yang lebih baik. Pada jarak yang begitu pendek hasilnya
hampir sama.


\>esdist(FMIPA,Semarang)-\>" km" // perkiraan jarak FMIPA-Semarang


    Commands must be separated by semicolon or comma!
    Found:  // perkiraan jarak FMIPA-Semarang (character 32)
    You can disable this in the Options menu.
    Error in:
    esdist(FMIPA,Semarang)-&gt;" km" // perkiraan jarak FMIPA-Semaran ...
                                 ^

Ada fungsi untuk heading, dengan mempertimbangkan bentuk elips bumi.
Sekali lagi, kami mencetak dengan cara yang canggih.


\>sdegprint(esdir(FMIPA,Solo))


         65.34

Sudut segitiga melebihi 180 pada bola.


\>asum=sangle(Solo,FMIPA,Semarang)+sangle(FMIPA,Solo,Semarang)+sangle(FMIPA,Semarang,Solo); degprint(asum)


    1800'10.77''

Ini dapat digunakan untuk menghitung luas segitiga. Catatan: Untuk
segitiga kecil, ini tidak akurat karena kesalahan pengurangan dalam
asum-pi.


\>(asum-pi)\*rearth(48)^2-\>" km^2" // perkiraan luas segitiga FMIPA-Solo-Semarang


    Commands must be separated by semicolon or comma!
    Found:  // perkiraan luas segitiga FMIPA-Solo-Semarang (character 32)
    You can disable this in the Options menu.
    Error in:
    (asum-pi)*rearth(48)^2-&gt;" km^2" // perkiraan luas segitiga FM ...
                                    ^

Ada fungsi untuk ini, yang menggunakan garis lintang rata-rata
segitiga untuk menghitung jari-jari bumi, dan menangani kesalahan
pembulatan untuk segitiga yang sangat kecil.


\>esarea(Solo,FMIPA,Semarang)-\>" km^2", //perkiraan yang sama dengan fungsi esarea()


    2123.64310526 km^2

Kita juga dapat menambahkan vektor ke posisi. Sebuah vektor berisi
heading dan jarak, keduanya dalam radian. Untuk mendapatkan sebuah
vektor, kita menggunakan vektor. Untuk menambahkan vektor ke posisi,
kami menggunakan vektor sadd.


\>v=svector(FMIPA,Solo); sposprint(saddvector(FMIPA,v)), sposprint(Solo),


    S 734.333' E 11049.683'
    S 734.333' E 11049.683'

Fungsi-fungsi ini mengasumsikan bola yang ideal. Hal yang sama di
bumi.


\>sposprint(esadd(FMIPA,esdir(FMIPA,Solo),esdist(FMIPA,Solo))), sposprint(Solo),


    S 734.333' E 11049.683'
    S 734.333' E 11049.683'

Mari kita beralih ke contoh yang lebih besar, Tugu Jogja dan Monas
Jakarta (menggunakan Google Earth untuk mencari koordinatnya).


\>Tugu=[-7.7833,110.3661]; Monas=[-6.175,106.811944];

\>sposprint(Tugu), sposprint(Monas)


    S 746.998' E 11021.966'
    S 610.500' E 10648.717'

Menurut Google Earth, jaraknya adalah 429,66 km. Kami mendapatkan
pendekatan yang baik.


\>esdist(Tugu,Monas)-\>" km" // perkiraan jarak Tugu Jogja - Monas Jakarta


    Commands must be separated by semicolon or comma!
    Found:  // perkiraan jarak Tugu Jogja - Monas Jakarta (character 32)
    You can disable this in the Options menu.
    Error in:
    esdist(Tugu,Monas)-&gt;" km" // perkiraan jarak Tugu Jogja - Mona ...
                             ^

Judulnya sama dengan judul yang dihitung di Google Earth.


\>degprint(esdir(Tugu,Monas))


    29417'2.85''

Namun, kita tidak lagi mendapatkan posisi target yang tepat, jika kita
menambahkan heading dan distance ke posisi semula. Hal ini terjadi,
karena kita tidak menghitung fungsi invers secara tepat, tetapi
mengambil perkiraan jari-jari bumi di sepanjang jalan.


\>sposprint(esadd(Tugu,esdir(Tugu,Monas),esdist(Tugu,Monas)))


    S 610.500' E 10648.717'

Namun, kesalahannya tidak besar.


\>sposprint(Monas),


    S 610.500' E 10648.717'

Tentu kita tidak bisa berlayar dengan tujuan yang sama dari satu
tujuan ke tujuan lainnya, jika kita ingin menempuh jalur terpendek.
Bayangkan, Anda terbang NE mulai dari titik mana pun di bumi. Kemudian
Anda akan berputar ke kutub utara. Lingkaran besar tidak mengikuti
heading yang konstan!


Perhitungan berikut menunjukkan bahwa kami jauh dari tujuan yang
benar, jika kami menggunakan pos yang sama selama perjalanan kami.


\>dist=esdist(Tugu,Monas); hd=esdir(Tugu,Monas);


Sekarang kita tambahkan 10 kali sepersepuluh dari jarak, menggunakan
pos ke Monas, kita sampai di Tugu.


\>p=Tugu; loop 1 to 10; p=esadd(p,hd,dist/10); end;


Hasilnya jauh.


\>sposprint(p), skmprint(esdist(p,Monas))


    S 611.250' E 10648.372'
         1.529km

Sebagai contoh lain, mari kita ambil dua titik di bumi pada garis
lintang yang sama.


\>P1=[30,10]; P2=[30,50];


Jalur terpendek dari P1 ke P2 bukanlah lingkaran dengan garis lintang
30, melainkan jalur terpendek yang dimulai 10 lebih jauh ke utara di
P1.


\>sdegprint(esdir(P1,P2))


         79.69

Tapi, jika kita mengikuti pembacaan kompas ini, kita akan berputar ke
kutub utara! Jadi kita harus menyesuaikan arah kita di sepanjang
jalan. Untuk tujuan kasar, kami menyesuaikannya pada 1/10 dari total
jarak.


\>p=P1;  dist=esdist(P1,P2); ...  
\>     loop 1 to 10; dir=esdir(p,P2); sdegprint(dir), p=esadd(p,dir,dist/10); end;


         79.69
         81.67
         83.71
         85.78
         87.89
         90.00
         92.12
         94.22
         96.29
         98.33

Jaraknya tidak tepat, karena kita akan menambahkan sedikit kesalahan,
jika kita mengikuti heading yang sama terlalu lama.


\>skmprint(esdist(p,P2))


         0.203km

Kami mendapatkan perkiraan yang baik, jika kami menyesuaikan pos
setelah setiap 1/100 dari total jarak dari Tugu ke Monas.


\>p=Tugu; dist=esdist(Tugu,Monas); ...  
\>     loop 1 to 100; p=esadd(p,esdir(p,Monas),dist/100); end;

\>skmprint(esdist(p,Monas))


         0.000km

Untuk keperluan navigasi, kita bisa mendapatkan urutan posisi GPS di
sepanjang lingkaran besar menuju Monas dengan fungsi navigasi.


\>load spherical; v=navigate(Tugu,Monas,10); ...  
\>     loop 1 to rows(v); sposprint(v[#]), end;


    S 746.998' E 11021.966'
    S 737.422' E 1100.573'
    S 727.829' E 10939.196'
    S 718.219' E 10917.834'
    S 78.592' E 10856.488'
    S 658.948' E 10835.157'
    S 649.289' E 10813.841'
    S 639.614' E 10752.539'
    S 629.924' E 10731.251'
    S 620.219' E 1079.977'
    S 610.500' E 10648.717'

Kami menulis sebuah fungsi, yang memplot bumi, dua posisi, dan posisi
di antaranya.


\>function testplot ...


    useglobal;
    plotearth;
    plotpos(Tugu,"Tugu Jogja"); plotpos(Monas,"Tugu Monas");
    plotposline(v);
    endfunction
</pre>
Sekarang rencanakan semuanya.


\>plot3d("testplot",angle=25, height=6,\>own,\>user,zoom=4):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-123.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-123.png)

Atau gunakan plot3d untuk mendapatkan tampilan anaglyph. Ini terlihat
sangat bagus dengan kacamata merah/sian.


\>plot3d("testplot",angle=25,height=6,distance=5,own=1,anaglyph=1,zoom=4):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-124.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-124.png)

# Latihan

1. Gambarlah segi-n beraturan jika diketahui titik pusat O, n, dan
jarak titik pusat ke titik-titik sudut segi-n tersebut (jari-jari
lingkaran luar segi-n), r.


Petunjuk:


* 
Besar sudut pusat yang menghadap masing-masing sisi segi-n adalah
* (360/n).

* 
Titik-titik sudut segi-n merupakan perpotongan lingkaran luar segi-n
* dan garis-garis yang melalui pusat dan saling membentuk sudut sebesar
* kelipatan (360/n).

* 
Untuk n ganjil, pilih salah satu titik sudut adalah di atas.

* 
Untuk n genap, pilih 2 titik di kanan dan kiri lurus dengan titik
* pusat.

* 
Anda dapat menggambar segi-3, 4, 5, 6, 7, dst beraturan.


2. Gambarlah suatu parabola yang melalui 3 titik yang diketahui.


Petunjuk:


- Misalkan persamaan parabolanya y= ax^2+bx+c.


- Substitusikan koordinat titik-titik yang diketahui ke persamaan
tersebut.


- Selesaikan SPL yang terbentuk untuk mendapatkan nilai-nilai a, b, c.


3. Gambarlah suatu segi-4 yang diketahui keempat titik sudutnya,
misalnya A, B, C, D.


   - Tentukan apakah segi-4 tersebut merupakan segi-4 garis singgung
(sisinya-sisintya merupakan garis singgung lingkaran yang sama yakni
lingkaran dalam segi-4 tersebut).


   - Suatu segi-4 merupakan segi-4 garis singgung apabila keempat
garis bagi sudutnya bertemu di satu titik.


   - Jika segi-4 tersebut merupakan segi-4 garis singgung, gambar
lingkaran dalamnya.


   - Tunjukkan bahwa syarat suatu segi-4 merupakan segi-4 garis
singgung apabila hasil kali panjang sisi-sisi yang berhadapan sama.


4. Gambarlah suatu ellips jika diketahui kedua titik fokusnya,
misalnya P dan Q. Ingat ellips dengan fokus P dan Q adalah tempat
kedudukan titik-titik yang jumlah jarak ke P dan ke Q selalu sama
(konstan).


5. Gambarlah suatu hiperbola jika diketahui kedua titik fokusnya,
misalnya P dan Q. Ingat ellips dengan fokus P dan Q adalah tempat
kedudukan titik-titik yang selisih jarak ke P dan ke Q selalu sama
(konstan).


## JAWABAN

1. Gambarlah segi-n beraturan jika diketahui titik pusat O, n, dan
jarak titik pusat ke titik-titik sudut segi-n tersebut (jari-jari
lingkaran luar segi-n), r.


\>load geometry


    Numerical and symbolic geometry.

\>setPlotRange(-3.5,3.5,-3.5,3.5);

\>A=[-2,-2]; plotPoint(A,"A");

\>B=[2,-2]; plotPoint(B,"B");

\>C=[0,3]; plotPoint(C,"C");

\>plotSegment(A,B,"c");

\>plotSegment(B,C,"a");

\>plotSegment(A,C,"b");

\>aspect(1):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-125.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-125.png)

\>c=circleThrough(A,B,C);

\>R=getCircleRadius(c);

\>O=getCircleCenter(c);

\>plotPoint(O,"O");

\>l=angleBisector(A,C,B);

\>color(2); plotLine(l); color(1);

\>plotCircle(c,"Lingkaran luar segitiga ABC"):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-126.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-126.png)

2. Gambarlah suatu parabola yang melalui 3 titik yang diketahui.


\>load geometry;

\>setPlotRange(5); P=[2,0]; Q=[4,0]; R=[0,-4];

\>plotPoint(P,"P"); plotPoint(Q,"Q"); plotPoint(R,"R"):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-127.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-127.png)

\>sol &= solve([a+b=-c,16\*a+4\*b=-c,c=-4],[a,b,c])


    
                         [[a = - 1, b = 5, c = - 4]]
    

\>function y&=-x^2+5\*x-4


    
                                   2
                                - x  + 5 x - 4
    

\>plot2d("-x^2+5\*x-4",-5,5,-5,5):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-128.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-128.png)

3. Gambarlah suatu segi-4 yang diketahui keempat titik sudutnya,
misalnya A, B, C, D.


\>load geometry


    Numerical and symbolic geometry.

\>setPlotRange(-4.5,4.5,-4.5,4.5);

\>A=[-3,-3]; plotPoint(A,"A");

\>B=[3,-3]; plotPoint(B,"B");

\>C=[3,3]; plotPoint(C,"C");

\>D=[-3,3]; plotPoint(D,"D");

\>plotSegment(A,B,"");

\>plotSegment(B,C,"");

\>plotSegment(C,D,"");

\>plotSegment(A,D,"");

\>aspect(1):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-129.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-129.png)

\>l=angleBisector(A,B,C);

\>m=angleBisector(B,C,D);

\>P=lineIntersection(l,m);

\>color(5); plotLine(l); plotLine(m); color(1);

\>plotPoint(P,"P"):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-130.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-130.png)

Dari gambar diatas terlihat bahwa keempat garis bagi sudutnya bertemu
di satu titik yaitu titik P.


\>r=norm(P-projectToLine(P,lineThrough(A,B)));

\>plotCircle(circleWithCenter(P,r),"Lingkaran dalam segiempat ABCD"):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-131.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-131.png)

Dari gambar diatas, terlihat bahwa sisi-sisinya merupakan garis
singgung lingkaran yang sama yaitu lingkaran dalam segiempat. Akan
ditunjukkan bahwa hasil kali panjang sisi-sisi yang berhadapan sama.


\>AB=norm(A-B) //panjang sisi AB


    6

\>CD=norm(C-D) //panjang sisi CD


    6

\>AD=norm(A-D) //panjang sisi AD


    6

\>BC=norm(B-C) //panjang sisi BC


    6

\>AB.CD


    36

\>AD.BC


    36

Terbukti bahwa hasil kali panjang sisi-sisi yang berhadapan sama yaitu
36. Jadi dapat dipastikan bahwa segiempat tersebut merupakan segiempat
garis singgung.


4. Gambarlah suatu ellips jika diketahui kedua titik fokusnya,
misalnya P dan Q. Ingat ellips dengan fokus P dan Q adalah tempat
kedudukan titik-titik yang jumlah jarak ke P dan ke Q selalu sama
(konstan).


Diketahui kedua titik fokus P = [-1,-1] dan Q = [1,-1]


\>$remvalue;

\>P=[-1,-1]; Q=[1,-1];

\>function d1(x,y):=sqrt((x-P[1])^2+(y-P[2])^2)

\>Q=[1,-1]; function d2(x,y):=sqrt((x-P[1])^2+(y-P[2])^2)+sqrt((x-Q[1])^2+(y-Q[2])^2);

\>fcontour("d2",xmin=-2,xmax=2,ymin=-4,ymax=4,hue=1):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-132.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-132.png)

\>plot3d("d2",xmin=-2,xmax=2,ymin=-4,ymax=4):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-133.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-133.png)

\>plot2d("abs(x+1)+abs(x-1)",xmin=-2,xmax=2):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-134.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-134.png)

5. Gambarlah suatu hiperbola jika diketahui kedua titik fokusnya,
misalnya P dan Q. Ingat ellips dengan fokus P dan Q adalah tempat
kedudukan titik-titik yang selisih jarak ke P dan ke Q selalu sama
(konstan).


\>P=[-1,-1]; Q=[1,-1];

\>function d1(x,y):=sqrt((x-p[1])^2+(y-p[2])^2)

\>Q=[1,-1]; function d2(x,y):=sqrt((x-P[1])^2+(y-P[2])^2)+sqrt((x+Q[1])^2+(y+Q[2])^2)

\>fcontour("d2",xmin=-2,xmax=2,ymin=-3,ymax=1,hue=1):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-135.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-135.png)

\>plot3d("d2",xmin=-2,xmax=2,ymin=-3,ymax=1):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-136.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-136.png)

\>plot2d("abs(x+1)+abs(x-1)",xmin=-3,xmax=3):


![images/Nur%20Alya%20Fadilah_23030630096_Geometry-137.png](images/Nur%20Alya%20Fadilah_23030630096_Geometry-137.png)

\section{EMT UNTUK STATSTKA}
# Nur Alya Fadilah_23030630096_Statistika
Nama  : Nur Alya Fadilah


NIM   : 23030630096


Kelas : Matematika E 2023


# EMT untuk Statistika

Dalam buku catatan ini, kami mendemonstrasikan plot statistik utama,
pengujian, dan distribusi di Euler.


Mari kita mulai dengan beberapa statistik deskriptif. Ini bukan
pengantar statistik. Jadi, Anda mungkin memerlukan beberapa latar
belakang untuk memahami detailnya.


Asumsikan pengukuran berikut. Kami ingin menghitung nilai rata-rata
dan standar deviasi yang diukur.


\>M=[1000,1004,998,997,1002,1001,998,1004,998,997]; ...  
\>   mean(M), dev(M),


    999.9
    2.72641400622

Kita dapat memplot plot kotak-dan-kumis untuk data. Dalam kasus kami
tidak ada outlier.


\>boxplot(M):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-001.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-001.png)

Kami menghitung probabilitas bahwa suatu nilai lebih besar dari 1005,
dengan asumsi nilai terukur dan distribusi normal.


Semua fungsi untuk distribusi di Euler diakhiri dengan ...dis dan
menghitung distribusi probabilitas kumulatif (CPF).


$$\text{normaldis(x,m,d)}=\int_{-\infty}^x \frac{1}{d\sqrt{2\pi}}e^{-\frac{1}{2 }(\frac{t-m}{d})^2}\ dt.$$Kami mencetak hasilnya dalam % dengan akurasi 2 digit menggunakan
fungsi cetak.


\>print((1-normaldis(1005,mean(M),dev(M)))\*100,2,unit=" %")


          3.07 %

Untuk contoh berikutnya, kami mengasumsikan jumlah pria berikut dalam
rentang ukuran yang diberikan.


\>r=155.5:4:187.5; v=[22,71,136,169,139,71,32,8];


Berikut adalah plot distribusinya.


\>plot2d(r,v,a=150,b=200,c=0,d=190,bar=1,style="\\/"):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-003.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-003.png)

Kita bisa memasukkan data mentah tersebut ke dalam sebuah tabel.


Tabel adalah metode untuk menyimpan data statistik. Tabel kita harus
berisi tiga kolom: Awal jangkauan, akhir jangkauan, jumlah orang dalam
jangkauan.


Tabel dapat dicetak dengan header. Kami menggunakan vektor string
untuk mengatur header.


\>T:=r[1:8]' | r[2:9]' | v'; writetable(T,labc=["from","to","count"])


          from        to     count
         155.5     159.5        22
         159.5     163.5        71
         163.5     167.5       136
         167.5     171.5       169
         171.5     175.5       139
         175.5     179.5        71
         179.5     183.5        32
         183.5     187.5         8

Jika kita membutuhkan nilai rata-rata dan statistik lain dari ukuran,
kita perlu menghitung titik tengah rentang. Kita dapat menggunakan dua
kolom pertama dari tabel kita untuk ini.


Sumbul "|" digunakan untuk memisahkan kolom, fungsi "writetable"
digunakan untuk menulis tabel, dengan opsion "labc" adalah untuk
menentukan header kolom.


\>(T[,1]+T[,2])/2 // the midpoint of each interval


            157.5 
            161.5 
            165.5 
            169.5 
            173.5 
            177.5 
            181.5 
            185.5 

Tetapi lebih mudah, untuk melipat rentang dengan vektor [1/2.1/2].


\>M=fold(r,[0.5,0.5])


    [157.5,  161.5,  165.5,  169.5,  173.5,  177.5,  181.5,  185.5]

Sekarang kita dapat menghitung mean dan deviasi sampel dengan
frekuensi yang diberikan.


\>{m,d}=meandev(M,v); m, d,


    169.901234568
    5.98912964449

Mari kita tambahkan distribusi normal dari nilai-nilai ke plot batang
di atas. Rumus untuk distribusi normal dengan mean m dan standar
deviasi d adalah:


$$y=\frac{1}{d\sqrt{2\pi}}e^{\frac{-(x-m)^2}{2d^2}}.$$Karena nilainya antara 0 dan 1, untuk memplotnya pada bar plot harus
dikalikan dengan 4 kali jumlah total data.


\>plot2d("qnormal(x,m,d)\*sum(v)\*4", ...  
\>     xmin=min(r),xmax=max(r),thickness=3,add=1):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-005.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-005.png)

# Tabel

Di direktori notebook ini Anda menemukan file dengan tabel. Data
tersebut mewakili hasil survei. Berikut adalah empat baris pertama
dari file tersebut. Data berasal dari buku online Jerman "Einfhrung
in die Statistik mit R" oleh A. Handl.


\>printfile("table.dat",4);


    Could not open the file
    table.dat
    for reading!
    Try "trace errors" to inspect local variables after errors.
    printfile:
        open(filename,"r");

Tabel berisi 7 kolom angka atau token (string). Kami ingin membaca
tabel dari file. Pertama, kami menggunakan terjemahan kami sendiri
untuk token.


Untuk ini, kami mendefinisikan set token. Fungsi strtokens()
mendapatkan vektor string token dari string yang diberikan.


\>mf:=["m","f"]; yn:=["y","n"]; ev:=strtokens("g vg m b vb");


Sekarang kita membaca tabel dengan terjemahan ini.


Argumen tok2, tok4 dll. adalah terjemahan dari kolom tabel. Argumen
ini tidak ada dalam daftar parameter readtable(), jadi Anda harus
menyediakannya dengan ":=".


\>{MT,hd}=readtable("table.dat",tok2:=mf,tok4:=yn,tok5:=ev,tok7:=yn);


    Could not open the file
    table.dat
    for reading!
    Try "trace errors" to inspect local variables after errors.
    readtable:
        if filename!=none then open(filename,"r"); endif;

\>load over statistics;


Untuk mencetak, kita perlu menentukan set token yang sama. Kami
mencetak empat baris pertama saja.


\>writetable(MT[1:4],labc=hd,wc=5,tok2:=mf,tok4:=yn,tok5:=ev,tok7:=yn);


    MT is not a variable!
    Error in:
    writetable(MT[1:4],labc=hd,wc=5,tok2:=mf,tok4:=yn,tok5:=ev,tok ...
                      ^

Titik "." mewakili nilai-nilai, yang tidak tersedia.


Jika kita tidak ingin menentukan token untuk terjemahan terlebih
dahulu, kita hanya perlu menentukan, kolom mana yang berisi token dan
bukan angka.


\>ctok=[2,4,5,7]; {MT,hd,tok}=readtable("table.dat",ctok=ctok);


    Could not open the file
    table.dat
    for reading!
    Try "trace errors" to inspect local variables after errors.
    readtable:
        if filename!=none then open(filename,"r"); endif;

Fungsi readtable() sekarang mengembalikan satu set token.


\>tok


    Variable tok not found!
    Error in:
    tok ...
       ^

Tabel berisi entri dari file dengan token yang diterjemahkan ke angka.


String khusus NA="." ditafsirkan sebagai "Tidak Tersedia", dan
mendapatkan NAN (bukan angka) dalam tabel. Terjemahan ini dapat diubah
dengan parameter NA, dan NAval.


\>MT[1]


    MT is not a variable!
    Error in:
    MT[1] ...
         ^

Berikut isi tabel dengan angka yang belum diterjemahkan.


\>writetable(MT,wc=5)


    Variable or function MT not found.
    Error in:
    writetable(MT,wc=5) ...
                 ^

Untuk kenyamanan, Anda dapat memasukkan output readtable() ke dalam
daftar.


\>Table={{readtable("table.dat",ctok=ctok)}};


    Could not open the file
    table.dat
    for reading!
    Try "trace errors" to inspect local variables after errors.
    readtable:
        if filename!=none then open(filename,"r"); endif;

Menggunakan kolom token yang sama dan token yang dibaca dari file,
kita dapat mencetak tabel. Kita dapat menentukan ctok, tok, dll. Atau
menggunakan daftar Tabel.


\>writetable(Table,ctok=ctok,wc=5);


    Variable or function Table not found.
    Error in:
    writetable(Table,ctok=ctok,wc=5); ...
                    ^

Fungsi tablecol() mengembalikan nilai kolom tabel, melewatkan setiap
baris dengan nilai NAN("." dalam file), dan indeks kolom, yang berisi
nilai-nilai ini.


\>{c,i}=tablecol(MT,[5,6]);


    Variable or function MT not found.
    Error in:
    {c,i}=tablecol(MT,[5,6]); ...
                     ^

Kita dapat menggunakan ini untuk mengekstrak kolom dari tabel untuk
tabel baru.


\>j=[1,5,6]; writetable(MT[i,j],labc=hd[j],ctok=[2],tok=tok)


    Variable or function i not found.
    Error in:
    j=[1,5,6]; writetable(MT[i,j],labc=hd[j],ctok=[2],tok=tok) ...
                              ^

Tentu saja, kita perlu mengekstrak tabel itu sendiri dari daftar Tabel
dalam kasus ini.


\>MT=Table[1];


    Table is not a variable!
    Error in:
    MT=Table[1]; ...
               ^

Tentu saja, kita juga dapat menggunakannya untuk menentukan nilai
rata-rata kolom atau nilai statistik lainnya.


\>mean(tablecol(MT,6))


    Variable or function MT not found.
    Error in:
    mean(tablecol(MT,6)) ...
                    ^

Fungsi getstatistics() mengembalikan elemen dalam vektor, dan
jumlahnya. Kami menerapkannya pada nilai "m" dan "f" di kolom kedua
tabel kami.


\>{xu,count}=getstatistics(tablecol(MT,2)); xu, count,


    Variable or function MT not found.
    Error in:
    {xu,count}=getstatistics(tablecol(MT,2)); xu, count, ...
                                        ^

Kami dapat mencetak hasilnya dalam tabel baru.


\>writetable(count',labr=tok[xu])


    Variable count not found!
    Error in:
    writetable(count',labr=tok[xu]) ...
                     ^

Fungsi selecttable() mengembalikan tabel baru dengan nilai dalam satu
kolom yang dipilih dari vektor indeks. Pertama kita mencari indeks
dari dua nilai kita di tabel token.


\>v:=indexof(tok,["g","vg"])


    Variable or function tok not found.
    Error in:
    v:=indexof(tok,["g","vg"]) ...
                  ^

Sekarang kita dapat memilih baris tabel, yang memiliki salah satu
nilai dalam v di baris ke-5.


\>MT1:=MT[selectrows(MT,5,v)]; i:=sortedrows(MT1,5);


    Variable or function MT not found.
    Error in:
    MT1:=MT[selectrows(MT,5,v)]; i:=sortedrows(MT1,5); ...
                         ^

Sekarang kita dapat mencetak tabel, dengan nilai yang diekstrak dan
diurutkan di kolom ke-5.


\>writetable(MT1[i],labc=hd,ctok=ctok,tok=tok,wc=7);


    Variable or function i not found.
    Error in:
    writetable(MT1[i],labc=hd,ctok=ctok,tok=tok,wc=7); ...
                    ^

Untuk statistik berikutnya, kami ingin menghubungkan dua kolom tabel.
Jadi kami mengekstrak kolom 2 dan 4 dan mengurutkan tabel.


\>i=sortedrows(MT,[2,4]);  ...  
\>     writetable(tablecol(MT[i],[2,4])',ctok=[1,2],tok=tok)


    Variable or function MT not found.
    Error in:
    i=sortedrows(MT,[2,4]);    writetable(tablecol(MT[i],[2,4])',c ...
                   ^

Dengan getstatistics(), kita juga dapat menghubungkan hitungan dalam
dua kolom tabel satu sama lain.


\>MT24=tabelkol(MT,[2,4]); ...  
\>   {xu1,xu2,count}=getstatistics(MT24[1],MT24[2]); ...  
\>   writetable(hitung,labr=tok[xu1],labc=tok[xu2])


    Variable or function MT not found.
    Error in:
    MT24=tabelkol(MT,[2,4]); {xu1,xu2,count}=getstatistics(MT24[1] ...
                    ^

Sebuah tabel dapat ditulis ke file.


\>filename="test.dat"; ...  
\>   writetable(count,labr=tok[xu1],labc=tok[xu2],file=filename);


    Variable or function count not found.
    Error in:
    filename="test.dat"; writetable(count,labr=tok[xu1],labc=tok[x ...
                                         ^

Kemudian kita bisa membaca tabel dari file.


\>{MT2,hd,tok2,hdr}=readtable(filename,\>clabs,\>rlabs); ...  
\>   writetable(MT2,labr=hdr,labc=hd)


    Could not open the file
    test.dat
    for reading!
    Try "trace errors" to inspect local variables after errors.
    readtable:
        if filename!=none then open(filename,"r"); endif;

Dan hapus filenya.


\>fileremove(filename);


# Distribusi

Dengan plot2d, ada metode yang sangat mudah untuk memplot distribusi
data eksperimen.


\>p=normal(1,1000); //1000 random normal-distributed sample p

\>plot2d(p,distribution=20,style="\\/"); // plot the random sample p

\>plot2d("qnormal(x,0,1)",add=1): // add the standard normal distribution plot


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-006.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-006.png)

Harap dicatat perbedaan antara plot batang (sampel) dan kurva normal
(distribusi nyata). Masukkan kembali tiga perintah untuk melihat hasil
pengambilan sampel lainnya.


Berikut adalah perbandingan 10 simulasi 1000 nilai terdistribusi
normal menggunakan apa yang disebut plot kotak. Plot ini menunjukkan
median, kuartil 25% dan 75%, nilai minimal dan maksimal, dan outlier.


\>p=normal(10,1000); boxplot(p):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-007.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-007.png)

Untuk menghasilkan bilangan bulat acak, Euler memiliki inrandom. Mari
kita simulasikan lemparan dadu dan plot distribusinya.


Kami menggunakan fungsi getmultiplicities(v,x), yang menghitung
seberapa sering elemen v muncul di x. Kemudian kita plot hasilnya
menggunakan columnplot().


\>k=intrandom(1,6000,6);  ...  
\>   columnsplot(getmultiplicities(1:6,k));  ...  
\>   ygrid(1000,color=red):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-008.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-008.png)

Sementara intrandom(n,m,k) mengembalikan bilangan bulat terdistribusi
seragam dari 1 ke k, dimungkinkan untuk menggunakan distribusi
bilangan bulat lainnya dengan randpint().


Dalam contoh berikut, probabilitas untuk 1,2,3 berturut-turut adalah
0,4,0,1,0,5.


\>randpint(1,1000,[0.4,0.1,0.5]); getmultiplicities(1:3,%)


    [378,  102,  520]

Euler dapat menghasilkan nilai acak dari lebih banyak distribusi. Coba
lihat referensinya.


Misalnya, kami mencoba distribusi eksponensial. Sebuah variabel acak
kontinu X dikatakan memiliki distribusi eksponensial, jika PDF-nya
diberikan oleh


$$f_X(x)=\lambda e^{-\lambda x},\quad x>0,\quad \lambda>0,$$

dengan parameter


$$\lambda=\frac{1}{\mu},\quad \mu \text{ adalah mean, dan dilambangkan dengan } X \sim \text{Exponential}(\lambda).$$\>plot2d(randexponential(1,1000,2),\>distribution):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-011.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-011.png)

Untuk banyak distribusi, Euler dapat menghitung fungsi distribusi dan
kebalikannya.


\>plot2d("normaldis",-4,4): 


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-012.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-012.png)

Berikut ini adalah salah satu cara untuk memplot kuantil.


\>plot2d("qnormal(x,1,1.5)",-4,6);  ...  
\>   plot2d("qnormal(x,1,1.5)",a=2,b=5,\>add,\>filled):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-013.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-013.png)

$$\text{normaldis(x,m,d)}=\int_{-\infty}^x \frac{1}{d\sqrt{2\pi}}e^{-\frac{1}{2}(\frac{t-m}{d})^2}\ dt.$$

Peluang berada di area hijau adalah sebagai berikut.


\>normaldis(5,1,1.5)-normaldis(2,1,1.5)


    0.248662156979

Ini dapat dihitung secara numerik dengan integral berikut.


$$\int_2^5 \frac{1}{1.5\sqrt{2\pi}}e^{-\frac{1}{2}(\frac{x-1}{1.5})^2}\ dx.$$\>gauss("qnormal(x,1,1.5)",2,5)


    0.248662156979

Mari kita bandingkan distribusi binomial dengan distribusi normal mean
dan deviasi yang sama. Fungsi invbindis() memecahkan interpolasi
linier antara nilai integer.


\>invbindis(0.95,1000,0.5), invnormaldis(0.95,500,0.5\*sqrt(1000))


    525.516721219
    526.007419394

Fungsi qdis() adalah densitas dari distribusi chi-kuadrat. Seperti
biasa, Euler memetakan vektor ke fungsi ini. Dengan demikian kita
mendapatkan plot semua distribusi chi-kuadrat dengan derajat 5 sampai
30 dengan mudah dengan cara berikut.


\>plot2d("qchidis(x,(5:5:50)')",0,50):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-016.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-016.png)

Euler memiliki fungsi yang akurat untuk mengevaluasi distribusi. Mari
kita periksa chidis() dengan integral.


Penamaan mencoba untuk konsisten. Misalnya.,


* 
distribusi chi-kuadrat adalah chidis(),

* 
fungsi kebalikannya adalah invchidis(),

* 
kepadatannya adalah qchidis().


Komplemen dari distribusi (ekor atas) adalah chicdis().


\>chidis(1.5,2), integrate("qchidis(x,2)",0,1.5)


    0.527633447259
    0.527633447259

# Distribusi Diskrit

Untuk menentukan distribusi diskrit Anda sendiri, Anda dapat
menggunakan metode berikut.


Pertama kita atur fungsi distribusinya.


\>wd = 0|((1:6)+[-0.01,0.01,0,0,0,0])/6


    [0,  0.165,  0.335,  0.5,  0.666667,  0.833333,  1]

Artinya dengan probabilitas wd[i+1]-wd[i] kita menghasilkan nilai acak
i.


Ini adalah distribusi yang hampir seragam. Mari kita mendefinisikan
generator nomor acak untuk ini. Fungsi find(v,x) menemukan nilai x
dalam vektor v. Fungsi ini juga berfungsi untuk vektor x.


\>function wrongdice (n,m) := find(wd,random(n,m))


Kesalahannya sangat halus sehingga kita hanya melihatnya dengan sangat
banyak iterasi.


\>columnsplot(getmultiplicities(1:6,wrongdice(1,1000000))):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-017.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-017.png)

Berikut adalah fungsi sederhana untuk memeriksa distribusi seragam
dari nilai 1...K dalam v. Kami menerima hasilnya, jika untuk semua
frekuensi


$$\left|f_i-\frac{1}{K}\right| < \frac{\delta}{\sqrt{n}}.$$\>function checkrandom (v, delta=1) ...


      K=max(v); n=cols(v);
      fr=getfrequencies(v,1:K);
      return max(fr/n-1/K)<delta/sqrt(n);
      endfunction
</pre>
Memang fungsi menolak distribusi seragam.


\>checkrandom(wrongdice(1,1000000))


    0

Dan ia menerima generator acak bawaan.


\>checkrandom(intrandom(1,1000000,6))


    1

Kita dapat menghitung distribusi binomial. Pertama ada binomialsum(),
yang mengembalikan probabilitas i atau kurang hit dari n percobaan.


\>bindis(410,1000,0.4)


    0.751401349654

Fungsi Beta terbalik digunakan untuk menghitung interval kepercayaan
Clopper-Pearson untuk parameter p. Tingkat default adalah alfa.


Arti interval ini adalah jika p berada di luar interval, hasil
pengamatan 410 dalam 1000 jarang terjadi.


\>clopperpearson(410,1000)


    [0.37932,  0.441212]

Perintah berikut adalah cara langsung untuk mendapatkan hasil di atas.
Tetapi untuk n besar, penjumlahan langsung tidak akurat dan lambat.


\>p=0.4; i=0:410; n=1000; sum(bin(n,i)\*p^i\*(1-p)^(n-i))


    0.751401349655

Omong-omong, invbinsum() menghitung kebalikan dari binomialsum().


\>invbindis(0.75,1000,0.4)


    409.932733047

Di Bridge, kami mengasumsikan 5 kartu yang beredar (dari 52) di dua
tangan (26 kartu). Mari kita hitung probabilitas distribusi yang lebih
buruk dari 3:2 (misalnya 0:5, 1:4, 4:1 atau 5:0).


\>2\*hypergeomsum(1,5,13,26)


    0.321739130435

Ada juga simulasi distribusi multinomial.


\>randmultinomial(10,1000,[0.4,0.1,0.5])


              381           100           519 
              376            91           533 
              417            80           503 
              440            94           466 
              406           112           482 
              408            94           498 
              395           107           498 
              399            96           505 
              428            87           485 
              400            99           501 

# Merencanakan Data

Untuk plot data, kami mencoba hasil pemilu Jerman sejak tahun 1990,
diukur dalam kursi.


\>BW := [ ...  
\>   1990,662,319,239,79,8,17; ...  
\>   1994,672,294,252,47,49,30; ...  
\>   1998,669,245,298,43,47,36; ...  
\>   2002,603,248,251,47,55,2; ...  
\>   2005,614,226,222,61,51,54; ...  
\>   2009,622,239,146,93,68,76; ...  
\>   2013,631,311,193,0,63,64];


Untuk pesta, kami menggunakan serangkaian nama.


\>P:=["CDU/CSU","SPD","FDP","Gr","Li"];


Mari kita mencetak persentase dengan baik.


Pertama kita ekstrak kolom yang diperlukan. Kolom 3 sampai 7 adalah
kursi masing-masing partai, dan kolom 2 adalah jumlah kursi. kolom
adalah tahun pemilihan.


\>BT:=BW[,3:7]; BT:=BT/sum(BT); YT:=BW[,1]';


Kemudian kami mencetak statistik dalam bentuk tabel. Kami menggunakan
nama sebagai tajuk kolom, dan tahun sebagai tajuk untuk baris. Lebar
default untuk kolom adalah wc=10, tetapi kami lebih memilih output
yang lebih padat. Kolom akan diperluas untuk label kolom, jika perlu.


\>writetable(BT\*100,wc=6,dc=0,\>fixed,labc=P,labr=YT)


           CDU/CSU   SPD   FDP    Gr    Li
      1990      48    36    12     1     3
      1994      44    38     7     7     4
      1998      37    45     6     7     5
      2002      41    42     8     9     0
      2005      37    36    10     8     9
      2009      38    23    15    11    12
      2013      49    31     0    10    10

Perkalian matriks berikut mengekstrak jumlah persentase dua partai
besar yang menunjukkan bahwa partai-partai kecil telah memperoleh
rekaman di parlemen hingga 2009.


\>BT1:=(BT.[1;1;0;0;0])'\*100


    [84.29,  81.25,  81.1659,  82.7529,  72.9642,  61.8971,  79.8732]

Ada juga plot statistik sederhana. Kami menggunakannya untuk
menampilkan garis dan titik secara bersamaan. Alternatifnya adalah
memanggil plot2d dua kali dengan &gt;add.


\>statplot(YT,BT1,"b"):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-019.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-019.png)

Tentukan beberapa warna untuk setiap pesta.


\>CP:=[rgb(0.5,0.5,0.5),red,yellow,green,rgb(0.8,0,0)];


Sekarang kita dapat memplot hasil pemilu 2009 dan perubahannya menjadi
satu plot menggunakan gambar. Kita dapat menambahkan vektor kolom ke
setiap plot.


\>figure(2,1);  ...  
\>   figure(1); columnsplot(BW[6,3:7],P,color=CP); ...  
\>   figure(2); columnsplot(BW[6,3:7]-BW[5,3:7],P,color=CP);  ...  
\>   figure(0):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-020.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-020.png)

Data plots combine rows of statistical data in one plot.


\>J:=BW[,1]'; DP:=BW[,3:7]'; ...  
\>   dataplot(YT,BT',color=CP);  ...  
\>   labelbox(P,colors=CP,styles="[]",\>points,w=0.2,x=0.3,y=0.4):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-021.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-021.png)

Plot kolom 3D menunjukkan baris data statistik dalam bentuk kolom.
Kami menyediakan label untuk baris dan kolom. sudut adalah sudut
pandang.


\>columnsplot3d(BT,scols=P,srows=YT, ...  
\>     angle=30,ccols=CP):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-022.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-022.png)

Representasi lain adalah plot mosaik. Perhatikan bahwa kolom plot
mewakili kolom matriks di sini. Karena panjangnya label CDU/CSU, kami
mengambil jendela yang lebih kecil dari biasanya.


\>shrinkwindow(\>smaller);  ...  
\>   mosaicplot(BT',srows=YT,scols=P,color=CP,style="#"); ...  
\>   shrinkwindow():


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-023.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-023.png)

Kita juga bisa membuat diagram lingkaran. Karena hitam dan kuning
membentuk koalisi, kami menyusun ulang elemen-elemennya.


\>i=[1,3,5,4,2]; piechart(BW[6,3:7][i],color=CP[i],lab=P[i]):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-024.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-024.png)

Berikut adalah jenis plot lainnya.


\>starplot(normal(1,10)+4,lab=1:10,\>rays):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-025.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-025.png)

Beberapa plot di plot2d bagus untuk statika. Berikut adalah plot
impuls dari data acak, terdistribusi secara merata di [0,1].


\>plot2d(makeimpulse(1:10,random(1,10)),\>bar):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-026.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-026.png)

Tetapi untuk data yang terdistribusi secara eksponensial, kita mungkin
memerlukan plot logaritmik.


\>logimpulseplot(1:10,-log(random(1,10))\*10):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-027.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-027.png)

Fungsi columnplot() lebih mudah digunakan, karena hanya membutuhkan
vektor nilai. Selain itu, ia dapat mengatur labelnya ke apa pun yang
kita inginkan, kita sudah mendemonstrasikannya dalam tutorial ini.


Ini adalah aplikasi lain, di mana kita menghitung karakter dalam
sebuah kalimat dan menyusun statistik.


\>v=strtochar("the quick brown fox jumps over the lazy dog"); ...  
\>   w=ascii("a"):ascii("z"); x=getmultiplicities(w,v); ...  
\>   cw=[]; for k=w; cw=cw|char(k); end; ...  
\>   columnsplot(x,lab=cw,width=0.05):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-028.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-028.png)

Dimungkinkan juga untuk mengatur sumbu secara manual.


\>n=10; p=0.4; i=0:n; x=bin(n,i)\*p^i\*(1-p)^(n-i); ...  
\>   columnsplot(x,lab=i,width=0.05,<frame,<grid); ...  
\>   yaxis(0,0:0.1:1,style="-\>",\>left); xaxis(0,style="."); ...  
\>   label("p",0,0.25), label("i",11,0); ...  
\>   textbox(["Binomial distribution","with p=0.4"]):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-029.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-029.png)

Berikut ini adalah cara untuk memplot frekuensi bilangan dalam sebuah
vektor.


Kami membuat vektor bilangan bulat bilangan acak 1 hingga 6.


\>v:=intrandom(1,10,10)


    [8,  5,  8,  8,  6,  8,  8,  3,  5,  5]

Kemudian ekstrak nomor unik di v.


\>vu:=unique(v)


    [3,  5,  6,  8]

Dan plot frekuensi dalam plot kolom.


\>columnsplot(getmultiplicities(vu,v),lab=vu,style="/"):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-030.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-030.png)

Kami ingin menunjukkan fungsi untuk distribusi nilai empiris.


\>x=normal(1,20);


Fungsi empdist(x,vs) membutuhkan array nilai yang diurutkan. Jadi kita
harus mengurutkan x sebelum kita dapat menggunakannya.


\>xs=sort(x);


Kemudian kami memplot distribusi empiris dan beberapa batang kepadatan
menjadi satu plot. Alih-alih plot batang untuk distribusi, kami
menggunakan plot gigi gergaji kali ini.


\>figure(2,1); ...  
\>   figure(1); plot2d("empdist",-4,4;xs); ...  
\>   figure(2); plot2d(histo(x,v=-4:0.2:4,<bar));  ...  
\>   figure(0):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-031.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-031.png)

Plot pencar mudah dilakukan di Euler dengan plot titik biasa. Grafik
berikut menunjukkan bahwa X dan X+Y jelas berkorelasi positif.


\>x=normal(1,100); plot2d(x,x+rotright(x),\>points,style=".."):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-032.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-032.png)

Seringkali, kita ingin membandingkan dua sampel dari distribusi yang
berbeda. Ini dapat dilakukan dengan plot kuantil-kuantil.


Untuk pengujian, kami mencoba distribusi student-t dan distribusi
eksponensial.


\>x=randt(1,1000,5); y=randnormal(1,1000,mean(x),dev(x)); ...  
\>   plot2d("x",r=6,style="--",yl="normal",xl="student-t",\>vertical); ...  
\>   plot2d(sort(x),sort(y),\>points,color=red,style="x",\>add):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-033.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-033.png)

Plot dengan jelas menunjukkan bahwa nilai terdistribusi normal
cenderung lebih kecil di ujung ekstrim.


Jika kita memiliki dua distribusi dengan ukuran yang berbeda, kita
dapat memperluas yang lebih kecil atau mengecilkan yang lebih besar.
Fungsi berikut baik untuk keduanya. Dibutuhkan nilai median dengan
persentase antara 0 dan 1.


\>function medianexpand (x,n) := median(x,p=linspace(0,1,n-1));


Mari kita bandingkan dua distribusi yang sama.


\>x=random(1000); y=random(400); ...  
\>   plot2d("x",0,1,style="--"); ...  
\>   plot2d(sort(medianexpand(x,400)),sort(y),\>points,color=red,style="x",\>add):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-034.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-034.png)

# Regresi dan Korelasi

Regresi linier dapat dilakukan dengan fungsi polyfit() atau berbagai
fungsi fit.


Sebagai permulaan, kami menemukan garis regresi untuk data univariat
dengan polifit(x,y,1).


\>x=1:10; y=[2,3,1,5,6,3,7,8,9,8]; writetable(x'|y',labc=["x","y"])


             x         y
             1         2
             2         3
             3         1
             4         5
             5         6
             6         3
             7         7
             8         8
             9         9
            10         8

Kami ingin membandingkan non-weighted dan weighted fit. Pertama,
koefisien kecocokan linier.


\>plot2d(x,y,\>points);

\>p=polyfit(x,y,1)


    [0.733333,  0.812121]

Sekarang koefisien dengan bobot yang menekankan nilai terakhir.


\>w &= "exp(-(x-10)^2/10)"; pw=polyfit(x,y,1,w=w(x))


    [4.71566,  0.38319]

Kami memasukkan semuanya ke dalam satu plot untuk titik dan garis
regresi, dan untuk bobot yang digunakan.


\>figure(2,1);  ...  
\>   figure(1); statplot(x,y,"b",xl="Regression"); ...  
\>     plot2d("evalpoly(x,p)",\>add,color=blue,style="--"); ...  
\>     plot2d("evalpoly(x,pw)",5,10,\>add,color=red,style="--"); ...  
\>   figure(2); plot2d(w,1,10,\>filled,style="/",fillcolor=red,xl=w); ...  
\>   figure(0):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-035.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-035.png)

Sebagai contoh lain kita membaca survei siswa, usia mereka, usia orang
tua mereka dan jumlah saudara kandung dari sebuah file.


Tabel ini berisi "m" dan "f" di kolom kedua. Kami menggunakan variabel
tok2 untuk mengatur terjemahan yang tepat daripada membiarkan
readtable() mengumpulkan terjemahan.


\>{MS,hd}:=readtable("table1.dat",tok2:=["m","f"]);  ...  
\>   writetable(MS,labc=hd,tok2:=["m","f"]);


    Could not open the file
    table1.dat
    for reading!
    Try "trace errors" to inspect local variables after errors.
    readtable:
        if filename!=none then open(filename,"r"); endif;

Bagaimana usia bergantung satu sama lain? Kesan pertama datang dari
scatterplot berpasangan.


\>scatterplots(tablecol(MS,3:5),hd[3:5]):


    Variable or function MS not found.
    Error in:
    scatterplots(tablecol(MS,3:5),hd[3:5]): ...
                            ^

Jelas bahwa usia ayah dan ibu bergantung satu sama lain. Mari kita
tentukan dan plot garis regresinya.


\>cs:=MS[,4:5]'; ps:=polyfit(cs[1],cs[2],1)


    MS is not a variable!
    Error in:
    cs:=MS[,4:5]'; ps:=polyfit(cs[1],cs[2],1) ...
                ^

Ini jelas model yang salah. Garis regresinya adalah s=17+0,74t, di
mana t adalah usia ibu dan s usia ayah. Perbedaan usia mungkin sedikit
bergantung pada usia, tetapi tidak terlalu banyak.


Sebaliknya, kami menduga fungsi seperti s=a+t. Maka a adalah mean dari
s-t. Ini adalah perbedaan usia rata-rata antara ayah dan ibu.


\>da:=mean(cs[2]-cs[1])


    cs is not a variable!
    Error in:
    da:=mean(cs[2]-cs[1]) ...
                  ^

Mari kita plot ini menjadi satu plot pencar.


\>plot2d(cs[1],cs[2],\>points);  ...  
\>   plot2d("evalpoly(x,ps)",color=red,style=".",\>add);  ...  
\>   plot2d("x+da",color=blue,\>add):


    cs is not a variable!
    Error in:
    plot2d(cs[1],cs[2],&gt;points);  plot2d("evalpoly(x,ps)",color=re ...
                ^

Berikut adalah plot kotak dari dua zaman. Ini hanya menunjukkan, bahwa
usianya berbeda.


\>boxplot(cs,["mothers","fathers"]):


    Variable or function cs not found.
    Error in:
    boxplot(cs,["mothers","fathers"]): ...
              ^

Sangat menarik bahwa perbedaan median tidak sebesar perbedaan
rata-rata.


\>median(cs[2])-median(cs[1])


    cs is not a variable!
    Error in:
    median(cs[2])-median(cs[1]) ...
                ^

Koefisien korelasi menunjukkan korelasi positif.


\>correl(cs[1],cs[2])


    cs is not a variable!
    Error in:
    correl(cs[1],cs[2]) ...
                ^

Korelasi peringkat adalah ukuran untuk urutan yang sama di kedua
vektor. Ini juga cukup positif.


\>rankcorrel(cs[1],cs[2])


    cs is not a variable!
    Error in:
    rankcorrel(cs[1],cs[2]) ...
                    ^

# Membuat Fungsi baru

Tentu saja, bahasa EMT dapat digunakan untuk memprogram fungsi-fungsi
baru. Misalnya, kita mendefinisikan fungsi skewness.


$$\text{sk}(x) = \dfrac{\sqrt{n} \sum_i (x_i-m)^3}{\left(\sum_i (x_i-m)^2\right)^{3/2 }}$$dimana m adalah mean dari x.


\>function skew (x:vector) ...


    m=mean(x);
    return sqrt(cols(x))*sum((x-m)^3)/(sum((x-m)^2))^(3/2);
    endfunction
</pre>
Seperti yang Anda lihat, kita dapat dengan mudah menggunakan bahasa
matriks untuk mendapatkan implementasi yang sangat singkat dan
efisien. Mari kita coba fungsi ini.


\>data=normal(20); skew(normal(10))


    -0.198710316203

Berikut adalah fungsi lain, yang disebut koefisien skewness Pearson.


\>function skew1 (x) := 3\*(mean(x)-median(x))/dev(x)

\>skew1(data)


    -0.0801873249135

# Simulasi Morte Carlo

Euler Math Toolbox sangat bagus untuk mensimulasikan kejadian acak.
Dalam demo ini, saya ingin mencoba beberapa


contoh.


Mari kita mulai dengan distribusi normal sederhana. Kami
mensimulasikan 1000-5-normal terdistribusi acak


variabel satu juta kali. Untuk ini, kami menggunakan fungsi
normal(m,n), yang menghasilkan matriks 0-1-


nilai terdistribusi, atau normal(n) yang defaultnya adalah m=1. Untuk
mendapatkan distribusi 5000-5, kami menggunakan yang sederhana


aritmatika dengan bahasa matriks Euler.


\>n=1000000; x=normal(n)\*5+1000;


Ada juga fungsi randnormal(n,m,mean,dev), yang mungkin kita gunakan.
Fungsi ini mematuhi


skema penamaan "rand..." untuk generator acak.


  dengan distribusi normal sederhana. Kami mensimulasikan
1000-5-normal terdistribusi acak


variabel satu juta kali. Untuk ini, kami menggunakan fungsi
normal(m,n), yang menghasilkan matriks 0-1-


nilai terdistribusi, atau normal(n) yang defaultnya adalah m=1. Untuk
mendapatkan distribusi 5000-5, kami menggunakan yang sederhana


aritmatika dengan bahasa matriks Euler.


\>n=1000000; x=randnormal(1,n,1000,5);


10 nilai x pertama adalah sebagai berikut.


\>x[1:10]


    [1002.99,  1003.08,  996.596,  990.94,  998.608,  1005.05,  997.111,
    1006.2,  1003.62,  988.073]

Distribusi dapat dengan mudah diplot dengan flag &gt;distribusi dari
plot2d. Saya akan menunjukkannya kepada Anda sebentar lagi


bagaimana ini bisa dilakukan secara manual.


Mari kita tambahkan kepadatan yang diharapkan dari distribusi normal


\>plot2d(x,\>distribution);

\>plot2d("qnormal(x,1000,5)",color=red,thickness=2,\>add):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-037.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-037.png)

Anda dapat mengatur jumlah interval untuk distribusi menjadi 100.
Kemudian Anda melihat seberapa dekat yang diamati


distribusi dan kecocokan distribusi yang sebenarnya. Bagaimanapun,
kami telah menghasilkan satu juta acara.


\>plot2d(x,distribution=100,style="#"); ...  
\>   plot2d("qnormal(x,1000,5)",color=red,thickness=2,\>add):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-038.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-038.png)

Tentu saja, nilai rata-rata dari simulasi ini dan penyimpangannya
harus sangat dekat dengan nilai yang diharapkan.


\>mean(x), dev(x)


    999.999155778
    5.0045797051

Kedua fungsi ini mudah dihitung dengan cara dasar. Untuk nilai
rata-rata, kita dapat menggunakan fungsi penjumlahan, yang mengambil
jumlah semua elemen dari vektor baris.


\>xm=sum(x)/n


    999.999155778

Maka simpangan percobaan adalah sebagai berikut:


\>sqrt(sum((x-xm)^2/(n-1)))


    5.0045797051

Perhatikan, bahwa x-xm adalah vektor dari nilai yang dikoreksi, di
mana xm dikurangkan dari semua elemen vektor x. Berikut adalah 10
nilai pertama x-xm.


\>short (x-xm)[1:10]


    [2.99,  3.078,  -3.4035,  -9.0591,  -1.3916,  5.0465,  -2.8878,
    6.1985,  3.6198,  -11.926]

Dengan menggunakan bahasa matriks, kita dapat dengan mudah menjawab
pertanyaan lain. Misalnya, kami ingin menghitung proporsi x yang
melebihi 1015.


Ekspresi x&gt;=1015 mengembalikan vektor 1 dan 0. Menjumlahkan vektor ini
menghasilkan berapa kali x[i]&gt;=1015 terjadi.


\>sum(x\>=1015)/n


    0.001307

Probabilitas yang diharapkan dari ini dapat dihitung dengan fungsi
normaldis(x). Euler menggunakan distribusi dengan konvensi penamaan
...dis, sehingga


normaldis(c,m,s) = P(X = c).


di mana X terdistribusi m-s-normal


\>1-normaldis(1015,1000,5)


    0.00134989803163

Hasilnya harus sesuai dengan dua digit dengan frekuensi yang diamati.


Bagaimana cara kerja &gt; flag distribusi plot2d? Ini menggunakan fungsi
histo(x), yang menghasilkan histogram frekuensi nilai dalam x. Fungsi
ini mengembalikan batas interval dan jumlah dalam interval ini. Kami
menormalkan jumlah untuk mendapatkan frekuensi.


\>{t,s}=histo(x,40); plot2d(t,s/n,\>bar):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-039.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-039.png)

Fungsi histo() juga dapat menghitung frekuensi dalam interval
tertentu.


\>{t,s}=histo(x,v=[950,980,990,1010,1020,1050]); t, s,


    [950,  980,  990,  1010,  1020,  1050]
    [34,  22842,  954094,  23001,  29]

\>sum(s)


    1000000

# Simulasi Pengukuran

Untuk mensimulasikan 5 pengukuran variabel acak terdistribusi normal,
kami mengambil lima nilai terdistribusi 1000-5-normal seratus ribu
kali.


\>m=5; n=100000; A=normal(n,m)\*5+1000;


Angka-angka tersebut disimpan dalam matriks A, masing-masing tupel
dari 5 pengukuran dalam satu baris. Ini adalah baris pertama dari
100.000 baris.


\>A[1]


    [1001.46,  1002.83,  995.424,  1010.42,  993.922]

Mari kita hitung vektor dari semua nilai rata-rata dari pengukuran m.
Nilai rata-ratanya harus mendekati 1000.


\>MA=sum(A)/m; mean(MA)


    Closing bracket missing in function call!
    Error in:
    MA=sum(A)/m; mean(MA) ...
                        ^

Perhatikan bahwa MA adalah vektor kolom, dan mean bekerja untuk vektor
baris, seperti jumlah dan dev.


Sekarang kita dapat menghitung vektor deviasi standar eksperimental.
Kita dapat menguji bahwa kuadrat dari ini (variasi) diharapkan menjadi
52.


\>VA=sum((A-MA)^2/(m-1)); mean(VA)


    Closing bracket missing in function call!
    Error in:
    VA=sum((A-MA)^2/(m-1)); mean(VA) ...
                                   ^

Plot berikutnya menunjukkan distribusi


yang diharapkan terdistribusi student-t dengan m-1 derajat kebebasan.
Kami menambahkan distribusi normal, yang jelas hanya solusi perkiraan.


\>plot2d((MA-1000)/sqrt(VA)\*sqrt(m),a=-6,b=6,c=0,d=0.4, ...  
\>    distribution=500,style="#"); ...  
\>    plot2d("qtdis(x,m-1)",color=red,thickness=2,\>add); ...  
\>    plot2d("qnormal(x)",color=blue,\>add):


    Closing bracket ) missing!
    Error in:
    plot2d((MA-1000)/sqrt(VA)*sqrt(m),a=-6,b=6,c=0,d=0.4,  distr ...
              ^

Untuk semua baris i


terdistribusi chi-kuadrat dengan m derajat kebebasan. Distribusi
chi-kuadrat disebut chidis() dalam Euler, dan qchidis() adalah fungsi
densitasnya.


\>plot2d(sum(((A-1000)/5)^2),distribution=50); ...  
\>    plot2d("qchidis(x,m)",color=red,thickness=2,\>add):


    Closing bracket missing in function call!
    Error in:
    plot2d(sum(((A-1000)/5)^2),distribution=50);  plot2d("qchidis ...
                              ^

# Interval Keyakinan 

Dengan menggunakan simulasi, kita ingin mendapatkan keyakinan dalam
kebenaran interval keyakinan. Jika kita memiliki n data dari variabel
acak terdistribusi normal, kita dapat memperkirakan mean dan standar
deviasi dari distribusi sebagai berikut:


\>n=10; x=normal(n); mean(x), dev(x),


    0.273523269265
    0.983795060777

Mari kita periksa nilai-nilai ini.


\>xm=sum(x)/n, xsd=sqrt(sum((x-xm)^2)/(n-1)),


    0.273523269265
    0.983795060777

Fungsi cimean() mengembalikan interval kepercayaan untuk nilai
rata-rata pengambilan sampel


\>cimean(x,5%)


    [-0.430241,  0.977288]

Interval ini harus memiliki properti bahwa nilai rata-rata sebenarnya
(0 dalam kasus kami) berada dalam interval dalam 95% kasus.
Menggunakan teori probabilitas, kita melihat bahwa kita dapat
menggunakan interval berikut.


\>invtdis(0.975,n-1)\*xsd/sqrt(n); [xm-%,xm+%]


    [-0.430241,  0.977288]

Tapi apakah ini benar?


Untuk memeriksa kebenaran kami mensimulasikan prosedur berkali-kali.


\>m=10000; X=normal(m,n); M=sum(X)/n; SD=sqrt(sum((X-M)^2/(n-1)));


Kami sekarang memiliki matriks kolom sarana dan standar deviasi.


\>plot2d(M,\>distribution,title="Distribution of mean Values"):


    Closing bracket missing in function call!
    Error in:
    plot2d(M,&gt;distribution,title="Distribution of mean Values"): ...
            ^

Mari kita hitung interval kepercayaan dan periksa, seberapa sering 0
berada dalam interval. Kami mendapatkan vektor kolom interval
kepercayaan.


\>cf=invtdis(0.975,n-1); CI=M+cf\*SD/sqrt(n)\*[-1,1]; CI[1:10]


        -0.500839      0.624196 
        0.0888336      0.549029 
        -0.533671       1.06173 
         -0.58591      0.665723 
        -0.560868       0.61117 
        -0.538362       1.00097 
        -0.892344      0.142276 
        -0.581888      0.833247 
        -0.393667      0.267974 
        -0.632631       0.60033 

Seberapa sering 0 dalam interval ini? Ini harus mendekati 95%.


\>sum((CI[,1]<=0 && CI[,2]\>=0))/m


    Closing bracket missing in function call!
    Error in:
    sum((CI[,1]&lt;=0 &amp;&amp; CI[,2]&gt;=0))/m ...
                                ^

Ide yang sama berlaku untuk distribusi binomial. Jika kami menemukan k
hit dalam n undian independen, kami memperkirakan p=k/n untuk
probabilitas satu pukulan. Kita dapat membuat selang kepercayaan untuk
p yang disebabkan oleh Clopper dan Pearson.


Intervalnya biasanya agak besar. Misalnya, jika kita menemukan 15 dari
150 kita hanya dapat mengatakan bahwa p adalah antara 5,7% dan 16%.


\>clopperpearson(15,150,5%)


    [0.0570574,  0.159568]

Mari kita periksa, apakah interval ini memiliki properti yang
diinginkan. Kita asumsikan bahwa p sebenarnya adalah 0,12.


\>m=10000; n=150; p=0.12; X=sum(random(m,n)<p);


Kemudian kita dapat memplot distribusi jumlah hit. Rata-rata harus
0,12*150.


\>plot2d(X,\>distribution):


    Closing bracket missing in function call!
    Error in:
    plot2d(X,&gt;distribution): ...
            ^

Fungsi clopperpearson() tidak membuat vektor. Jadi kita harus
menggunakan loop dalam kasus ini.


\>CI=zeros(m,2); for k=1:m; CI[k]=clopperpearson(X[k],n,5%); end;


Kami menghitung berapa kali p berada dalam interval dengan cara yang
sama seperti di atas.


\>sum((p\>=CI[,1] && p<=CI[,2]))/m


    Closing bracket missing in function call!
    Error in:
    sum((p&gt;=CI[,1] &amp;&amp; p&lt;=CI[,2]))/m ...
                                ^

# Simulasi Monte Carlo

Euler dapat digunakan untuk mensimulasikan kejadian acak. Kita telah
melihat contoh sederhana di atas. Ini adalah satu lagi, yang
mensimulasikan 1000 kali 3 lemparan dadu, dan meminta distribusi
jumlah.


\>ds:=sum(intrandom(1000,3,6))';  fs=getmultiplicities(3:18,ds)


    [5,  12,  26,  38,  61,  101,  112,  123,  156,  115,  87,  69,  48,
    28,  14,  5]

Kita bisa merencanakan ini sekarang.


\>columnsplot(fs,lab=3:18):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-040.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-040.png)

Untuk menentukan distribusi yang diharapkan tidak begitu mudah. Kami
menggunakan rekursi lanjutan untuk ini.


Fungsi berikut menghitung banyaknya cara bilangan k dapat
direpresentasikan sebagai jumlah n bilangan dalam rentang 1 sampai m.
Ia bekerja secara rekursif dengan cara yang jelas.


\>function map countways (k; n, m) ...


      if n==1 then return k>=1 && k<=m
      else
        sum=0; 
        loop 1 to m; sum=sum+countways(k-#,n-1,m); end;
        return sum;
      end;
    endfunction
</pre>
Berikut adalah hasil untuk tiga lemparan dadu.


\>cw=countways(3:18,3,6)


    [1,  3,  6,  10,  15,  21,  25,  27,  27,  25,  21,  15,  10,  6,  3,
    1]

Kami menambahkan nilai yang diharapkan ke plot.


\>plot2d(cw/6^3\*1000,\>add); plot2d(cw/6^3\*1000,\>points,\>add):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-041.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-041.png)

Untuk simulasi lain, simpangan nilai rata-rata dari n 0-1-variabel
acak terdistribusi normal adalah 1/sqrt(n).


\>longformat; 1/sqrt(10)


    0.316227766017

Mari kita periksa ini dengan simulasi. Kami memproduksi 10.000 kali 10
vektor acak.


\>M=normal(10000,10); dev(mean(M)')


    0.318036460391

\>plot2d(mean(M)',\>distribution):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-042.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-042.png)

Median 10 0-1-bilangan acak terdistribusi normal memiliki simpangan
yang lebih besar.


\>dev(median(M)')


    0.372804012749

Karena kita dapat dengan mudah menghasilkan jalan acak, kita dapat
mensimulasikan proses Wiener. Kami mengambil 1000 langkah dari 1000
proses. Kami kemudian memplot deviasi standar dan rata-rata dari
langkah ke-n dari proses ini bersama dengan nilai yang diharapkan
dalam warna merah.


\>n=1000; m=1000; M=cumsum(normal(n,m)/sqrt(m)); ...  
\>   t=(1:n)/n; figure(2,1); ...  
\>   figure(1); plot2d(t,mean(M')'); plot2d(t,0,color=red,\>add); ...  
\>   figure(2); plot2d(t,dev(M')'); plot2d(t,sqrt(t),color=red,\>add); ...  
\>   figure(0):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-043.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-043.png)

# Tes

Tes adalah alat penting dalam statistik. Di Euler, banyak tes
diimplementasikan. Semua tes ini mengembalikan kesalahan yang kami
terima jika kami menolak hipotesis nol.


Sebagai contoh, kami menguji lemparan dadu untuk distribusi seragam.
Pada 600 lemparan, kami mendapatkan nilai berikut, yang kami masukkan
ke dalam uji chi-kuadrat.


\>chitest([90,103,114,101,103,89],dup(100,6)')


    0.498830517952

Tes chi-kuadrat juga memiliki mode, yang menggunakan simulasi Monte
Carlo untuk menguji statistik. Hasilnya harus hampir sama. Parameter
&gt;p menginterpretasikan vektor-y sebagai vektor probabilitas.


\>chitest([90,103,114,101,103,89],dup(1/6,6)',\>p,\>montecarlo)


    0.504

Kesalahan ini terlalu besar. Jadi kita tidak bisa menolak distribusi
seragam. Ini tidak membuktikan bahwa dadu kami adil. Tapi kita tidak
bisa menolak hipotesis kita.


Selanjutnya kita menghasilkan 1000 lemparan dadu menggunakan generator
angka acak, dan melakukan tes yang sama.


\>n=1000; t=random([1,n\*6]); chitest(count(t\*6,6),dup(n,6)')


    0.488221433823

Mari kita uji nilai rata-rata 100 dengan uji-t.


\>s=200+normal([1,100])\*10; ...  
\>   ttest(mean(s),dev(s),100,200)


    0.273708267524

Fungsi ttest() membutuhkan nilai rata-rata, simpangan, jumlah data,
dan nilai rata-rata yang akan diuji.


Sekarang mari kita periksa dua pengukuran untuk mean yang sama. Kami
menolak hipotesis bahwa mereka memiliki rata-rata yang sama, jika
hasilnya &lt;0,05.


\>tcomparedata(normal(1,10),normal(1,10))


    0.139406470145

Jika kita menambahkan bias ke satu distribusi, kita mendapatkan lebih
banyak penolakan. Ulangi simulasi ini beberapa kali untuk melihat
efeknya.


\>tcomparedata(normal(1,10),normal(1,10)+2)


    3.6139297689e-05

Pada contoh berikutnya, kita menghasilkan 20 lemparan dadu acak
sebanyak 100 kali dan menghitung yang ada di dalamnya. Harus ada
20/6=3,3 yang rata-rata.


\>R=random(100,20); R=sum(R\*6<=1)'; mean(R)


    3.29

Kami sekarang membandingkan jumlah satu dengan distribusi binomial.
Pertama kita plot distribusinya.


\>plot2d(R,distribution=max(R)+1,even=1,style="\\/"):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-044.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-044.png)

\>t=count(R,21);


Kemudian kami menghitung nilai yang diharapkan.


\>n=0:20; b=bin(20,n)\*(1/6)^n\*(5/6)^(20-n)\*100;


Kita harus mengumpulkan beberapa angka untuk mendapatkan kategori yang
cukup besar.


\>t1=sum(t[1:2])|t[3:7]|sum(t[8:21]); ...  
\>   b1=sum(b[1:2])|b[3:7]|sum(b[8:21]);


Uji chi-kuadrat menolak hipotesis bahwa distribusi kami adalah
distribusi binomial, jika hasilnya &lt;0,05.


\>chitest(t1,b1)


    0.592329829121

Contoh berikut berisi hasil dua kelompok orang (laki-laki dan
perempuan, katakanlah) memberikan suara untuk satu dari enam partai.


\>A=[23,37,43,52,64,74;27,39,41,49,63,76];  ...  
\>     writetable(A,wc=6,labr=["m","f"],labc=1:6)


               1     2     3     4     5     6
         m    23    37    43    52    64    74
         f    27    39    41    49    63    76

Kami ingin menguji independensi suara dari jenis kelamin. Tes tabel
chi^2 melakukan ini. Akibatnya terlalu besar untuk menolak
kemerdekaan. Jadi kita tidak bisa mengatakan, jika voting tergantung
pada jenis kelamin dari data ini.


\>tabletest(A)


    0.990701632326

Berikut ini adalah tabel yang diharapkan, jika kita mengasumsikan
frekuensi pemungutan suara yang diamati.


\>writetable(expectedtable(A),wc=6,dc=1,labr=["m","f"],labc=1:6)


               1     2     3     4     5     6
         m  24.9  37.9  41.9  50.3  63.3  74.7
         f  25.1  38.1  42.1  50.7  63.7  75.3

Kita dapat menghitung koefisien kontingensi yang dikoreksi. Karena
sangat dekat dengan 0, kami menyimpulkan bahwa pemungutan suara tidak
tergantung pada jenis kelamin.


\>contingency(A)


    0.0427225484717

# Beberapa Tes lainnya

Selanjutnya kami menggunakan analisis varians (Uji-F) untuk menguji
tiga sampel data yang terdistribusi normal untuk nilai rata-rata yang
sama. Metode tersebut disebut ANOVA (analisis varians). Di Euler,
fungsi varanalysis() digunakan.


\>x1=[109,111,98,119,91,118,109,99,115,109,94]; mean(x1),


    106.545454545

\>x2=[120,124,115,139,114,110,113,120,117]; mean(x2),


    119.111111111

\>x3=[120,112,115,110,105,134,105,130,121,111]; mean(x3)


    116.3

\>varanalysis(x1,x2,x3)


    0.0138048221371

Ini berarti, kami menolak hipotesis nilai rata-rata yang sama. Kami
melakukan ini dengan probabilitas kesalahan 1,3%.


Ada juga uji median, yang menolak sampel data dengan distribusi
rata-rata berbeda menguji median sampel bersatu.


\>a=[56,66,68,49,61,53,45,58,54];

\>b=[72,81,51,73,69,78,59,67,65,71,68,71];

\>mediantest(a,b)


    0.0241724220052

Tes lain tentang kesetaraan adalah tes peringkat. Ini jauh lebih tajam
daripada tes median.


\>ranktest(a,b)


    0.00199969612469

Dalam contoh berikut, kedua distribusi memiliki mean yang sama.


\>ranktest(random(1,100),random(1,50)\*3-1)


    0.0790775759345

Sekarang mari kita coba mensimulasikan dua perlakuan a dan b yang
diterapkan pada orang yang berbeda.


\>a=[8.0,7.4,5.9,9.4,8.6,8.2,7.6,8.1,6.2,8.9];

\>b=[6.8,7.1,6.8,8.3,7.9,7.2,7.4,6.8,6.8,8.1];


Tes signum memutuskan, jika a lebih baik dari b.


\>signtest(a,b)


    0.0546875

Ini terlalu banyak kesalahan. Kita tidak dapat menolak bahwa a sama
baiknya dengan b.


Tes Wilcoxon lebih tajam dari tes ini, tetapi bergantung pada nilai
kuantitatif perbedaan.


\>wilcoxon(a,b)


    0.0296680599405

Mari kita coba dua tes lagi menggunakan seri yang dihasilkan.


\>wilcoxon(normal(1,20),normal(1,20)-1)


    0.00255552436097

\>wilcoxon(normal(1,20),normal(1,20))


    0.0429619300139

# Nomor Acak

Berikut ini adalah pengujian untuk pembangkit bilangan acak. Euler
menggunakan generator yang sangat bagus, jadi kita tidak perlu
mengharapkan masalah.


Pertama kita menghasilkan sepuluh juta angka acak di [0,1].


\>n:=10000000; r:=random(1,n);


Selanjutnya kita hitung jarak antara dua bilangan kurang dari 0,05.


\>a:=0.05; d:=differences(nonzeros(r<a));


Akhirnya, kami memplot berapa kali, setiap jarak terjadi, dan
membandingkan dengan nilai yang diharapkan.


\>m=getmultiplicities(1:100,d); plot2d(m); ...  
\>     plot2d("n\*(1-a)^(x-1)\*a^2",color=red,\>add):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-045.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-045.png)

Hapus datanya.


\>remvalue n;


# Pengantar untuk Pengguna Proyek R

Jelas, EMT tidak bersaing dengan R sebagai paket statistik. Namun, ada
banyak prosedur dan fungsi statistik yang tersedia di EMT juga. Jadi
EMT dapat memenuhi kebutuhan dasar. Bagaimanapun, EMT hadir dengan
paket numerik dan sistem aljabar komputer.


Notebook ini cocok untuk Anda yang terbiasa dengan R, tetapi perlu
mengetahui perbedaan sintaks EMT dan R. Kami mencoba memberikan
gambaran tentang hal-hal yang jelas dan kurang jelas yang perlu Anda
ketahui.


Selain itu, kami mencari cara untuk bertukar data antara kedua sistem.


Perhatikan bahwa ini adalah pekerjaan yang sedang berjalan.


# Sintaks Dasar

Hal pertama yang Anda pelajari di R adalah membuat vektor. Di EMT,
perbedaan utama adalah bahwa : operator dapat mengambil ukuran
langkah. Selain itu, ia memiliki daya ikat yang rendah.


\>n=10; 0:n/20:n-1


    [0,  0.5,  1,  1.5,  2,  2.5,  3,  3.5,  4,  4.5,  5,  5.5,  6,  6.5,
    7,  7.5,  8,  8.5,  9]

Fungsi c() tidak ada. Dimungkinkan untuk menggunakan vektor untuk
menggabungkan sesuatu.


Contoh berikut, seperti banyak contoh lainnya, dari "Interoduction to
R" yang disertakan dengan proyek R. Jika Anda membaca PDF ini, Anda
akan menemukan bahwa saya mengikuti jalannya dalam tutorial ini.


\>x=[10.4, 5.6, 3.1, 6.4, 21.7]; [x,0,x]


    [10.4,  5.6,  3.1,  6.4,  21.7,  0,  10.4,  5.6,  3.1,  6.4,  21.7]

Operator titik dua dengan ukuran langkah EMT diganti dengan fungsi
seq() di R. Kita bisa menulis fungsi ini di EMT.


\>function seq(a,b,c) := a:b:c; ...  
\>   seq(0,-0.1,-1)


    [0,  -0.1,  -0.2,  -0.3,  -0.4,  -0.5,  -0.6,  -0.7,  -0.8,  -0.9,  -1]

Fungsi rep() dari R tidak ada di EMT. Untuk input vektor, dapat
ditulis sebagai berikut.


\>function rep(x:vector,n:index) := flatten(dup(x,n)); ...  
\>   rep(x,2)


    [10.4,  5.6,  3.1,  6.4,  21.7,  10.4,  5.6,  3.1,  6.4,  21.7]

Perhatikan bahwa "=" atau ":=" digunakan untuk tugas. Operator "-&gt;"
digunakan untuk unit di EMT.


\>125km -\> " miles"


    77.6713990297 miles

Operator "&lt;-" untuk penugasan tetap menyesatkan, dan bukan ide yang
baik untuk R. Berikut ini akan membandingkan a dan -4 di EMT.


\>a=2; a<-4


    0

Di R, "a&lt;-4&lt;3" berfungsi, tetapi "a&lt;-4&lt;-3" tidak. Saya juga memiliki
ambiguitas serupa di EMT, tetapi mencoba menghilangkannya
perlahan-lahan.


EMT dan R memiliki vektor bertipe boolean. Namun di EMT, angka 0 dan 1
digunakan untuk mewakili salah dan benar. Di R, nilai true dan false
dapat digunakan dalam aritmatika biasa seperti di EMT.


\>x<5, %\*x


    [0,  0,  1,  0,  0]
    [0,  0,  3.1,  0,  0]

EMT melempar kesalahan atau menghasilkan NAN tergantung pada tanda
"kesalahan".


\>errors off; 0/0, isNAN(sqrt(-1)), errors on;


    NAN
    1

String sama di R dan EMT. Keduanya berada di lokal saat ini, bukan di
Unicode.


Di R ada paket untuk Unicode. Di EMT, sebuah string dapat berupa
string Unicode. String unicode dapat diterjemahkan ke pengkodean lokal
dan sebaliknya. Selain itu, u"..." dapat berisi entitas HTML.


\>u"&#169; Ren&eacut; Grothmann"


     Ren Grothmann

Berikut ini mungkin atau mungkin tidak ditampilkan dengan benar di
sistem Anda sebagai A dengan titik dan garis di atasnya. Itu
tergantung pada font yang Anda gunakan.


\>chartoutf([480])


    

Penggabungan string dilakukan dengan "+" atau "|". Ini dapat mencakup
angka, yang akan dicetak dalam format saat ini.


\>"pi = "+pi


    pi = 3.14159265359

# Pengindeksan

Sebagian besar waktu, ini akan berfungsi seperti pada R.


Tetapi EMT akan menginterpretasikan indeks negatif dari belakang
vektor, sedangkan R menginterpretasikan x[n] sebagai x tanpa elemen
ke-n.


\>x, x[1:3], x[-2]


    [10.4,  5.6,  3.1,  6.4,  21.7]
    [10.4,  5.6,  3.1]
    6.4

Perilaku R dapat dicapai dalam EMT dengan drop().


\>drop(x,2)


    [10.4,  3.1,  6.4,  21.7]

Vektor logis tidak diperlakukan secara berbeda sebagai indeks di EMT,
berbeda dengan R. Anda perlu mengekstrak elemen bukan nol terlebih
dahulu di EMT.


\>x, x\>5, x[nonzeros(x\>5)]


    [10.4,  5.6,  3.1,  6.4,  21.7]
    [1,  1,  0,  1,  1]
    [10.4,  5.6,  6.4,  21.7]

Sama seperti di R, vektor indeks dapat berisi pengulangan.


\>x[[1,2,2,1]]


    [10.4,  5.6,  5.6,  10.4]

Tetapi nama untuk indeks tidak dimungkinkan di EMT. Untuk paket
statistik, ini mungkin sering diperlukan untuk memudahkan akses ke
elemen vektor.


Untuk meniru perilaku ini, kita dapat mendefinisikan fungsi sebagai
berikut.


\>function sel (v,i,s) := v[indexof(s,i)]; ...  
\>   s=["first","second","third","fourth"]; sel(x,["first","third"],s)


    
    Trying to overwrite protected function sel!
    Error in:
    function sel (v,i,s) := v[indexof(s,i)]; ... ...
                 ^
    
    Trying to overwrite protected function sel!
    Error in:
    function sel (v,i,s) := v[indexof(s,i)]; ... ...
                 ^
    
    Trying to overwrite protected function sel!
    Error in:
    function sel (v,i,s) := v[indexof(s,i)]; ... ...
                 ^
    
    Trying to overwrite protected function sel!
    Error in:
    function sel (v,i,s) := v[indexof(s,i)]; ... ...
                 ^
    [10.4,  3.1]

# Tipe Data

EMT memiliki lebih banyak tipe data tetap daripada R. Jelas, di R ada
vektor yang tumbuh. Anda dapat mengatur vektor numerik kosong v dan
menetapkan nilai ke elemen v[17]. Ini tidak mungkin di EMT.


Berikut ini agak tidak efisien.


\>v=[]; for i=1 to 10000; v=v|i; end;


EMT sekarang akan membuat vektor dengan v dan i ditambahkan pada
tumpukan dan menyalin vektor itu kembali ke variabel global v.


Semakin efisien pra-mendefinisikan vektor.


\>v=zeros(10000); for i=1 to 10000; v[i]=i; end;


Untuk mengubah jenis tanggal di EMT, Anda dapat menggunakan fungsi
seperti complex().


\>complex(1:4)


    [ 1+0i ,  2+0i ,  3+0i ,  4+0i  ]

Konversi ke string hanya dimungkinkan untuk tipe data dasar. Format
saat ini digunakan untuk rangkaian string sederhana. Tetapi ada fungsi
seperti print() atau frac().


Untuk vektor, Anda dapat dengan mudah menulis fungsi Anda sendiri.


\>function tostr (v) ...


    s="[";
    loop 1 to length(v);
       s=s+print(v[#],2,0);
       if #<length(v) then s=s+","; endif;
    end;
    return s+"]";
    endfunction
</pre>
\>tostr(linspace(0,1,10))


    [0.00,0.10,0.20,0.30,0.40,0.50,0.60,0.70,0.80,0.90,1.00]

Untuk komunikasi dengan Maxima, terdapat fungsi convertmxm(), yang
juga dapat digunakan untuk memformat vektor untuk output.


\>convertmxm(1:10)


    [1,2,3,4,5,6,7,8,9,10]

Untuk Latex perintah tex dapat digunakan untuk mendapatkan perintah
Latex.


\>tex(&[1,2,3])


    \left[ 1 , 2 , 3 \right] 

# Faktor dan Tabel

Dalam pengantar R ada contoh dengan apa yang disebut faktor.


Berikut ini adalah daftar wilayah dari 30 negara bagian.


\>austates = ["tas", "sa", "qld", "nsw", "nsw", "nt", "wa", "wa", ...  
\>   "qld", "vic", "nsw", "vic", "qld", "qld", "sa", "tas", ...  
\>   "sa", "nt", "wa", "vic", "qld", "nsw", "nsw", "wa", ...  
\>   "sa", "act", "nsw", "vic", "vic", "act"];


Asumsikan, kita memiliki pendapatan yang sesuai di setiap negara
bagian.


\>incomes = [60, 49, 40, 61, 64, 60, 59, 54, 62, 69, 70, 42, 56, ...  
\>   61, 61, 61, 58, 51, 48, 65, 49, 49, 41, 48, 52, 46, ...  
\>   59, 46, 58, 43];


Sekarang, kami ingin menghitung rata-rata pendapatan di wilayah
tersebut. Menjadi program statistik, R memiliki factor() dan tappy()
untuk ini.


EMT dapat melakukannya dengan menemukan indeks wilayah dalam daftar
wilayah yang unik.


\>auterr=sort(unique(austates)); f=indexofsorted(auterr,austates)


    [6,  5,  4,  2,  2,  3,  8,  8,  4,  7,  2,  7,  4,  4,  5,  6,  5,  3,
    8,  7,  4,  2,  2,  8,  5,  1,  2,  7,  7,  1]

Pada titik itu, kita dapat menulis fungsi loop kita sendiri untuk
melakukan sesuatu hanya untuk satu faktor.


Atau kita bisa meniru fungsi tapply() dengan cara berikut.


\>function map tappl (i; f$:call, cat, x) ...


    u=sort(unique(cat));
    f=indexof(u,cat);
    return f$(x[nonzeros(f==indexof(u,i))]);
    endfunction
</pre>
Ini agak tidak efisien, karena menghitung wilayah unik untuk setiap i,
tetapi berhasil.


\>tappl(auterr,"mean",austates,incomes)


    [44.5,  57.3333333333,  55.5,  53.6,  55,  60.5,  56,  52.25]

Perhatikan bahwa ini berfungsi untuk setiap vektor wilayah.


\>tappl(["act","nsw"],"mean",austates,incomes)


    [44.5,  57.3333333333]

Sekarang, paket statistik EMT mendefinisikan tabel seperti di R.
Fungsi readtable() dan writetable() dapat digunakan untuk input dan
output.


Jadi kita bisa mencetak rata-rata pendapatan negara di wilayah dengan
cara yang bersahabat.


\>writetable(tappl(auterr,"mean",austates,incomes),labc=auterr,wc=7)


        act    nsw     nt    qld     sa    tas    vic     wa
       44.5  57.33   55.5   53.6     55   60.5     56  52.25

Kita juga dapat mencoba meniru perilaku R sepenuhnya.


Faktor-faktor tersebut harus dengan jelas disimpan dalam kumpulan
dengan jenis dan kategori (negara bagian dan teritori dalam contoh
kami). Untuk EMT, kami menambahkan indeks yang telah dihitung
sebelumnya.


\>function makef (t) ...


    ## Factor data
    ## Returns a collection with data t, unique data, indices.
    ## See: tapply
    u=sort(unique(t));
    return {{t,u,indexofsorted(u,t)}};
    endfunction
</pre>
\>statef=makef(austates);


Sekarang elemen ketiga dari koleksi akan berisi indeks.


\>statef[3]


    [6,  5,  4,  2,  2,  3,  8,  8,  4,  7,  2,  7,  4,  4,  5,  6,  5,  3,
    8,  7,  4,  2,  2,  8,  5,  1,  2,  7,  7,  1]

Sekarang kita bisa meniru tapply() dengan cara berikut. Ini akan
mengembalikan tabel sebagai kumpulan data tabel dan judul kolom.


\>function tapply (t:vector,tf,f$:call) ...


    ## Makes a table of data and factors
    ## tf : output of makef()
    ## See: makef
    uf=tf[2]; f=tf[3]; x=zeros(length(uf));
    for i=1 to length(uf);
       ind=nonzeros(f==i);
       if length(ind)==0 then x[i]=NAN;
       else x[i]=f$(t[ind]);
       endif;
    end;
    return {{x,uf}};
    endfunction
</pre>
Kami tidak menambahkan banyak jenis pengecekan di sini. Satu-satunya
tindakan pencegahan menyangkut kategori (faktor) tanpa data. Tetapi
orang harus memeriksa panjang t yang benar dan kebenaran koleksi tf.


Tabel ini dapat dicetak sebagai tabel dengan writetable().


\>writetable(tapply(incomes,statef,"mean"),wc=7)


        act    nsw     nt    qld     sa    tas    vic     wa
       44.5  57.33   55.5   53.6     55   60.5     56  52.25

# Array

EMT hanya memiliki dua dimensi untuk array. Tipe datanya disebut
matriks. Akan mudah untuk menulis fungsi untuk dimensi yang lebih
tinggi atau pustaka C untuk ini.


R memiliki lebih dari dua dimensi. Dalam R array adalah vektor dengan
bidang dimensi.


Dalam EMT, vektor adalah matriks dengan satu baris. Itu dapat dibuat
menjadi matriks dengan redim().


\>shortformat; X=redim(1:20,4,5)


            1         2         3         4         5 
            6         7         8         9        10 
           11        12        13        14        15 
           16        17        18        19        20 

Ekstraksi baris dan kolom, atau sub-matriks, sangat mirip dengan R.


\>X[,2:3]


            2         3 
            7         8 
           12        13 
           17        18 

Namun, dalam R dimungkinkan untuk menetapkan daftar indeks spesifik
dari vektor ke suatu nilai. Hal yang sama dimungkinkan di EMT hanya
dengan loop.


\>function setmatrixvalue (M, i, j, v) ...


    loop 1 to max(length(i),length(j),length(v))
       M[i{#},j{#}] = v{#};
    end;
    endfunction
</pre>
Kami mendemonstrasikan ini untuk menunjukkan bahwa matriks dilewatkan
dengan referensi di EMT. Jika Anda tidak ingin mengubah matriks asli
M, Anda perlu menyalinnya ke dalam fungsi.


\>setmatrixvalue(X,1:3,3:-1:1,0); X,


            1         2         0         4         5 
            6         0         8         9        10 
            0        12        13        14        15 
           16        17        18        19        20 

Perkalian luar dalam EMT hanya dapat dilakukan antar vektor. Ini
otomatis karena bahasa matriks. Satu vektor harus menjadi vektor kolom
dan yang lainnya vektor baris.


\>(1:5)\*(1:5)'


            1         2         3         4         5 
            2         4         6         8        10 
            3         6         9        12        15 
            4         8        12        16        20 
            5        10        15        20        25 

Dalam pengantar PDF untuk R ada sebuah contoh, yang menghitung
distribusi ab-cd untuk a,b,c,d yang dipilih dari 0 hingga n secara
acak. Solusi dalam R adalah membentuk matriks 4 dimensi dan
menjalankan table() di atasnya.


Tentu saja, ini dapat dicapai dengan loop. Tapi loop tidak efektif di
EMT atau R. Di EMT, kita bisa menulis loop di C dan itu akan menjadi
solusi tercepat.


Tapi kita ingin meniru perilaku R. Untuk ini, kita perlu meratakan
perkalian ab dan membuat matriks ab-cd.


\>a=0:6; b=a'; p=flatten(a\*b); q=flatten(p-p'); ...  
\>   u=sort(unique(q)); f=getmultiplicities(u,q); ...  
\>   statplot(u,f,"h"):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-046.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-046.png)

Selain multiplisitas yang tepat, EMT dapat menghitung frekuensi dalam
vektor.


\>getfrequencies(q,-50:10:50)


    [0,  23,  132,  316,  602,  801,  333,  141,  53,  0]

The most easy way to plot this as a distribution is the following.


\>plot2d(q,distribution=11):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-047.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-047.png)

Tetapi juga memungkinkan untuk menghitung sebelumnya hitungan dalam
interval yang dipilih sebelumnya. Tentu saja, berikut ini menggunakan
getfrequencies() secara internal.


Karena fungsi histo() mengembalikan frekuensi, kita perlu
menskalakannya sehingga integral di bawah grafik batang adalah 1.


\>{x,y}=histo(q,v=-55:10:55); y=y/sum(y)/differences(x); ...  
\>   plot2d(x,y,\>bar,style="/"):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-048.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-048.png)

# Daftar

EMT memiliki dua macam daftar. Salah satunya adalah daftar global yang
dapat diubah, dan yang lainnya adalah jenis daftar yang tidak dapat
diubah. Kami tidak peduli dengan daftar global di sini.


Jenis daftar yang tidak dapat diubah disebut koleksi di EMT. Itu
berperilaku seperti struktur di C, tetapi elemennya hanya diberi nomor
dan tidak diberi nama.


\>L={{"Fred","Flintstone",40,[1990,1992]}}


    Fred
    Flintstone
    40
    [1990,  1992]

Saat ini elemen tidak memiliki nama, meskipun nama dapat ditetapkan
untuk tujuan khusus. Mereka diakses dengan angka.


\>(L[4])[2]


    1992

# File Input dan Output (Membaca dan Menulis Data)

Anda akan sering ingin mengimpor matriks data dari sumber lain ke EMT.
Tutorial ini memberi tahu Anda tentang banyak cara untuk mencapai ini.
Fungsi sederhana adalah writematrix() dan readmatrix().


Mari kita tunjukkan cara membaca dan menulis vektor real ke file.


\>a=random(1,100); mean(a), dev(a),


    0.52081
    0.28079

Untuk menulis data ke file, kita menggunakan fungsi writematrix().


Karena pengenalan ini kemungkinan besar berada di direktori, di mana
pengguna tidak memiliki akses tulis, kami menulis data ke direktori
home pengguna. Untuk notebook sendiri, ini tidak perlu, karena file
data akan ditulis ke dalam direktori yang sama.


\>filename="test.dat";


Untuk menulis data ke file, kita menggunakan fungsi writematrix().


Karena pengenalan ini kemungkinan besar berada di direktori, di mana
pengguna tidak memiliki akses, kami menulis data ke direktori home
pengguna. Untuk notebook itu sendiri, ini tidak perlu, karena data
file akan ditulis ke dalam direktori yang sama.


\>writematrix(a',filename);


Untuk membaca data, kami menggunakan readmatrix().


\>a=readmatrix(filename)';


Dan hapus filenya.


\>fileremove(filename);

\>mean(a), dev(a),


    0.52081
    0.28079

Fungsi writematrix() atau writetable() dapat dikonfigurasi untuk
bahasa lain.


Misalnya, jika Anda memiliki sistem Indonesia (titik desimal dengan
koma), Excel Anda memerlukan nilai dengan koma desimal yang dipisahkan
oleh titik koma dalam file csv (defaultnya adalah nilai yang
dipisahkan koma). File "test.csv" berikut akan muncul di folder
cuurent Anda.


\>filename="test.csv"; ...  
\>   writematrix(random(5,3),file=filename,separator=",");


Anda sekarang dapat membuka file ini dengan Excel Indonesia secara
langsung.


\>fileremove(filename);


Terkadang kita memiliki string dengan token seperti berikut ini.


\>s1:="f m m f m m m f f f m m f";  ...  
\>   s2:="f f f m m f f";


Untuk tokenize ini, kami mendefinisikan vektor token.


\>tok:=["f","m"]


    f
    m

Kemudian kita dapat menghitung berapa kali setiap token muncul dalam
string, dan memasukkan hasilnya ke dalam tabel.


\>M:=getmultiplicities(tok,strtokens(s1))\_ ...  
\>     getmultiplicities(tok,strtokens(s2));


Tulis tabel dengan header token.


\>writetable(M,labc=tok,labr=1:2,wc=8)


                   f       m
           1       6       7
           2       5       2

Untuk statika, EMT dapat membaca dan menulis tabel.


\>file="test.dat"; open(file,"w"); ...  
\>   writeln("A,B,C"); writematrix(random(3,3)); ...  
\>   close();


Filenya terlihat seperti ini.


\>printfile(file)


    A,B,C
    0.3359459915922067,0.1003100292414206,0.1441504984408581
    0.6724340692893117,0.1221005061541419,0.6414330650688198
    0.18523620709082,0.7738673262199027,0.1076645260450825
    

Fungsi readtable() dalam bentuknya yang paling sederhana dapat membaca
ini dan mengembalikan kumpulan nilai dan baris judul.


\>L=readtable(file,\>list);


Koleksi ini dapat dicetak dengan writetable() ke notebook, atau ke
file.


\>writetable(L,wc=10,dc=5)


             A         B         C
       0.33595   0.10031   0.14415
       0.67243    0.1221   0.64143
       0.18524   0.77387   0.10766

Matriks nilai adalah elemen pertama dari L. Perhatikan bahwa mean()
dalam EMT menghitung nilai rata-rata dari baris matriks.


\>mean(L[1])


      0.19347 
      0.47866 
      0.35559 

# File CSV

Pertama, mari kita menulis matriks ke dalam file. Untuk output, kami
membuat file di direktori kerja saat ini.


\>file="test.csv";  ...  
\>   M=random(3,3); writematrix(M,file);


Berikut adalah isi dari file ini.


\>printfile(file)


    0.09340943300156007,0.1566442722989075,0.9010640222534733
    0.3149082938987785,0.775600886403618,0.9521922501438955
    0.4885882891388632,1.871725618418622e-05,0.5768154058741916
    

CVS ini dapat dibuka pada sistem bahasa Inggris ke Excel dengan klik
dua kali. Jika Anda mendapatkan file seperti itu di sistem Jerman,
Anda perlu mengimpor data ke Excel dengan memperhatikan titik desimal.


Tetapi titik desimal juga merupakan format default untuk EMT. Anda
dapat membaca matriks dari file dengan readmatrix().


\>readmatrix(file)


     0.093409   0.15664   0.90106 
      0.31491    0.7756   0.95219 
      0.48859 1.8717e-05   0.57682 

Dimungkinkan untuk menulis beberapa matriks ke satu file. Perintah
open() dapat membuka file untuk ditulis dengan parameter "w".
Standarnya adalah "r" untuk membaca.


\>open(file,"w"); writematrix(M); writematrix(M'); close();


Matriks dipisahkan oleh garis kosong. Untuk membaca matriks, buka file
dan panggil readmatrix() beberapa kali.


\>open(file); A=readmatrix(); B=readmatrix(); A==B, close();


            1         0         0 
            0         1         0 
            0         0         1 

Di Excel atau spreadsheet serupa, Anda dapat mengekspor matriks
sebagai CSV (nilai yang dipisahkan koma). Di Excel 2007, gunakan
"simpan sebagai" dan "format lain", lalu pilih "CSV". Pastikan, tabel
saat ini hanya berisi data yang ingin Anda ekspor.


Berikut adalah contoh.


\>printfile("excel-data.csv")


    Could not open the file
    excel-data.csv
    for reading!
    Try "trace errors" to inspect local variables after errors.
    printfile:
        open(filename,"r");

Seperti yang Anda lihat, sistem Jerman saya menggunakan titik koma
sebagai pemisah dan koma desimal. Anda dapat mengubah ini di
pengaturan sistem atau di Excel, tetapi tidak perlu membaca matriks ke
dalam EMT.


Cara termudah untuk membaca ini ke dalam Euler adalah readmatrix().
Semua koma diganti dengan titik dengan parameter &gt;comma. Untuk CSV
bahasa Inggris, cukup abaikan parameter ini.


\>M=readmatrix("excel-data.csv",\>comma)


    Could not open the file
    excel-data.csv
    for reading!
    Try "trace errors" to inspect local variables after errors.
    readmatrix:
        if filename&lt;&gt;"" then open(filename,"r"); endif;

Mari kita plot ini.


\>plot2d(M'[1],M'[2:3],\>points,color=[red,green]'):


![images/Nur%20Alya%20Fadilah_23030630096_Statistika-049.png](images/Nur%20Alya%20Fadilah_23030630096_Statistika-049.png)

Ada cara yang lebih mendasar untuk membaca data dari file. Anda dapat
membuka file dan membaca angka baris demi baris. Fungsi
getvectorline() akan membaca angka dari baris data. Secara default, ia
mengharapkan titik desimal. Tapi itu juga bisa menggunakan koma
desimal, jika Anda memanggil setdecimaldot(",") sebelum Anda
menggunakan fungsi ini.


Fungsi berikut adalah contoh untuk ini. Ini akan berhenti di akhir
file atau baris kosong.


\>function myload (file) ...


    open(file);
    M=[];
    repeat
       until eof();
       v=getvectorline(3);
       if length(v)>0 then M=M_v; else break; endif;
    end;
    return M;
    close(file);
    endfunction
</pre>
\>myload(file)


     0.093409         0   0.15664         0   0.90106 
      0.31491         0    0.7756         0   0.95219 
      0.48859       0.1         0         0   0.57682 

Dimungkinkan juga untuk membaca semua angka dalam file itu dengan
getvector().


\>open(file); v=getvector(10000); close(); redim(v[1:9],3,3)


     0.093409         0   0.15664 
            0   0.90106   0.31491 
            0    0.7756         0 

Jadi sangat mudah untuk menyimpan vektor nilai, satu nilai di setiap
baris dan membaca kembali vektor ini.


\>v=random(1000); mean(v)


    0.5121

\>writematrix(v',file); mean(readmatrix(file)')


    0.5121

# Menggunakan Tabel

Tabel dapat digunakan untuk membaca atau menulis data numerik. Sebagai
contoh, kami menulis tabel dengan header baris dan kolom ke file.


\>file="test.tab"; M=random(3,3);  ...  
\>   open(file,"w");  ...  
\>   writetable(M,separator=",",labc=["one","two","three"]);  ...  
\>   close(); ...  
\>   printfile(file)


    one,two,three
          0.72,      0.77,      0.38
          0.01,      0.06,      0.29
          0.23,      0.22,      0.82

Ini dapat diimpor ke Excel.


Untuk membaca file dalam EMT, kami menggunakan readtable().


\>{M,headings}=readtable(file,\>clabs); ...  
\>   writetable(M,labc=headings)


           one       two     three
          0.72      0.77      0.38
          0.01      0.06      0.29
          0.23      0.22      0.82

# Menganalisis Garis

Anda bahkan dapat mengevaluasi setiap baris dengan tangan. Misalkan,
kita memiliki garis dengan format berikut.


\>line="2020-11-03,Tue,1'114.05"


    2020-11-03,Tue,1'114.05

Pertama kita dapat menandai garis.


\>vt=strtokens(line)


    2020-11-03
    Tue
    1'114.05

Kemudian kita dapat mengevaluasi setiap elemen garis menggunakan
evaluasi yang sesuai.


\>day(vt[1]),  ...  
\>   indexof(["mon","tue","wed","thu","fri","sat","sun"],tolower(vt[2])),  ...  
\>   strrepl(vt[3],"'","")()


    7.3816e+05
    2
    1114

Menggunakan ekspresi reguler, dimungkinkan untuk mengekstrak hampir
semua informasi dari baris data.


Asumsikan kita memiliki baris berikut dokumen HTML.


\>line="<tr\><td\>1145.45</td\><td\>5.6</td\><td\>-4.5</td\><tr\>"


    &lt;tr&gt;&lt;td&gt;1145.45&lt;/td&gt;&lt;td&gt;5.6&lt;/td&gt;&lt;td&gt;-4.5&lt;/td&gt;&lt;tr&gt;

Untuk mengekstrak ini, kami menggunakan ekspresi reguler, yang mencari


  - kurung tutup &gt;,  
  - string apa pun yang tidak mengandung tanda kurung dengan  

sub-pertandingan "(...)",


  - braket pembuka dan penutup menggunakan solusi terpendek,


  - lagi string apa pun yang tidak mengandung tanda kurung,


  - dan kurung buka &lt;.


Ekspresi reguler agak sulit dipelajari tetapi sangat kuat.


\>{pos,s,vt}=strxfind(line,"\>([^<\>]+)<.+?\>([^<\>]+)<");


Hasilnya adalah posisi kecocokan, string yang cocok, dan vektor string
untuk sub-pertandingan.


\>for k=1:length(vt); vt[k](), end;


    1145.5
    5.6

Berikut adalah fungsi, yang membaca semua item numerik antara &lt;td&gt; dan
&lt;/td&gt;.


\>function readtd (line) ...


    v=[]; cp=0;
    repeat
       {pos,s,vt}=strxfind(line,"<td.*?>(.+?)</td>",cp);
       until pos==0;
       if length(vt)>0 then v=v|vt[1]; endif;
       cp=pos+strlen(s);
    end;
    return v;
    endfunction
</pre>
\>readtd(line+"<td\>non-numerical</td\>")


    1145.45
    5.6
    -4.5
    non-numerical

# Membaca dari Web

Situs web atau file dengan URL dapat dibuka di EMT dan dapat dibaca
baris demi baris.


Dalam contoh, kami membaca versi saat ini dari situs EMT. Kami
menggunakan ekspresi reguler untuk memindai "Versi ..." dalam sebuah
judul.


\>function readversion () ...


    urlopen("http://www.euler-math-toolbox.de/Programs/Changes.html");
    repeat
      until urleof();
      s=urlgetline();
      k=strfind(s,"Version ",1);
      if k>0 then substring(s,k,strfind(s,"<",k)-1), break; endif;
    end;
    urlclose();
    endfunction
</pre>
\>readversion


    Version 2024-01-12

# Input dan Output Variabel

Anda dapat menulis variabel dalam bentuk definisi Euler ke file atau
ke baris perintah.


\>writevar(pi,"mypi");


    mypi = 3.141592653589793;

Untuk pengujian, kami membuat file Euler di direktori kerja EMT.


\>file="test.e"; ...  
\>   writevar(random(2,2),"M",file); ...  
\>   printfile(file,3)


    M = [ ..
    0.6407974941971651, 0.3156871990456301;
    0.01349215588850586, 0.01387671156764053];

Kita sekarang dapat memuat file. Ini akan mendefinisikan matriks M.


\>load(file); show M,


    M = 
       0.6408   0.31569 
     0.013492  0.013877 

Omong-omong, jika writevar() digunakan pada variabel, itu akan
mencetak definisi variabel dengan nama variabel ini.


\>writevar(M); writevar(inch$)


    M = [ ..
    0.6407974941971651, 0.3156871990456301;
    0.01349215588850586, 0.01387671156764053];
    inch$ = 0.0254;

Kita juga bisa membuka file baru atau menambahkan file yang sudah ada.
Dalam contoh kami menambahkan file yang dihasilkan sebelumnya.


\>open(file,"a"); ...  
\>   writevar(random(2,2),"M1"); ...  
\>   writevar(random(3,1),"M2"); ...  
\>   close();

\>load(file); show M1; show M2;


    M1 = 
      0.11526   0.37761 
      0.19764   0.99965 
    M2 = 
       0.1757 
      0.18207 
      0.72022 

Untuk menghapus file apa pun, gunakan fileremove().


\>fileremove(file);


Vektor baris dalam file tidak memerlukan koma, jika setiap angka
berada di baris baru. Mari kita buat file seperti itu, menulis setiap
baris satu per satu dengan writeln().


\>open(file,"w"); writeln("M = ["); ...  
\>   for i=1 to 5; writeln(""+random()); end; ...  
\>   writeln("];"); close(); ...  
\>   printfile(file)


    M = [
    0.18863342704
    0.413824288722
    0.735141486156
    0.842383658328
    0.919588709327
    ];

\>load(file); M


    [0.18863,  0.41382,  0.73514,  0.84238,  0.91959]


\maketitle

\section{Introduction}

\end{document}
